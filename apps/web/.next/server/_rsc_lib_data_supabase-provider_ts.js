"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_lib_data_supabase-provider_ts";
exports.ids = ["_rsc_lib_data_supabase-provider_ts"];
exports.modules = {

/***/ "(rsc)/./lib/data/supabase-provider.ts":
/*!***************************************!*\
  !*** ./lib/data/supabase-provider.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSupabaseProvider: () => (/* binding */ createSupabaseProvider)\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(rsc)/./lib/supabase.ts\");\n// lib/data/supabase-provider.ts\n\n/* ----------------- helpers ----------------- */ function isPlaceholder(x) {\n    if (x === null || x === undefined) return true;\n    const s = String(x).trim();\n    return s === \"\" || s === \"-\" || s === \"—\" || s.toLowerCase() === \"n/a\";\n}\n// Parse common date formats → timestamp (ms). Handles ISO and M/D/YYYY (and D/M/YYYY when obvious).\nfunction ts(d) {\n    if (!d) return 0;\n    const s = String(d).trim();\n    // Try native parser first (works for ISO like 2025-09-25)\n    const t = Date.parse(s);\n    if (!Number.isNaN(t)) return t;\n    // Try M/D/YYYY or D/M/YYYY\n    const m = s.match(/^(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{2,4})$/);\n    if (m) {\n        const a = parseInt(m[1], 10);\n        const b = parseInt(m[2], 10);\n        const y = m[3].length === 2 ? 2000 + parseInt(m[3], 10) : parseInt(m[3], 10);\n        // If first number >12, it's D/M/Y; otherwise assume M/D/Y\n        const isDMY = a > 12;\n        const month = isDMY ? b - 1 : a - 1;\n        const day = isDMY ? a : b;\n        return new Date(y, month, day).getTime();\n    }\n    return 0; // fall back\n}\nfunction toNum(x) {\n    if (x === null || x === undefined) return null;\n    const s = String(x).replace(/,/g, \"\").trim();\n    if (isPlaceholder(s)) return null;\n    const n = Number(s);\n    return Number.isFinite(n) ? n : null;\n}\nfunction pick(...vals) {\n    for (const v of vals){\n        if (v === null || v === undefined) continue;\n        if (typeof v === \"string\" && isPlaceholder(v)) continue;\n        return v;\n    }\n    return null;\n}\n// exact, case-insensitive match for ILIKE (escape % and _)\nfunction escapeLikeExact(s) {\n    return s.replace(/[%_]/g, (m)=>`\\\\${m}`);\n}\nfunction prefixToSection(key) {\n    const k = (key || \"\").toLowerCase();\n    if (k.startsWith(\"hema_\")) return \"Hematology\";\n    if (k.startsWith(\"chem_\")) return \"Blood Chemistry\";\n    if (k.startsWith(\"fa_\")) return \"Fecalysis\";\n    if (k.startsWith(\"ua_\")) return \"Urinalysis\";\n    if (k.startsWith(\"sero_\")) return \"Serology\";\n    return \"Others\";\n}\n/* ---------- default per-section order (fallback when no ranges.order) ---------- */ const DEFAULT_ORDER = {\n    Hematology: [\n        \"hema_wbc\",\n        \"hema_lymph\",\n        \"hema_mid\",\n        \"hema_gran\",\n        \"hema_rbc\",\n        \"hema_hgb\",\n        \"hema_hct\",\n        \"hema_mcv\",\n        \"hema_mch\",\n        \"hema_mchc\",\n        \"hema_plt\",\n        \"hema_bt\",\n        \"hema_remarks\"\n    ],\n    \"Blood Chemistry\": [\n        \"chem_ogbase\",\n        \"chem_og1st\",\n        \"chem_og2nd\",\n        \"chem_fbs\",\n        \"chem_rbs\",\n        \"chem_hba1c\",\n        \"chem_chole\",\n        \"chem_trigly\",\n        \"chem_hdl\",\n        \"chem_ldl\",\n        \"chem_vldl\",\n        \"chem_bun\",\n        \"chem_crea\",\n        \"chem_bua\",\n        \"chem_ast\",\n        \"chem_alt\",\n        \"chem_tsh\",\n        \"chem_ft3\",\n        \"chem_ft4\",\n        \"chem_t3\",\n        \"chem_t4\",\n        \"chem_psa\",\n        \"chem_remarks\"\n    ],\n    Urinalysis: [\n        \"ua_color\",\n        \"ua_trans\",\n        \"ua_glu\",\n        \"ua_pro\",\n        \"ua_ph\",\n        \"ua_sg\",\n        \"blood\",\n        \"ua_bilirubin\",\n        \"ua_urobili\",\n        \"ua_ketones\",\n        \"ua_nitrites\",\n        \"ua_le\",\n        \"ua_cast\",\n        \"ua_casttype\",\n        \"ua_crystals\",\n        \"ua_crystalstype\",\n        \"ua_epi\",\n        \"ua_muc\",\n        \"ua_ura\",\n        \"ua_pho\",\n        \"ua_bac\",\n        \"ua_pus\",\n        \"ua_rbc\",\n        \"ua_remarks\"\n    ],\n    Fecalysis: [\n        \"fa_color\",\n        \"fa_cons\",\n        \"fa_pus\",\n        \"fa_rbc\",\n        \"fa_bac\",\n        \"fa_yeast\",\n        \"fa_fat\",\n        \"fa_para\",\n        \"fa_paratype\",\n        \"fa_fobt\",\n        \"fa_remarks\"\n    ],\n    Serology: [\n        \"sero_dengns1\",\n        \"sero_dengm\",\n        \"sero_dengg\",\n        \"sero_hepab\",\n        \"sero_rpv\",\n        \"sero_hiv\",\n        \"sero_hcv\",\n        \"sero_pt\",\n        \"sero_remarks\"\n    ],\n    Others: []\n};\nfunction buildOrderIndex(rangesRows) {\n    const byKeyOrder = new Map();\n    // ranges may have order-like columns; use first that exists\n    for (const r of rangesRows){\n        const key = String(r.analyte_key ?? r.key ?? r.parameter_key ?? r.param_key ?? \"\").trim();\n        if (!key) continue;\n        const orderRaw = r.order ?? r.sort_order ?? r.rank ?? r.prio ?? null;\n        const orderNum = toNum(orderRaw);\n        if (orderNum !== null) byKeyOrder.set(key, orderNum);\n    }\n    return byKeyOrder;\n}\nfunction sortItemsInSections(sections, rangesRows) {\n    const orderIndex = buildOrderIndex(rangesRows);\n    return sections.map((sec)=>{\n        const defaults = DEFAULT_ORDER[sec.name] ?? [];\n        const defaultIndex = new Map();\n        defaults.forEach((k, i)=>defaultIndex.set(k, i));\n        const items = [\n            ...sec.items\n        ].sort((a, b)=>{\n            const ao = orderIndex.get(a.key);\n            const bo = orderIndex.get(b.key);\n            if (ao !== undefined || bo !== undefined) {\n                if (ao === undefined) return 1;\n                if (bo === undefined) return -1;\n                return ao - bo;\n            }\n            const ad = defaultIndex.get(a.key);\n            const bd = defaultIndex.get(b.key);\n            if (ad !== undefined || bd !== undefined) {\n                if (ad === undefined) return 1;\n                if (bd === undefined) return -1;\n                return ad - bd;\n            }\n            // final fallback: alphabetical by label then key\n            const al = (a.label || \"\").toLowerCase();\n            const bl = (b.label || \"\").toLowerCase();\n            if (al !== bl) return al < bl ? -1 : 1;\n            return (a.key || \"\").localeCompare(b.key || \"\");\n        });\n        return {\n            ...sec,\n            items\n        };\n    });\n}\nfunction createSupabaseProvider() {\n    const TABLE_PATIENTS = \"patients\";\n    const TABLE_RESULTS = \"results_flat\";\n    const TABLE_RANGES = \"ranges\";\n    const TABLE_VITALS = \"vitals_snapshots\";\n    const TABLE_RESULTS_WIDE = \"results_wide\";\n    const db = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.getSupabase)();\n    // cache ranges + raw rows (for ordering)\n    let rangesCache = null;\n    let rangesRowsCache = null;\n    async function getRangesMap() {\n        if (rangesCache && rangesRowsCache) return {\n            map: rangesCache,\n            rows: rangesRowsCache\n        };\n        const { data, error } = await db.from(TABLE_RANGES).select(\"*\");\n        if (error) throw error;\n        const rows = data || [];\n        const map = new Map();\n        for (const r of rows){\n            const key = String(r.analyte_key ?? r.key ?? r.parameter_key ?? r.param_key ?? \"\").trim();\n            if (!key) continue;\n            const section = (r.section ?? r.group ?? r.category ?? null) || prefixToSection(key);\n            const label = (r.item_label ?? r.display_name ?? r.label ?? r.name ?? null) || null;\n            const unit = r.unit ?? r.units ?? r.uom ?? null;\n            // Your ranges use \"low\"/\"high\" (may be text); keep raw for display, numeric for flag logic\n            const low = r.low ?? null;\n            const high = r.high ?? null;\n            map.set(key, {\n                section,\n                label,\n                unit,\n                low,\n                high\n            });\n        }\n        rangesCache = map;\n        rangesRowsCache = rows;\n        return {\n            map,\n            rows\n        };\n    }\n    async function fetchVitalsSnapshots(patient_id, opts) {\n        const pid = escapeLikeExact(String(patient_id || \"\").trim());\n        let query = db.from(TABLE_VITALS).select(\"*\").ilike(\"patient_id\", pid).order(\"measured_at\", {\n            ascending: false\n        });\n        if (opts?.consultation_id) query = query.eq(\"consultation_id\", opts.consultation_id);\n        if (opts?.encounter_id) query = query.eq(\"encounter_id\", opts.encounter_id);\n        query = query.limit(opts?.limit ?? 8);\n        const { data, error } = await query;\n        if (error) throw error;\n        const rows = (data || []).map((r)=>({\n                id: String(r.id),\n                patient_id: String(r.patient_id),\n                consultation_id: String(r.consultation_id),\n                encounter_id: String(r.encounter_id),\n                measured_at: r.measured_at ?? r.created_at ?? new Date().toISOString(),\n                systolic_bp: toNum(r.systolic_bp),\n                diastolic_bp: toNum(r.diastolic_bp),\n                hr: toNum(r.hr),\n                rr: toNum(r.rr),\n                temp_c: r.temp_c == null ? null : Number(r.temp_c),\n                height_cm: r.height_cm == null ? null : Number(r.height_cm),\n                weight_kg: r.weight_kg == null ? null : Number(r.weight_kg),\n                bmi: r.bmi == null ? null : Number(r.bmi),\n                o2sat: toNum(r.o2sat),\n                notes: r.notes ?? null,\n                source: r.source ?? null,\n                created_at: r.created_at ?? null,\n                created_by_initials: r.created_by_initials ?? null\n            }));\n        return {\n            latest: rows[0] ?? null,\n            history: rows\n        };\n    }\n    async function fallbackPatientFromResults(patient_id) {\n        const pid = escapeLikeExact(String(patient_id || \"\").trim());\n        const { data, error } = await db.from(TABLE_RESULTS_WIDE).select(\"*\").ilike(\"patient_id\", pid).order(\"date_of_test\", {\n            ascending: false\n        }).limit(1).maybeSingle();\n        if (error) throw error;\n        if (!data) return null;\n        const vitals = await fetchVitalsSnapshots(patient_id).catch(()=>({\n                latest: null,\n                history: []\n            }));\n        return {\n            patient_id: data.patient_id ?? patient_id,\n            full_name: data.full_name ?? \"\",\n            sex: data.sex ?? \"\",\n            age: data.age ?? \"\",\n            birthday: data.birthday ?? \"\",\n            contact: data.contact ?? \"\",\n            address: data.address ?? \"\",\n            email: data.email ?? \"\",\n            systolic_bp: \"\",\n            diastolic_bp: \"\",\n            height_ft: \"\",\n            height_inch: \"\",\n            weight_kg: \"\",\n            medications_current: \"\",\n            medications: \"\",\n            family_history: \"\",\n            smoking_hx: \"\",\n            alcohol_hx: \"\",\n            vitals,\n            last_updated: data.last_updated ?? \"\"\n        };\n    }\n    async function listVisitRows(patient_id) {\n        const pid = escapeLikeExact(String(patient_id || \"\").trim());\n        const { data, error } = await db.from(TABLE_RESULTS).select(\"date_of_test, barcode, branch, notes\").ilike(\"patient_id\", pid);\n        if (error) throw error;\n        if (data && data.length > 0) {\n            return data.map((r)=>({\n                    date_of_test: String(r.date_of_test ?? \"\").trim(),\n                    barcode: r.barcode ?? \"\",\n                    branch: r.branch ?? \"\",\n                    notes: r.notes ?? \"\"\n                }));\n        }\n        // Fallback to wide table for legacy rows\n        const { data: wide, error: wideError } = await db.from(TABLE_RESULTS_WIDE).select(\"date_of_test, barcode, branch, notes\").ilike(\"patient_id\", pid);\n        if (wideError) throw wideError;\n        return (wide || []).map((r)=>({\n                date_of_test: String(r?.date_of_test ?? \"\").trim(),\n                barcode: r?.barcode ?? \"\",\n                branch: r?.branch ?? \"\",\n                notes: r?.notes ?? \"\"\n            }));\n    }\n    async function fetchResultRows(patient_id, visitDate) {\n        const pid = escapeLikeExact(String(patient_id || \"\").trim());\n        let query = db.from(TABLE_RESULTS).select(\"*\").ilike(\"patient_id\", pid);\n        if (visitDate) query = query.eq(\"date_of_test\", visitDate);\n        const { data, error } = await query;\n        if (error) throw error;\n        if (data && data.length > 0) return data;\n        // Fallback to the wide table: explode wide columns into flat rows\n        let wideQuery = db.from(TABLE_RESULTS_WIDE).select(\"*\").ilike(\"patient_id\", pid);\n        if (visitDate) wideQuery = wideQuery.eq(\"date_of_test\", visitDate);\n        const { data: wide, error: wideError } = await wideQuery;\n        if (wideError) throw wideError;\n        if (!wide || wide.length === 0) return [];\n        const skipKeys = new Set([\n            \"patient_id\",\n            \"date_of_test\",\n            \"barcode\",\n            \"notes\",\n            \"branch\",\n            \"id\",\n            \"created_at\",\n            \"updated_at\",\n            \"created_by\",\n            \"updated_by\",\n            \"created_by_initials\"\n        ]);\n        const flat = [];\n        for (const row of wide){\n            const base = {\n                patient_id: row.patient_id ?? patient_id,\n                date_of_test: row.date_of_test ?? visitDate ?? \"\",\n                barcode: row.barcode ?? \"\",\n                notes: row.notes ?? \"\",\n                branch: row.branch ?? \"\"\n            };\n            for (const [key, val] of Object.entries(row)){\n                if (skipKeys.has(key)) continue;\n                if (val === null || val === undefined || isPlaceholder(val)) continue;\n                flat.push({\n                    ...base,\n                    analyte_key: key,\n                    item_key: key,\n                    value: val\n                });\n            }\n        }\n        return flat;\n    }\n    return {\n        async getPatient (patient_id) {\n            const pid = escapeLikeExact(String(patient_id || \"\").trim());\n            const { data, error } = await db.from(TABLE_PATIENTS).select(\"*\").ilike(\"patient_id\", pid).limit(1).maybeSingle();\n            if (error) throw error;\n            if (!data) {\n                // Legacy rows might exist only in results_wide\n                const fallback = await fallbackPatientFromResults(patient_id);\n                if (!fallback) return null;\n                return fallback;\n            }\n            const medsCurrent = data.medications_current ?? \"\";\n            const vitals = await fetchVitalsSnapshots(patient_id).catch(()=>({\n                    latest: null,\n                    history: []\n                }));\n            const p = {\n                patient_id: data.patient_id,\n                full_name: data.full_name ?? \"\",\n                sex: data.sex ?? \"\",\n                age: data.age ?? \"\",\n                birthday: data.birthday ?? \"\",\n                contact: data.contact ?? \"\",\n                address: data.address ?? \"\",\n                email: data.email ?? \"\",\n                height_ft: data.height_ft ?? \"\",\n                height_inch: data.height_inch ?? \"\",\n                weight_kg: data.weight_kg ?? \"\",\n                systolic_bp: data.systolic_bp ?? \"\",\n                diastolic_bp: data.diastolic_bp ?? \"\",\n                last_updated: data.last_updated ?? \"\",\n                present_illness_history: data.present_illness_history ?? \"\",\n                past_medical_history: data.past_medical_history ?? \"\",\n                past_surgical_history: data.past_surgical_history ?? \"\",\n                chief_complaint: data.chief_complaint ?? \"\",\n                allergies_text: data.allergies_text ?? \"\",\n                medications_current: medsCurrent,\n                medications: medsCurrent,\n                family_history: data.family_hx ?? \"\",\n                smoking_hx: data.smoking_hx ?? \"\",\n                alcohol_hx: data.alcohol_hx ?? \"\",\n                vitals\n            };\n            return p;\n        },\n        async getVisits (patient_id) {\n            const visitRows = await listVisitRows(patient_id);\n            const seen = new Map();\n            for (const r of visitRows){\n                const date = String(r.date_of_test ?? r.date ?? r.test_date ?? \"\").trim();\n                if (!date || isPlaceholder(date)) continue;\n                if (!seen.has(date)) {\n                    seen.set(date, {\n                        date_of_test: date,\n                        barcode: r.barcode ?? \"\",\n                        branch: r.branch ?? \"\",\n                        notes: r.notes ?? \"\"\n                    });\n                }\n            }\n            return Array.from(seen.values()).sort((a, b)=>ts(b.date_of_test) - ts(a.date_of_test));\n        },\n        async getReport ({ patient_id, visitDate }) {\n            const patient = await this.getPatient(patient_id) || {\n                patient_id,\n                full_name: \"\",\n                vitals: {\n                    latest: null,\n                    history: []\n                }\n            };\n            let date = visitDate;\n            if (!date) {\n                const visits = await this.getVisits(patient_id);\n                date = visits[0]?.date_of_test;\n                if (!date) return null;\n            }\n            const rows = await fetchResultRows(patient_id, date);\n            if (rows.length === 0) return null;\n            const { map: rangesMap, rows: rangesRows } = await getRangesMap();\n            const bySection = new Map();\n            for (const r of rows){\n                const key = String(r.item_key ?? r.analyte_key ?? r.parameter_key ?? r.param_key ?? r.key ?? \"\").trim();\n                const meta = key ? rangesMap.get(key) : undefined;\n                const label = String(pick(r.item_label, r.display_name, r.parameter_label, r.label, meta?.label, key || null) ?? \"\").trim();\n                // unit: never allow \"null\" string\n                const unitRaw = pick(r.unit, r.units, r.uom, meta?.unit);\n                const unit = unitRaw == null ? \"\" : String(unitRaw);\n                // section from ranges or prefix\n                const section = String(pick(r.section, r.item_section, r.dept, r.category, meta?.section, prefixToSection(key || label), \"Others\"));\n                // value: treat \"-\" etc as null; keep numeric if possible for flags\n                const rawVal = pick(r.value, r.result, r.val);\n                const valueNum = toNum(rawVal);\n                const value = valueNum !== null ? valueNum : isPlaceholder(rawVal) ? null : rawVal;\n                // references (display raw, compute flags via numeric)\n                const rawLow = pick(r.ref_low, r.low, meta?.low);\n                const rawHigh = pick(r.ref_high, r.high, meta?.high);\n                const ref_low_display = isPlaceholder(rawLow) ? null : rawLow;\n                const ref_high_display = isPlaceholder(rawHigh) ? null : rawHigh;\n                const refLowNum = toNum(rawLow);\n                const refHighNum = toNum(rawHigh);\n                // flag: prefer DB; else compute L/H only (do NOT show \"N\")\n                let flag = null;\n                const rawFlag = pick(r.flag) ?? null;\n                if (rawFlag) {\n                    const f = String(rawFlag).toUpperCase();\n                    if (f === \"L\" || f === \"H\" || f === \"A\") flag = f;\n                } else if (valueNum !== null) {\n                    if (refLowNum !== null && valueNum < refLowNum) flag = \"L\";\n                    else if (refHighNum !== null && valueNum > refHighNum) flag = \"H\";\n                // else normal → leave null (you don't want \"N\")\n                }\n                const item = {\n                    key,\n                    label,\n                    unit,\n                    value,\n                    ref_low: ref_low_display,\n                    ref_high: ref_high_display,\n                    flag,\n                    method: r.method ?? null,\n                    remarks: r.remarks ?? null\n                };\n                // skip placeholders/blank values entirely (don't render)\n                if (item.value === null || typeof item.value === \"string\" && isPlaceholder(item.value)) {\n                    continue;\n                }\n                const arr = bySection.get(section) ?? [];\n                arr.push(item);\n                bySection.set(section, arr);\n            }\n            // sort items in each section\n            let sections = Array.from(bySection.entries()).map(([name, items])=>({\n                    name,\n                    items\n                })).filter((sec)=>sec.items.some((i)=>i.value !== null && String(i.value).trim() !== \"\"));\n            sections = sortItemsInSections(sections, rangesRows);\n            const first = rows[0] || {};\n            const visit = {\n                date_of_test: date,\n                barcode: first.barcode ?? \"\",\n                branch: first.branch ?? \"\",\n                notes: first.notes ?? \"\"\n            };\n            return {\n                patient,\n                visit,\n                sections\n            };\n        },\n        async searchPatients ({ query, limit = 20, offset = 0 }) {\n            const q = (query || \"\").trim();\n            if (!q) return {\n                results: [],\n                total: 0\n            };\n            const pat = `%${q.replace(/[%_]/g, (m)=>`\\\\${m}`)}%`;\n            const { data, error, count } = await db.from(TABLE_PATIENTS).select(\"patient_id, full_name, sex, age, birthday, contact, address, email\", {\n                count: \"exact\"\n            }).or(`patient_id.ilike.${pat},full_name.ilike.${pat}`).order(\"full_name\", {\n                ascending: true\n            }).range(offset, offset + limit - 1);\n            if (error) throw error;\n            return {\n                results: data || [],\n                total: count ?? undefined\n            };\n        },\n        async getConfig () {\n            return {\n                footer_lines: [],\n                signatories: []\n            };\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBRUMsYUFBYSxFQUFFO1lBQUM7UUFDN0M7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvcG9jaG9sby9Qcm9qZWN0cy93ZWxsc2Vydi1wb3J0YWwvYXBwcy93ZWIvbGliL2RhdGEvc3VwYWJhc2UtcHJvdmlkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL2RhdGEvc3VwYWJhc2UtcHJvdmlkZXIudHNcbmltcG9ydCB0eXBlIHtcbiAgRGF0YVByb3ZpZGVyLFxuICBQYXRpZW50LFxuICBWaXNpdCxcbiAgUmVwb3J0LFxuICBSZXBvcnRTZWN0aW9uLFxuICBSZXBvcnRJdGVtLFxuICBWaXRhbHNTbmFwc2hvdCxcbn0gZnJvbSBcIi4vZGF0YS1wcm92aWRlclwiO1xuaW1wb3J0IHsgZ2V0U3VwYWJhc2UgfSBmcm9tIFwiQC9saWIvc3VwYWJhc2VcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0gaGVscGVycyAtLS0tLS0tLS0tLS0tLS0tLSAqL1xuZnVuY3Rpb24gaXNQbGFjZWhvbGRlcih4OiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKHggPT09IG51bGwgfHwgeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgcyA9IFN0cmluZyh4KS50cmltKCk7XG4gIHJldHVybiBzID09PSBcIlwiIHx8IHMgPT09IFwiLVwiIHx8IHMgPT09IFwi4oCUXCIgfHwgcy50b0xvd2VyQ2FzZSgpID09PSBcIm4vYVwiO1xufVxuXG4vLyBQYXJzZSBjb21tb24gZGF0ZSBmb3JtYXRzIOKGkiB0aW1lc3RhbXAgKG1zKS4gSGFuZGxlcyBJU08gYW5kIE0vRC9ZWVlZIChhbmQgRC9NL1lZWVkgd2hlbiBvYnZpb3VzKS5cbmZ1bmN0aW9uIHRzKGQ6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICBpZiAoIWQpIHJldHVybiAwO1xuICBjb25zdCBzID0gU3RyaW5nKGQpLnRyaW0oKTtcbiAgLy8gVHJ5IG5hdGl2ZSBwYXJzZXIgZmlyc3QgKHdvcmtzIGZvciBJU08gbGlrZSAyMDI1LTA5LTI1KVxuICBjb25zdCB0ID0gRGF0ZS5wYXJzZShzKTtcbiAgaWYgKCFOdW1iZXIuaXNOYU4odCkpIHJldHVybiB0O1xuXG4gIC8vIFRyeSBNL0QvWVlZWSBvciBEL00vWVlZWVxuICBjb25zdCBtID0gcy5tYXRjaCgvXihcXGR7MSwyfSlbXFwvXFwtXShcXGR7MSwyfSlbXFwvXFwtXShcXGR7Miw0fSkkLyk7XG4gIGlmIChtKSB7XG4gICAgY29uc3QgYSA9IHBhcnNlSW50KG1bMV0sIDEwKTtcbiAgICBjb25zdCBiID0gcGFyc2VJbnQobVsyXSwgMTApO1xuICAgIGNvbnN0IHkgPSBtWzNdLmxlbmd0aCA9PT0gMiA/IDIwMDAgKyBwYXJzZUludChtWzNdLCAxMCkgOiBwYXJzZUludChtWzNdLCAxMCk7XG4gICAgLy8gSWYgZmlyc3QgbnVtYmVyID4xMiwgaXQncyBEL00vWTsgb3RoZXJ3aXNlIGFzc3VtZSBNL0QvWVxuICAgIGNvbnN0IGlzRE1ZID0gYSA+IDEyO1xuICAgIGNvbnN0IG1vbnRoID0gaXNETVkgPyBiIC0gMSA6IGEgLSAxO1xuICAgIGNvbnN0IGRheSAgID0gaXNETVkgPyBhICAgICA6IGI7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHksIG1vbnRoLCBkYXkpLmdldFRpbWUoKTtcbiAgfVxuXG4gIHJldHVybiAwOyAvLyBmYWxsIGJhY2tcbn1cblxuZnVuY3Rpb24gdG9OdW0oeDogYW55KTogbnVtYmVyIHwgbnVsbCB7XG4gIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHMgPSBTdHJpbmcoeCkucmVwbGFjZSgvLC9nLCBcIlwiKS50cmltKCk7XG4gIGlmIChpc1BsYWNlaG9sZGVyKHMpKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgbiA9IE51bWJlcihzKTtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShuKSA/IG4gOiBudWxsO1xufVxuZnVuY3Rpb24gcGljazxUPiguLi52YWxzOiBUW10pOiBUIHwgbnVsbCB7XG4gIGZvciAoY29uc3QgdiBvZiB2YWxzKSB7XG4gICAgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgJiYgaXNQbGFjZWhvbGRlcih2KSkgY29udGludWU7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG4vLyBleGFjdCwgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgSUxJS0UgKGVzY2FwZSAlIGFuZCBfKVxuZnVuY3Rpb24gZXNjYXBlTGlrZUV4YWN0KHM6IHN0cmluZykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bJV9dL2csIChtKSA9PiBgXFxcXCR7bX1gKTtcbn1cbmZ1bmN0aW9uIHByZWZpeFRvU2VjdGlvbihrZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGsgPSAoa2V5IHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChrLnN0YXJ0c1dpdGgoXCJoZW1hX1wiKSkgcmV0dXJuIFwiSGVtYXRvbG9neVwiO1xuICBpZiAoay5zdGFydHNXaXRoKFwiY2hlbV9cIikpIHJldHVybiBcIkJsb29kIENoZW1pc3RyeVwiO1xuICBpZiAoay5zdGFydHNXaXRoKFwiZmFfXCIpKSAgIHJldHVybiBcIkZlY2FseXNpc1wiO1xuICBpZiAoay5zdGFydHNXaXRoKFwidWFfXCIpKSAgIHJldHVybiBcIlVyaW5hbHlzaXNcIjtcbiAgaWYgKGsuc3RhcnRzV2l0aChcInNlcm9fXCIpKSByZXR1cm4gXCJTZXJvbG9neVwiO1xuICByZXR1cm4gXCJPdGhlcnNcIjtcbn1cblxuLyogLS0tLS0tLS0tLSBkZWZhdWx0IHBlci1zZWN0aW9uIG9yZGVyIChmYWxsYmFjayB3aGVuIG5vIHJhbmdlcy5vcmRlcikgLS0tLS0tLS0tLSAqL1xuY29uc3QgREVGQVVMVF9PUkRFUjogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge1xuICBIZW1hdG9sb2d5OiBbXG4gICAgXCJoZW1hX3diY1wiLCBcImhlbWFfbHltcGhcIiwgXCJoZW1hX21pZFwiLCBcImhlbWFfZ3JhblwiLFxuICAgIFwiaGVtYV9yYmNcIiwgXCJoZW1hX2hnYlwiLCBcImhlbWFfaGN0XCIsIFwiaGVtYV9tY3ZcIiwgXCJoZW1hX21jaFwiLCBcImhlbWFfbWNoY1wiLFxuICAgIFwiaGVtYV9wbHRcIiwgXCJoZW1hX2J0XCIsIFwiaGVtYV9yZW1hcmtzXCIsXG4gIF0sXG4gIFwiQmxvb2QgQ2hlbWlzdHJ5XCI6IFtcbiAgICBcImNoZW1fb2diYXNlXCIsIFwiY2hlbV9vZzFzdFwiLCBcImNoZW1fb2cybmRcIiwgXCJjaGVtX2Zic1wiLCBcImNoZW1fcmJzXCIsIFwiY2hlbV9oYmExY1wiLFxuICAgIFwiY2hlbV9jaG9sZVwiLCBcImNoZW1fdHJpZ2x5XCIsIFwiY2hlbV9oZGxcIiwgXCJjaGVtX2xkbFwiLCBcImNoZW1fdmxkbFwiLFxuICAgIFwiY2hlbV9idW5cIiwgXCJjaGVtX2NyZWFcIiwgXCJjaGVtX2J1YVwiLFxuICAgIFwiY2hlbV9hc3RcIiwgXCJjaGVtX2FsdFwiLFxuICAgIFwiY2hlbV90c2hcIiwgXCJjaGVtX2Z0M1wiLCBcImNoZW1fZnQ0XCIsIFwiY2hlbV90M1wiLCBcImNoZW1fdDRcIixcbiAgICBcImNoZW1fcHNhXCIsIFwiY2hlbV9yZW1hcmtzXCIsXG4gIF0sXG4gIFVyaW5hbHlzaXM6IFtcbiAgICBcInVhX2NvbG9yXCIsIFwidWFfdHJhbnNcIiwgXCJ1YV9nbHVcIiwgXCJ1YV9wcm9cIiwgXCJ1YV9waFwiLCBcInVhX3NnXCIsIFwiYmxvb2RcIixcbiAgICBcInVhX2JpbGlydWJpblwiLCBcInVhX3Vyb2JpbGlcIiwgXCJ1YV9rZXRvbmVzXCIsIFwidWFfbml0cml0ZXNcIiwgXCJ1YV9sZVwiLFxuICAgIFwidWFfY2FzdFwiLCBcInVhX2Nhc3R0eXBlXCIsIFwidWFfY3J5c3RhbHNcIiwgXCJ1YV9jcnlzdGFsc3R5cGVcIixcbiAgICBcInVhX2VwaVwiLCBcInVhX211Y1wiLCBcInVhX3VyYVwiLCBcInVhX3Bob1wiLFxuICAgIFwidWFfYmFjXCIsIFwidWFfcHVzXCIsIFwidWFfcmJjXCIsIFwidWFfcmVtYXJrc1wiLFxuICBdLFxuICBGZWNhbHlzaXM6IFtcbiAgICBcImZhX2NvbG9yXCIsXHRcImZhX2NvbnNcIiwgXCJmYV9wdXNcIiwgXCJmYV9yYmNcIixcbiAgICBcImZhX2JhY1wiLCBcImZhX3llYXN0XCIsIFwiZmFfZmF0XCIsIFwiZmFfcGFyYVwiLCBcImZhX3BhcmF0eXBlXCIsXG4gICAgXCJmYV9mb2J0XCIsIFwiZmFfcmVtYXJrc1wiLFxuXSxcbiAgU2Vyb2xvZ3k6IFtcbiAgICBcInNlcm9fZGVuZ25zMVwiLCBcInNlcm9fZGVuZ21cIiwgXCJzZXJvX2RlbmdnXCIsXG4gICAgXCJzZXJvX2hlcGFiXCIsIFwic2Vyb19ycHZcIiwgXCJzZXJvX2hpdlwiLCBcInNlcm9faGN2XCIsIFwic2Vyb19wdFwiLFxuICAgIFwic2Vyb19yZW1hcmtzXCJcbl0sXG4gIE90aGVyczogW10sXG59O1xuZnVuY3Rpb24gYnVpbGRPcmRlckluZGV4KHJhbmdlc1Jvd3M6IFJlY29yZDxzdHJpbmcsIGFueT5bXSkge1xuICBjb25zdCBieUtleU9yZGVyID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgLy8gcmFuZ2VzIG1heSBoYXZlIG9yZGVyLWxpa2UgY29sdW1uczsgdXNlIGZpcnN0IHRoYXQgZXhpc3RzXG4gIGZvciAoY29uc3QgciBvZiByYW5nZXNSb3dzKSB7XG4gICAgY29uc3Qga2V5ID0gU3RyaW5nKFxuICAgICAgci5hbmFseXRlX2tleSA/PyByLmtleSA/PyByLnBhcmFtZXRlcl9rZXkgPz8gci5wYXJhbV9rZXkgPz8gXCJcIlxuICAgICkudHJpbSgpO1xuICAgIGlmICgha2V5KSBjb250aW51ZTtcbiAgICBjb25zdCBvcmRlclJhdyA9IChyLm9yZGVyID8/IHIuc29ydF9vcmRlciA/PyByLnJhbmsgPz8gci5wcmlvID8/IG51bGwpO1xuICAgIGNvbnN0IG9yZGVyTnVtID0gdG9OdW0ob3JkZXJSYXcpO1xuICAgIGlmIChvcmRlck51bSAhPT0gbnVsbCkgYnlLZXlPcmRlci5zZXQoa2V5LCBvcmRlck51bSk7XG4gIH1cbiAgcmV0dXJuIGJ5S2V5T3JkZXI7XG59XG5mdW5jdGlvbiBzb3J0SXRlbXNJblNlY3Rpb25zKFxuICBzZWN0aW9uczogUmVwb3J0U2VjdGlvbltdLFxuICByYW5nZXNSb3dzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+W11cbik6IFJlcG9ydFNlY3Rpb25bXSB7XG4gIGNvbnN0IG9yZGVySW5kZXggPSBidWlsZE9yZGVySW5kZXgocmFuZ2VzUm93cyk7XG4gIHJldHVybiBzZWN0aW9ucy5tYXAoKHNlYykgPT4ge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gREVGQVVMVF9PUkRFUltzZWMubmFtZV0gPz8gW107XG4gICAgY29uc3QgZGVmYXVsdEluZGV4ID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICBkZWZhdWx0cy5mb3JFYWNoKChrLCBpKSA9PiBkZWZhdWx0SW5kZXguc2V0KGssIGkpKTtcblxuICAgIGNvbnN0IGl0ZW1zID0gWy4uLnNlYy5pdGVtc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYW8gPSBvcmRlckluZGV4LmdldChhLmtleSk7XG4gICAgICBjb25zdCBibyA9IG9yZGVySW5kZXguZ2V0KGIua2V5KTtcbiAgICAgIGlmIChhbyAhPT0gdW5kZWZpbmVkIHx8IGJvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFvID09PSB1bmRlZmluZWQpIHJldHVybiAxO1xuICAgICAgICBpZiAoYm8gPT09IHVuZGVmaW5lZCkgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gYW8gLSBibztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFkID0gZGVmYXVsdEluZGV4LmdldChhLmtleSk7XG4gICAgICBjb25zdCBiZCA9IGRlZmF1bHRJbmRleC5nZXQoYi5rZXkpO1xuICAgICAgaWYgKGFkICE9PSB1bmRlZmluZWQgfHwgYmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChiZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiBhZCAtIGJkO1xuICAgICAgfVxuICAgICAgLy8gZmluYWwgZmFsbGJhY2s6IGFscGhhYmV0aWNhbCBieSBsYWJlbCB0aGVuIGtleVxuICAgICAgY29uc3QgYWwgPSAoYS5sYWJlbCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgYmwgPSAoYi5sYWJlbCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGFsICE9PSBibCkgcmV0dXJuIGFsIDwgYmwgPyAtMSA6IDE7XG4gICAgICByZXR1cm4gKGEua2V5IHx8IFwiXCIpLmxvY2FsZUNvbXBhcmUoYi5rZXkgfHwgXCJcIik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyAuLi5zZWMsIGl0ZW1zIH07XG4gIH0pO1xufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLSBwcm92aWRlciAtLS0tLS0tLS0tLS0tLS0tLSAqL1xudHlwZSBSYW5nZU1ldGEgPSB7XG4gIHNlY3Rpb24/OiBzdHJpbmcgfCBudWxsO1xuICBsYWJlbD86IHN0cmluZyB8IG51bGw7XG4gIHVuaXQ/OiBzdHJpbmcgfCBudWxsO1xuICBsb3c/OiBudW1iZXIgfCBzdHJpbmcgfCBudWxsO1xuICBoaWdoPzogbnVtYmVyIHwgc3RyaW5nIHwgbnVsbDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdXBhYmFzZVByb3ZpZGVyKCk6IERhdGFQcm92aWRlciB7XG4gIGNvbnN0IFRBQkxFX1BBVElFTlRTID0gXCJwYXRpZW50c1wiO1xuICBjb25zdCBUQUJMRV9SRVNVTFRTICA9IFwicmVzdWx0c19mbGF0XCI7XG4gIGNvbnN0IFRBQkxFX1JBTkdFUyAgID0gXCJyYW5nZXNcIjtcbiAgY29uc3QgVEFCTEVfVklUQUxTICAgPSBcInZpdGFsc19zbmFwc2hvdHNcIjtcbiAgY29uc3QgVEFCTEVfUkVTVUxUU19XSURFID0gXCJyZXN1bHRzX3dpZGVcIjtcblxuICBjb25zdCBkYiA9IGdldFN1cGFiYXNlKCk7XG5cbiAgLy8gY2FjaGUgcmFuZ2VzICsgcmF3IHJvd3MgKGZvciBvcmRlcmluZylcbiAgbGV0IHJhbmdlc0NhY2hlOiBNYXA8c3RyaW5nLCBSYW5nZU1ldGE+IHwgbnVsbCA9IG51bGw7XG4gIGxldCByYW5nZXNSb3dzQ2FjaGU6IFJlY29yZDxzdHJpbmcsIGFueT5bXSB8IG51bGwgPSBudWxsO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGdldFJhbmdlc01hcCgpOiBQcm9taXNlPHsgbWFwOiBNYXA8c3RyaW5nLCBSYW5nZU1ldGE+OyByb3dzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+W10gfT4ge1xuICAgIGlmIChyYW5nZXNDYWNoZSAmJiByYW5nZXNSb3dzQ2FjaGUpIHJldHVybiB7IG1hcDogcmFuZ2VzQ2FjaGUsIHJvd3M6IHJhbmdlc1Jvd3NDYWNoZSB9O1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGRiLmZyb20oVEFCTEVfUkFOR0VTKS5zZWxlY3QoXCIqXCIpO1xuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cbiAgICBjb25zdCByb3dzID0gKGRhdGEgfHwgW10pIGFzIFJlY29yZDxzdHJpbmcsIGFueT5bXTtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwPHN0cmluZywgUmFuZ2VNZXRhPigpO1xuICAgIGZvciAoY29uc3QgciBvZiByb3dzKSB7XG4gICAgICBjb25zdCBrZXkgPSBTdHJpbmcoXG4gICAgICAgIHIuYW5hbHl0ZV9rZXkgPz8gci5rZXkgPz8gci5wYXJhbWV0ZXJfa2V5ID8/IHIucGFyYW1fa2V5ID8/IFwiXCJcbiAgICAgICkudHJpbSgpO1xuICAgICAgaWYgKCFrZXkpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBzZWN0aW9uID1cbiAgICAgICAgKHIuc2VjdGlvbiA/PyByLmdyb3VwID8/IHIuY2F0ZWdvcnkgPz8gbnVsbCkgfHwgcHJlZml4VG9TZWN0aW9uKGtleSk7XG4gICAgICBjb25zdCBsYWJlbCA9XG4gICAgICAgIChyLml0ZW1fbGFiZWwgPz8gci5kaXNwbGF5X25hbWUgPz8gci5sYWJlbCA/PyByLm5hbWUgPz8gbnVsbCkgfHwgbnVsbDtcbiAgICAgIGNvbnN0IHVuaXQgPSByLnVuaXQgPz8gci51bml0cyA/PyByLnVvbSA/PyBudWxsO1xuICAgICAgLy8gWW91ciByYW5nZXMgdXNlIFwibG93XCIvXCJoaWdoXCIgKG1heSBiZSB0ZXh0KTsga2VlcCByYXcgZm9yIGRpc3BsYXksIG51bWVyaWMgZm9yIGZsYWcgbG9naWNcbiAgICAgIGNvbnN0IGxvdyAgPSByLmxvdyAgPz8gbnVsbDtcbiAgICAgIGNvbnN0IGhpZ2ggPSByLmhpZ2ggPz8gbnVsbDtcblxuICAgICAgbWFwLnNldChrZXksIHsgc2VjdGlvbiwgbGFiZWwsIHVuaXQsIGxvdywgaGlnaCB9KTtcbiAgICB9XG4gICAgcmFuZ2VzQ2FjaGUgPSBtYXA7XG4gICAgcmFuZ2VzUm93c0NhY2hlID0gcm93cztcbiAgICByZXR1cm4geyBtYXAsIHJvd3MgfTtcbiAgfVxuXG4gIHR5cGUgVml0YWxzQnVuZGxlID0geyBsYXRlc3Q6IFZpdGFsc1NuYXBzaG90IHwgbnVsbDsgaGlzdG9yeTogVml0YWxzU25hcHNob3RbXSB9O1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoVml0YWxzU25hcHNob3RzKFxuICAgIHBhdGllbnRfaWQ6IHN0cmluZyxcbiAgICBvcHRzPzogeyBsaW1pdD86IG51bWJlcjsgY29uc3VsdGF0aW9uX2lkPzogc3RyaW5nIHwgbnVsbDsgZW5jb3VudGVyX2lkPzogc3RyaW5nIHwgbnVsbDsgfVxuICApOiBQcm9taXNlPFZpdGFsc0J1bmRsZT4ge1xuICAgIGNvbnN0IHBpZCA9IGVzY2FwZUxpa2VFeGFjdChTdHJpbmcocGF0aWVudF9pZCB8fCBcIlwiKS50cmltKCkpO1xuICAgIGxldCBxdWVyeSA9IGRiXG4gICAgICAuZnJvbShUQUJMRV9WSVRBTFMpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmlsaWtlKFwicGF0aWVudF9pZFwiLCBwaWQpXG4gICAgICAub3JkZXIoXCJtZWFzdXJlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgICBpZiAob3B0cz8uY29uc3VsdGF0aW9uX2lkKSBxdWVyeSA9IHF1ZXJ5LmVxKFwiY29uc3VsdGF0aW9uX2lkXCIsIG9wdHMuY29uc3VsdGF0aW9uX2lkKTtcbiAgICBpZiAob3B0cz8uZW5jb3VudGVyX2lkKSBxdWVyeSA9IHF1ZXJ5LmVxKFwiZW5jb3VudGVyX2lkXCIsIG9wdHMuZW5jb3VudGVyX2lkKTtcbiAgICBxdWVyeSA9IHF1ZXJ5LmxpbWl0KG9wdHM/LmxpbWl0ID8/IDgpO1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblxuICAgIGNvbnN0IHJvd3M6IFZpdGFsc1NuYXBzaG90W10gPSAoZGF0YSB8fCBbXSkubWFwKChyKSA9PiAoe1xuICAgICAgaWQ6IFN0cmluZyhyLmlkKSxcbiAgICAgIHBhdGllbnRfaWQ6IFN0cmluZyhyLnBhdGllbnRfaWQpLFxuICAgICAgY29uc3VsdGF0aW9uX2lkOiBTdHJpbmcoci5jb25zdWx0YXRpb25faWQpLFxuICAgICAgZW5jb3VudGVyX2lkOiBTdHJpbmcoci5lbmNvdW50ZXJfaWQpLFxuICAgICAgbWVhc3VyZWRfYXQ6IChyLm1lYXN1cmVkX2F0ID8/IHIuY3JlYXRlZF9hdCA/PyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpIGFzIHN0cmluZyxcbiAgICAgIHN5c3RvbGljX2JwOiB0b051bShyLnN5c3RvbGljX2JwKSxcbiAgICAgIGRpYXN0b2xpY19icDogdG9OdW0oci5kaWFzdG9saWNfYnApLFxuICAgICAgaHI6IHRvTnVtKHIuaHIpLFxuICAgICAgcnI6IHRvTnVtKHIucnIpLFxuICAgICAgdGVtcF9jOiByLnRlbXBfYyA9PSBudWxsID8gbnVsbCA6IE51bWJlcihyLnRlbXBfYyksXG4gICAgICBoZWlnaHRfY206IHIuaGVpZ2h0X2NtID09IG51bGwgPyBudWxsIDogTnVtYmVyKHIuaGVpZ2h0X2NtKSxcbiAgICAgIHdlaWdodF9rZzogci53ZWlnaHRfa2cgPT0gbnVsbCA/IG51bGwgOiBOdW1iZXIoci53ZWlnaHRfa2cpLFxuICAgICAgYm1pOiByLmJtaSA9PSBudWxsID8gbnVsbCA6IE51bWJlcihyLmJtaSksXG4gICAgICBvMnNhdDogdG9OdW0oci5vMnNhdCksXG4gICAgICBub3Rlczogci5ub3RlcyA/PyBudWxsLFxuICAgICAgc291cmNlOiByLnNvdXJjZSA/PyBudWxsLFxuICAgICAgY3JlYXRlZF9hdDogci5jcmVhdGVkX2F0ID8/IG51bGwsXG4gICAgICBjcmVhdGVkX2J5X2luaXRpYWxzOiByLmNyZWF0ZWRfYnlfaW5pdGlhbHMgPz8gbnVsbCxcbiAgICB9KSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGF0ZXN0OiByb3dzWzBdID8/IG51bGwsXG4gICAgICBoaXN0b3J5OiByb3dzLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBmYWxsYmFja1BhdGllbnRGcm9tUmVzdWx0cyhwYXRpZW50X2lkOiBzdHJpbmcpOiBQcm9taXNlPFBhdGllbnQgfCBudWxsPiB7XG4gICAgY29uc3QgcGlkID0gZXNjYXBlTGlrZUV4YWN0KFN0cmluZyhwYXRpZW50X2lkIHx8IFwiXCIpLnRyaW0oKSk7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgZGJcbiAgICAgIC5mcm9tKFRBQkxFX1JFU1VMVFNfV0lERSlcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZClcbiAgICAgIC5vcmRlcihcImRhdGVfb2ZfdGVzdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgIC5saW1pdCgxKVxuICAgICAgLm1heWJlU2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCB2aXRhbHMgPSBhd2FpdCBmZXRjaFZpdGFsc1NuYXBzaG90cyhwYXRpZW50X2lkKS5jYXRjaChcbiAgICAgICgpOiBWaXRhbHNCdW5kbGUgPT4gKHsgbGF0ZXN0OiBudWxsLCBoaXN0b3J5OiBbXSB9KVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aWVudF9pZDogZGF0YS5wYXRpZW50X2lkID8/IHBhdGllbnRfaWQsXG4gICAgICBmdWxsX25hbWU6ICBkYXRhLmZ1bGxfbmFtZSA/PyBcIlwiLFxuICAgICAgc2V4OiAgICAgICAgZGF0YS5zZXggPz8gXCJcIixcbiAgICAgIGFnZTogICAgICAgIGRhdGEuYWdlID8/IFwiXCIsXG4gICAgICBiaXJ0aGRheTogICBkYXRhLmJpcnRoZGF5ID8/IFwiXCIsXG4gICAgICBjb250YWN0OiAgICBkYXRhLmNvbnRhY3QgPz8gXCJcIixcbiAgICAgIGFkZHJlc3M6ICAgIGRhdGEuYWRkcmVzcyA/PyBcIlwiLFxuICAgICAgZW1haWw6ICAgICAgZGF0YS5lbWFpbCA/PyBcIlwiLFxuICAgICAgc3lzdG9saWNfYnA6IFwiXCIsXG4gICAgICBkaWFzdG9saWNfYnA6IFwiXCIsXG4gICAgICBoZWlnaHRfZnQ6IFwiXCIsXG4gICAgICBoZWlnaHRfaW5jaDogXCJcIixcbiAgICAgIHdlaWdodF9rZzogXCJcIixcbiAgICAgIG1lZGljYXRpb25zX2N1cnJlbnQ6IFwiXCIsXG4gICAgICBtZWRpY2F0aW9uczogXCJcIixcbiAgICAgIGZhbWlseV9oaXN0b3J5OiBcIlwiLFxuICAgICAgc21va2luZ19oeDogXCJcIixcbiAgICAgIGFsY29ob2xfaHg6IFwiXCIsXG4gICAgICB2aXRhbHMsXG4gICAgICBsYXN0X3VwZGF0ZWQ6IGRhdGEubGFzdF91cGRhdGVkID8/IFwiXCIsXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RWaXNpdFJvd3MocGF0aWVudF9pZDogc3RyaW5nKTogUHJvbWlzZTxWaXNpdFtdPiB7XG4gICAgY29uc3QgcGlkID0gZXNjYXBlTGlrZUV4YWN0KFN0cmluZyhwYXRpZW50X2lkIHx8IFwiXCIpLnRyaW0oKSk7XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBkYlxuICAgICAgLmZyb20oVEFCTEVfUkVTVUxUUylcbiAgICAgIC5zZWxlY3QoXCJkYXRlX29mX3Rlc3QsIGJhcmNvZGUsIGJyYW5jaCwgbm90ZXNcIilcbiAgICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKTtcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gKGRhdGEgYXMgUmVjb3JkPHN0cmluZywgYW55PltdKS5tYXAoKHIpID0+ICh7XG4gICAgICAgIGRhdGVfb2ZfdGVzdDogU3RyaW5nKHIuZGF0ZV9vZl90ZXN0ID8/IFwiXCIpLnRyaW0oKSxcbiAgICAgICAgYmFyY29kZTogci5iYXJjb2RlID8/IFwiXCIsXG4gICAgICAgIGJyYW5jaDogci5icmFuY2ggPz8gXCJcIixcbiAgICAgICAgbm90ZXM6IHIubm90ZXMgPz8gXCJcIixcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byB3aWRlIHRhYmxlIGZvciBsZWdhY3kgcm93c1xuICAgIGNvbnN0IHsgZGF0YTogd2lkZSwgZXJyb3I6IHdpZGVFcnJvciB9ID0gYXdhaXQgZGJcbiAgICAgIC5mcm9tKFRBQkxFX1JFU1VMVFNfV0lERSlcbiAgICAgIC5zZWxlY3QoXCJkYXRlX29mX3Rlc3QsIGJhcmNvZGUsIGJyYW5jaCwgbm90ZXNcIilcbiAgICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKTtcblxuICAgIGlmICh3aWRlRXJyb3IpIHRocm93IHdpZGVFcnJvcjtcblxuICAgIHJldHVybiAod2lkZSB8fCBbXSkubWFwKChyOiBhbnkpID0+ICh7XG4gICAgICBkYXRlX29mX3Rlc3Q6IFN0cmluZyhyPy5kYXRlX29mX3Rlc3QgPz8gXCJcIikudHJpbSgpLFxuICAgICAgYmFyY29kZTogcj8uYmFyY29kZSA/PyBcIlwiLFxuICAgICAgYnJhbmNoOiByPy5icmFuY2ggPz8gXCJcIixcbiAgICAgIG5vdGVzOiByPy5ub3RlcyA/PyBcIlwiLFxuICAgIH0pKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoUmVzdWx0Um93cyhwYXRpZW50X2lkOiBzdHJpbmcsIHZpc2l0RGF0ZT86IHN0cmluZyk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgYW55PltdPiB7XG4gICAgY29uc3QgcGlkID0gZXNjYXBlTGlrZUV4YWN0KFN0cmluZyhwYXRpZW50X2lkIHx8IFwiXCIpLnRyaW0oKSk7XG4gICAgbGV0IHF1ZXJ5ID0gZGJcbiAgICAgIC5mcm9tKFRBQkxFX1JFU1VMVFMpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmlsaWtlKFwicGF0aWVudF9pZFwiLCBwaWQpO1xuXG4gICAgaWYgKHZpc2l0RGF0ZSkgcXVlcnkgPSBxdWVyeS5lcShcImRhdGVfb2ZfdGVzdFwiLCB2aXNpdERhdGUpO1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHJldHVybiBkYXRhIGFzIFJlY29yZDxzdHJpbmcsIGFueT5bXTtcblxuICAgIC8vIEZhbGxiYWNrIHRvIHRoZSB3aWRlIHRhYmxlOiBleHBsb2RlIHdpZGUgY29sdW1ucyBpbnRvIGZsYXQgcm93c1xuICAgIGxldCB3aWRlUXVlcnkgPSBkYlxuICAgICAgLmZyb20oVEFCTEVfUkVTVUxUU19XSURFKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKTtcblxuICAgIGlmICh2aXNpdERhdGUpIHdpZGVRdWVyeSA9IHdpZGVRdWVyeS5lcShcImRhdGVfb2ZfdGVzdFwiLCB2aXNpdERhdGUpO1xuXG4gICAgY29uc3QgeyBkYXRhOiB3aWRlLCBlcnJvcjogd2lkZUVycm9yIH0gPSBhd2FpdCB3aWRlUXVlcnk7XG4gICAgaWYgKHdpZGVFcnJvcikgdGhyb3cgd2lkZUVycm9yO1xuICAgIGlmICghd2lkZSB8fCB3aWRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuXG4gICAgY29uc3Qgc2tpcEtleXMgPSBuZXcgU2V0KFtcbiAgICAgIFwicGF0aWVudF9pZFwiLFxuICAgICAgXCJkYXRlX29mX3Rlc3RcIixcbiAgICAgIFwiYmFyY29kZVwiLFxuICAgICAgXCJub3Rlc1wiLFxuICAgICAgXCJicmFuY2hcIixcbiAgICAgIFwiaWRcIixcbiAgICAgIFwiY3JlYXRlZF9hdFwiLFxuICAgICAgXCJ1cGRhdGVkX2F0XCIsXG4gICAgICBcImNyZWF0ZWRfYnlcIixcbiAgICAgIFwidXBkYXRlZF9ieVwiLFxuICAgICAgXCJjcmVhdGVkX2J5X2luaXRpYWxzXCIsXG4gICAgXSk7XG5cbiAgICBjb25zdCBmbGF0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiB3aWRlIGFzIFJlY29yZDxzdHJpbmcsIGFueT5bXSkge1xuICAgICAgY29uc3QgYmFzZSA9IHtcbiAgICAgICAgcGF0aWVudF9pZDogcm93LnBhdGllbnRfaWQgPz8gcGF0aWVudF9pZCxcbiAgICAgICAgZGF0ZV9vZl90ZXN0OiByb3cuZGF0ZV9vZl90ZXN0ID8/IHZpc2l0RGF0ZSA/PyBcIlwiLFxuICAgICAgICBiYXJjb2RlOiByb3cuYmFyY29kZSA/PyBcIlwiLFxuICAgICAgICBub3Rlczogcm93Lm5vdGVzID8/IFwiXCIsXG4gICAgICAgIGJyYW5jaDogcm93LmJyYW5jaCA/PyBcIlwiLFxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhyb3cpKSB7XG4gICAgICAgIGlmIChza2lwS2V5cy5oYXMoa2V5KSkgY29udGludWU7XG4gICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQgfHwgaXNQbGFjZWhvbGRlcih2YWwpKSBjb250aW51ZTtcbiAgICAgICAgZmxhdC5wdXNoKHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIGFuYWx5dGVfa2V5OiBrZXksXG4gICAgICAgICAgaXRlbV9rZXk6IGtleSxcbiAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmxhdDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXN5bmMgZ2V0UGF0aWVudChwYXRpZW50X2lkOiBzdHJpbmcpOiBQcm9taXNlPFBhdGllbnQgfCBudWxsPiB7XG4gICAgICBjb25zdCBwaWQgPSBlc2NhcGVMaWtlRXhhY3QoU3RyaW5nKHBhdGllbnRfaWQgfHwgXCJcIikudHJpbSgpKTtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGRiXG4gICAgICAgIC5mcm9tKFRBQkxFX1BBVElFTlRTKVxuICAgICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZClcbiAgICAgICAgLmxpbWl0KDEpXG4gICAgICAgIC5tYXliZVNpbmdsZSgpO1xuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIC8vIExlZ2FjeSByb3dzIG1pZ2h0IGV4aXN0IG9ubHkgaW4gcmVzdWx0c193aWRlXG4gICAgICAgIGNvbnN0IGZhbGxiYWNrID0gYXdhaXQgZmFsbGJhY2tQYXRpZW50RnJvbVJlc3VsdHMocGF0aWVudF9pZCk7XG4gICAgICAgIGlmICghZmFsbGJhY2spIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1lZHNDdXJyZW50ID0gZGF0YS5tZWRpY2F0aW9uc19jdXJyZW50ID8/IFwiXCI7XG5cbiAgICAgIGNvbnN0IHZpdGFscyA9IGF3YWl0IGZldGNoVml0YWxzU25hcHNob3RzKHBhdGllbnRfaWQpLmNhdGNoKFxuICAgICAgICAoKTogVml0YWxzQnVuZGxlID0+ICh7IGxhdGVzdDogbnVsbCwgaGlzdG9yeTogW10gfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHA6IFBhdGllbnQgPSB7XG4gICAgICAgIHBhdGllbnRfaWQ6IGRhdGEucGF0aWVudF9pZCxcbiAgICAgICAgZnVsbF9uYW1lOiAgZGF0YS5mdWxsX25hbWUgPz8gXCJcIixcbiAgICAgICAgc2V4OiAgICAgICAgZGF0YS5zZXggPz8gXCJcIixcbiAgICAgICAgYWdlOiAgICAgICAgZGF0YS5hZ2UgPz8gXCJcIixcbiAgICAgICAgYmlydGhkYXk6ICAgZGF0YS5iaXJ0aGRheSA/PyBcIlwiLFxuICAgICAgICBjb250YWN0OiAgICBkYXRhLmNvbnRhY3QgPz8gXCJcIixcbiAgICAgICAgYWRkcmVzczogICAgZGF0YS5hZGRyZXNzID8/IFwiXCIsXG4gICAgICAgIGVtYWlsOiAgICAgIGRhdGEuZW1haWwgPz8gXCJcIixcbiAgICAgICAgaGVpZ2h0X2Z0OiAgZGF0YS5oZWlnaHRfZnQgPz8gXCJcIixcbiAgICAgICAgaGVpZ2h0X2luY2g6ZGF0YS5oZWlnaHRfaW5jaCA/PyBcIlwiLFxuICAgICAgICB3ZWlnaHRfa2c6ICBkYXRhLndlaWdodF9rZyA/PyBcIlwiLFxuICAgICAgICBzeXN0b2xpY19icDpkYXRhLnN5c3RvbGljX2JwID8/IFwiXCIsXG4gICAgICAgIGRpYXN0b2xpY19icDpkYXRhLmRpYXN0b2xpY19icCA/PyBcIlwiLFxuICAgICAgICBsYXN0X3VwZGF0ZWQ6IGRhdGEubGFzdF91cGRhdGVkID8/IFwiXCIsXG4gICAgICAgIHByZXNlbnRfaWxsbmVzc19oaXN0b3J5OiBkYXRhLnByZXNlbnRfaWxsbmVzc19oaXN0b3J5ID8/IFwiXCIsXG4gICAgICAgIHBhc3RfbWVkaWNhbF9oaXN0b3J5OiAgICBkYXRhLnBhc3RfbWVkaWNhbF9oaXN0b3J5ID8/IFwiXCIsXG4gICAgICAgIHBhc3Rfc3VyZ2ljYWxfaGlzdG9yeTogICBkYXRhLnBhc3Rfc3VyZ2ljYWxfaGlzdG9yeSA/PyBcIlwiLFxuICAgICAgICBjaGllZl9jb21wbGFpbnQ6ICAgICAgICAgZGF0YS5jaGllZl9jb21wbGFpbnQgPz8gXCJcIixcbiAgICAgICAgYWxsZXJnaWVzX3RleHQ6ICAgICAgICAgIGRhdGEuYWxsZXJnaWVzX3RleHQgPz8gXCJcIixcbiAgICAgICAgbWVkaWNhdGlvbnNfY3VycmVudDogICAgIG1lZHNDdXJyZW50LFxuICAgICAgICBtZWRpY2F0aW9uczogICAgICAgICAgICAgbWVkc0N1cnJlbnQsICAgICAgICAgICAvLyBtaXJyb3IgZm9yIFVJIGNvbXBhdGliaWxpdHlcbiAgICAgICAgZmFtaWx5X2hpc3Rvcnk6ICAgICAgICAgIGRhdGEuZmFtaWx5X2h4ID8/IFwiXCIsICAvLyBzb3VyY2UgaXMgZmFtaWx5X2h4XG4gICAgICAgIHNtb2tpbmdfaHg6ICAgICAgICAgICAgICBkYXRhLnNtb2tpbmdfaHggPz8gXCJcIixcbiAgICAgICAgYWxjb2hvbF9oeDogICAgICAgICAgICAgIGRhdGEuYWxjb2hvbF9oeCA/PyBcIlwiLFxuICAgICAgICB2aXRhbHMsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIGFzeW5jIGdldFZpc2l0cyhwYXRpZW50X2lkOiBzdHJpbmcpOiBQcm9taXNlPFZpc2l0W10+IHtcbiAgICAgIGNvbnN0IHZpc2l0Um93cyA9IGF3YWl0IGxpc3RWaXNpdFJvd3MocGF0aWVudF9pZCk7XG5cbiAgICAgIGNvbnN0IHNlZW4gPSBuZXcgTWFwPHN0cmluZywgVmlzaXQ+KCk7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgdmlzaXRSb3dzKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBTdHJpbmcoci5kYXRlX29mX3Rlc3QgPz8gci5kYXRlID8/IHIudGVzdF9kYXRlID8/IFwiXCIpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFkYXRlIHx8IGlzUGxhY2Vob2xkZXIoZGF0ZSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXNlZW4uaGFzKGRhdGUpKSB7XG4gICAgICAgICAgc2Vlbi5zZXQoZGF0ZSwge1xuICAgICAgICAgICAgZGF0ZV9vZl90ZXN0OiBkYXRlLFxuICAgICAgICAgICAgYmFyY29kZTogci5iYXJjb2RlID8/IFwiXCIsXG4gICAgICAgICAgICBicmFuY2g6ICByLmJyYW5jaCA/PyBcIlwiLFxuICAgICAgICAgICAgbm90ZXM6ICAgci5ub3RlcyA/PyBcIlwiLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShzZWVuLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiB0cyhiLmRhdGVfb2ZfdGVzdCkgLSB0cyhhLmRhdGVfb2ZfdGVzdCkpO1xuICAgIH0sXG5cbiAgICBhc3luYyBnZXRSZXBvcnQoeyBwYXRpZW50X2lkLCB2aXNpdERhdGUgfTogeyBwYXRpZW50X2lkOiBzdHJpbmc7IHZpc2l0RGF0ZT86IHN0cmluZzsgfSk6IFByb21pc2U8UmVwb3J0IHwgbnVsbD4ge1xuICAgICAgY29uc3QgcGF0aWVudCA9XG4gICAgICAgIChhd2FpdCB0aGlzLmdldFBhdGllbnQocGF0aWVudF9pZCkpIHx8XG4gICAgICAgICh7XG4gICAgICAgICAgcGF0aWVudF9pZCxcbiAgICAgICAgICBmdWxsX25hbWU6IFwiXCIsXG4gICAgICAgICAgdml0YWxzOiB7IGxhdGVzdDogbnVsbCwgaGlzdG9yeTogW10gfSxcbiAgICAgICAgfSBhcyBQYXRpZW50KTtcblxuICAgICAgbGV0IGRhdGUgPSB2aXNpdERhdGU7XG4gICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgY29uc3QgdmlzaXRzID0gYXdhaXQgdGhpcy5nZXRWaXNpdHMocGF0aWVudF9pZCk7XG4gICAgICAgIGRhdGUgPSB2aXNpdHNbMF0/LmRhdGVfb2ZfdGVzdDtcbiAgICAgICAgaWYgKCFkYXRlKSByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm93cyA9IGF3YWl0IGZldGNoUmVzdWx0Um93cyhwYXRpZW50X2lkLCBkYXRlKTtcbiAgICAgIGlmIChyb3dzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNvbnN0IHsgbWFwOiByYW5nZXNNYXAsIHJvd3M6IHJhbmdlc1Jvd3MgfSA9IGF3YWl0IGdldFJhbmdlc01hcCgpO1xuICAgICAgY29uc3QgYnlTZWN0aW9uID0gbmV3IE1hcDxzdHJpbmcsIFJlcG9ydEl0ZW1bXT4oKTtcblxuICAgICAgZm9yIChjb25zdCByIG9mIHJvd3MpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gU3RyaW5nKFxuICAgICAgICAgIHIuaXRlbV9rZXkgPz9cbiAgICAgICAgICByLmFuYWx5dGVfa2V5ID8/XG4gICAgICAgICAgci5wYXJhbWV0ZXJfa2V5ID8/XG4gICAgICAgICAgci5wYXJhbV9rZXkgPz9cbiAgICAgICAgICByLmtleSA/P1xuICAgICAgICAgIFwiXCJcbiAgICAgICAgKS50cmltKCk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBrZXkgPyByYW5nZXNNYXAuZ2V0KGtleSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY29uc3QgbGFiZWwgPSBTdHJpbmcoXG4gICAgICAgICAgcGljayhcbiAgICAgICAgICAgIHIuaXRlbV9sYWJlbCxcbiAgICAgICAgICAgIHIuZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgci5wYXJhbWV0ZXJfbGFiZWwsXG4gICAgICAgICAgICByLmxhYmVsLFxuICAgICAgICAgICAgbWV0YT8ubGFiZWwsXG4gICAgICAgICAgICBrZXkgfHwgbnVsbFxuICAgICAgICAgICkgPz8gXCJcIlxuICAgICAgICApLnRyaW0oKTtcblxuICAgICAgICAvLyB1bml0OiBuZXZlciBhbGxvdyBcIm51bGxcIiBzdHJpbmdcbiAgICAgICAgY29uc3QgdW5pdFJhdyA9IHBpY2soci51bml0LCByLnVuaXRzLCByLnVvbSwgbWV0YT8udW5pdCk7XG4gICAgICAgIGNvbnN0IHVuaXQgPSB1bml0UmF3ID09IG51bGwgPyBcIlwiIDogU3RyaW5nKHVuaXRSYXcpO1xuXG4gICAgICAgIC8vIHNlY3Rpb24gZnJvbSByYW5nZXMgb3IgcHJlZml4XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSBTdHJpbmcoXG4gICAgICAgICAgcGljayhyLnNlY3Rpb24sIHIuaXRlbV9zZWN0aW9uLCByLmRlcHQsIHIuY2F0ZWdvcnksIG1ldGE/LnNlY3Rpb24sIHByZWZpeFRvU2VjdGlvbihrZXkgfHwgbGFiZWwpLCBcIk90aGVyc1wiKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHZhbHVlOiB0cmVhdCBcIi1cIiBldGMgYXMgbnVsbDsga2VlcCBudW1lcmljIGlmIHBvc3NpYmxlIGZvciBmbGFnc1xuICAgICAgICBjb25zdCByYXdWYWwgPSBwaWNrKHIudmFsdWUsIHIucmVzdWx0LCByLnZhbCk7XG4gICAgICAgIGNvbnN0IHZhbHVlTnVtID0gdG9OdW0ocmF3VmFsKTtcbiAgICAgICAgY29uc3QgdmFsdWU6IG51bWJlciB8IHN0cmluZyB8IG51bGwgPVxuICAgICAgICAgIHZhbHVlTnVtICE9PSBudWxsID8gdmFsdWVOdW0gOiAoaXNQbGFjZWhvbGRlcihyYXdWYWwpID8gbnVsbCA6IChyYXdWYWwgYXMgYW55KSk7XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlcyAoZGlzcGxheSByYXcsIGNvbXB1dGUgZmxhZ3MgdmlhIG51bWVyaWMpXG4gICAgICAgIGNvbnN0IHJhd0xvdyAgPSBwaWNrKHIucmVmX2xvdywgIHIubG93LCAgbWV0YT8ubG93KTtcbiAgICAgICAgY29uc3QgcmF3SGlnaCA9IHBpY2soci5yZWZfaGlnaCwgci5oaWdoLCBtZXRhPy5oaWdoKTtcbiAgICAgICAgY29uc3QgcmVmX2xvd19kaXNwbGF5ICA9IGlzUGxhY2Vob2xkZXIocmF3TG93KSAgPyBudWxsIDogKHJhd0xvdyAgYXMgYW55KTtcbiAgICAgICAgY29uc3QgcmVmX2hpZ2hfZGlzcGxheSA9IGlzUGxhY2Vob2xkZXIocmF3SGlnaCkgPyBudWxsIDogKHJhd0hpZ2ggYXMgYW55KTtcbiAgICAgICAgY29uc3QgcmVmTG93TnVtICA9IHRvTnVtKHJhd0xvdyk7XG4gICAgICAgIGNvbnN0IHJlZkhpZ2hOdW0gPSB0b051bShyYXdIaWdoKTtcblxuICAgICAgICAvLyBmbGFnOiBwcmVmZXIgREI7IGVsc2UgY29tcHV0ZSBML0ggb25seSAoZG8gTk9UIHNob3cgXCJOXCIpXG4gICAgICAgIGxldCBmbGFnOiBcIkxcIiB8IFwiSFwiIHwgXCJBXCIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgY29uc3QgcmF3RmxhZyA9IChwaWNrKHIuZmxhZykgYXMgYW55KSA/PyBudWxsO1xuICAgICAgICBpZiAocmF3RmxhZykge1xuICAgICAgICAgIGNvbnN0IGYgPSBTdHJpbmcocmF3RmxhZykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBpZiAoZiA9PT0gXCJMXCIgfHwgZiA9PT0gXCJIXCIgfHwgZiA9PT0gXCJBXCIpIGZsYWcgPSBmIGFzIGFueTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZU51bSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZWZMb3dOdW0gIT09IG51bGwgJiYgdmFsdWVOdW0gPCByZWZMb3dOdW0pIGZsYWcgPSBcIkxcIjtcbiAgICAgICAgICBlbHNlIGlmIChyZWZIaWdoTnVtICE9PSBudWxsICYmIHZhbHVlTnVtID4gcmVmSGlnaE51bSkgZmxhZyA9IFwiSFwiO1xuICAgICAgICAgIC8vIGVsc2Ugbm9ybWFsIOKGkiBsZWF2ZSBudWxsICh5b3UgZG9uJ3Qgd2FudCBcIk5cIilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGl0ZW06IFJlcG9ydEl0ZW0gPSB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgcmVmX2xvdzogIHJlZl9sb3dfZGlzcGxheSxcbiAgICAgICAgICByZWZfaGlnaDogcmVmX2hpZ2hfZGlzcGxheSxcbiAgICAgICAgICBmbGFnLFxuICAgICAgICAgIG1ldGhvZDogIHIubWV0aG9kID8/IG51bGwsXG4gICAgICAgICAgcmVtYXJrczogci5yZW1hcmtzID8/IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2tpcCBwbGFjZWhvbGRlcnMvYmxhbmsgdmFsdWVzIGVudGlyZWx5IChkb24ndCByZW5kZXIpXG4gICAgICAgIGlmIChpdGVtLnZhbHVlID09PSBudWxsIHx8ICh0eXBlb2YgaXRlbS52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBpc1BsYWNlaG9sZGVyKGl0ZW0udmFsdWUpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXJyID0gYnlTZWN0aW9uLmdldChzZWN0aW9uKSA/PyBbXTtcbiAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgICAgIGJ5U2VjdGlvbi5zZXQoc2VjdGlvbiwgYXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gc29ydCBpdGVtcyBpbiBlYWNoIHNlY3Rpb25cbiAgICAgIGxldCBzZWN0aW9uczogUmVwb3J0U2VjdGlvbltdID1cbiAgICAgICAgQXJyYXkuZnJvbShieVNlY3Rpb24uZW50cmllcygpKVxuICAgICAgICAgIC5tYXAoKFtuYW1lLCBpdGVtc10pID0+ICh7IG5hbWUsIGl0ZW1zIH0pKVxuICAgICAgICAgIC5maWx0ZXIoc2VjID0+IHNlYy5pdGVtcy5zb21lKGkgPT4gaS52YWx1ZSAhPT0gbnVsbCAmJiBTdHJpbmcoaS52YWx1ZSkudHJpbSgpICE9PSBcIlwiKSk7XG4gICAgICBzZWN0aW9ucyA9IHNvcnRJdGVtc0luU2VjdGlvbnMoc2VjdGlvbnMsIHJhbmdlc1Jvd3MpO1xuXG4gICAgICBjb25zdCBmaXJzdCA9IHJvd3NbMF0gfHwge307XG4gICAgICBjb25zdCB2aXNpdDogVmlzaXQgPSB7XG4gICAgICAgIGRhdGVfb2ZfdGVzdDogZGF0ZSxcbiAgICAgICAgYmFyY29kZTogZmlyc3QuYmFyY29kZSA/PyBcIlwiLFxuICAgICAgICBicmFuY2g6ICBmaXJzdC5icmFuY2ggPz8gXCJcIixcbiAgICAgICAgbm90ZXM6ICAgZmlyc3Qubm90ZXMgPz8gXCJcIixcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7IHBhdGllbnQsIHZpc2l0LCBzZWN0aW9ucyB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBzZWFyY2hQYXRpZW50cyh7IHF1ZXJ5LCBsaW1pdCA9IDIwLCBvZmZzZXQgPSAwIH0pIHtcbiAgICAgIGNvbnN0IHEgPSAocXVlcnkgfHwgXCJcIikudHJpbSgpO1xuICAgICAgaWYgKCFxKSByZXR1cm4geyByZXN1bHRzOiBbXSwgdG90YWw6IDAgfTtcblxuICAgICAgY29uc3QgcGF0ID0gYCUke3EucmVwbGFjZSgvWyVfXS9nLCAobSkgPT4gYFxcXFwke219YCl9JWA7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yLCBjb3VudCB9ID0gYXdhaXQgZGJcbiAgICAgICAgLmZyb20oVEFCTEVfUEFUSUVOVFMpXG4gICAgICAgIC5zZWxlY3QoXCJwYXRpZW50X2lkLCBmdWxsX25hbWUsIHNleCwgYWdlLCBiaXJ0aGRheSwgY29udGFjdCwgYWRkcmVzcywgZW1haWxcIiwgeyBjb3VudDogXCJleGFjdFwiIH0pXG4gICAgICAgIC5vcihgcGF0aWVudF9pZC5pbGlrZS4ke3BhdH0sZnVsbF9uYW1lLmlsaWtlLiR7cGF0fWApXG4gICAgICAgIC5vcmRlcihcImZ1bGxfbmFtZVwiLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgICAgICAucmFuZ2Uob2Zmc2V0LCBvZmZzZXQgKyBsaW1pdCAtIDEpO1xuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgICAgcmV0dXJuIHsgcmVzdWx0czogKGRhdGEgfHwgW10pIGFzIFBhdGllbnRbXSwgdG90YWw6IGNvdW50ID8/IHVuZGVmaW5lZCB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBnZXRDb25maWcoKSB7XG4gICAgICByZXR1cm4geyBmb290ZXJfbGluZXM6IFtdLCBzaWduYXRvcmllczogW10gfTtcbiAgICB9LFxuICB9O1xufVxuIl0sIm5hbWVzIjpbImdldFN1cGFiYXNlIiwiaXNQbGFjZWhvbGRlciIsIngiLCJ1bmRlZmluZWQiLCJzIiwiU3RyaW5nIiwidHJpbSIsInRvTG93ZXJDYXNlIiwidHMiLCJkIiwidCIsIkRhdGUiLCJwYXJzZSIsIk51bWJlciIsImlzTmFOIiwibSIsIm1hdGNoIiwiYSIsInBhcnNlSW50IiwiYiIsInkiLCJsZW5ndGgiLCJpc0RNWSIsIm1vbnRoIiwiZGF5IiwiZ2V0VGltZSIsInRvTnVtIiwicmVwbGFjZSIsIm4iLCJpc0Zpbml0ZSIsInBpY2siLCJ2YWxzIiwidiIsImVzY2FwZUxpa2VFeGFjdCIsInByZWZpeFRvU2VjdGlvbiIsImtleSIsImsiLCJzdGFydHNXaXRoIiwiREVGQVVMVF9PUkRFUiIsIkhlbWF0b2xvZ3kiLCJVcmluYWx5c2lzIiwiRmVjYWx5c2lzIiwiU2Vyb2xvZ3kiLCJPdGhlcnMiLCJidWlsZE9yZGVySW5kZXgiLCJyYW5nZXNSb3dzIiwiYnlLZXlPcmRlciIsIk1hcCIsInIiLCJhbmFseXRlX2tleSIsInBhcmFtZXRlcl9rZXkiLCJwYXJhbV9rZXkiLCJvcmRlclJhdyIsIm9yZGVyIiwic29ydF9vcmRlciIsInJhbmsiLCJwcmlvIiwib3JkZXJOdW0iLCJzZXQiLCJzb3J0SXRlbXNJblNlY3Rpb25zIiwic2VjdGlvbnMiLCJvcmRlckluZGV4IiwibWFwIiwic2VjIiwiZGVmYXVsdHMiLCJuYW1lIiwiZGVmYXVsdEluZGV4IiwiZm9yRWFjaCIsImkiLCJpdGVtcyIsInNvcnQiLCJhbyIsImdldCIsImJvIiwiYWQiLCJiZCIsImFsIiwibGFiZWwiLCJibCIsImxvY2FsZUNvbXBhcmUiLCJjcmVhdGVTdXBhYmFzZVByb3ZpZGVyIiwiVEFCTEVfUEFUSUVOVFMiLCJUQUJMRV9SRVNVTFRTIiwiVEFCTEVfUkFOR0VTIiwiVEFCTEVfVklUQUxTIiwiVEFCTEVfUkVTVUxUU19XSURFIiwiZGIiLCJyYW5nZXNDYWNoZSIsInJhbmdlc1Jvd3NDYWNoZSIsImdldFJhbmdlc01hcCIsInJvd3MiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwic2VjdGlvbiIsImdyb3VwIiwiY2F0ZWdvcnkiLCJpdGVtX2xhYmVsIiwiZGlzcGxheV9uYW1lIiwidW5pdCIsInVuaXRzIiwidW9tIiwibG93IiwiaGlnaCIsImZldGNoVml0YWxzU25hcHNob3RzIiwicGF0aWVudF9pZCIsIm9wdHMiLCJwaWQiLCJxdWVyeSIsImlsaWtlIiwiYXNjZW5kaW5nIiwiY29uc3VsdGF0aW9uX2lkIiwiZXEiLCJlbmNvdW50ZXJfaWQiLCJsaW1pdCIsImlkIiwibWVhc3VyZWRfYXQiLCJjcmVhdGVkX2F0IiwidG9JU09TdHJpbmciLCJzeXN0b2xpY19icCIsImRpYXN0b2xpY19icCIsImhyIiwicnIiLCJ0ZW1wX2MiLCJoZWlnaHRfY20iLCJ3ZWlnaHRfa2ciLCJibWkiLCJvMnNhdCIsIm5vdGVzIiwic291cmNlIiwiY3JlYXRlZF9ieV9pbml0aWFscyIsImxhdGVzdCIsImhpc3RvcnkiLCJmYWxsYmFja1BhdGllbnRGcm9tUmVzdWx0cyIsIm1heWJlU2luZ2xlIiwidml0YWxzIiwiY2F0Y2giLCJmdWxsX25hbWUiLCJzZXgiLCJhZ2UiLCJiaXJ0aGRheSIsImNvbnRhY3QiLCJhZGRyZXNzIiwiZW1haWwiLCJoZWlnaHRfZnQiLCJoZWlnaHRfaW5jaCIsIm1lZGljYXRpb25zX2N1cnJlbnQiLCJtZWRpY2F0aW9ucyIsImZhbWlseV9oaXN0b3J5Iiwic21va2luZ19oeCIsImFsY29ob2xfaHgiLCJsYXN0X3VwZGF0ZWQiLCJsaXN0VmlzaXRSb3dzIiwiZGF0ZV9vZl90ZXN0IiwiYmFyY29kZSIsImJyYW5jaCIsIndpZGUiLCJ3aWRlRXJyb3IiLCJmZXRjaFJlc3VsdFJvd3MiLCJ2aXNpdERhdGUiLCJ3aWRlUXVlcnkiLCJza2lwS2V5cyIsIlNldCIsImZsYXQiLCJyb3ciLCJiYXNlIiwidmFsIiwiT2JqZWN0IiwiZW50cmllcyIsImhhcyIsInB1c2giLCJpdGVtX2tleSIsInZhbHVlIiwiZ2V0UGF0aWVudCIsImZhbGxiYWNrIiwibWVkc0N1cnJlbnQiLCJwIiwicHJlc2VudF9pbGxuZXNzX2hpc3RvcnkiLCJwYXN0X21lZGljYWxfaGlzdG9yeSIsInBhc3Rfc3VyZ2ljYWxfaGlzdG9yeSIsImNoaWVmX2NvbXBsYWludCIsImFsbGVyZ2llc190ZXh0IiwiZmFtaWx5X2h4IiwiZ2V0VmlzaXRzIiwidmlzaXRSb3dzIiwic2VlbiIsImRhdGUiLCJ0ZXN0X2RhdGUiLCJBcnJheSIsInZhbHVlcyIsImdldFJlcG9ydCIsInBhdGllbnQiLCJ2aXNpdHMiLCJyYW5nZXNNYXAiLCJieVNlY3Rpb24iLCJtZXRhIiwicGFyYW1ldGVyX2xhYmVsIiwidW5pdFJhdyIsIml0ZW1fc2VjdGlvbiIsImRlcHQiLCJyYXdWYWwiLCJyZXN1bHQiLCJ2YWx1ZU51bSIsInJhd0xvdyIsInJlZl9sb3ciLCJyYXdIaWdoIiwicmVmX2hpZ2giLCJyZWZfbG93X2Rpc3BsYXkiLCJyZWZfaGlnaF9kaXNwbGF5IiwicmVmTG93TnVtIiwicmVmSGlnaE51bSIsImZsYWciLCJyYXdGbGFnIiwiZiIsInRvVXBwZXJDYXNlIiwiaXRlbSIsIm1ldGhvZCIsInJlbWFya3MiLCJhcnIiLCJmaWx0ZXIiLCJzb21lIiwiZmlyc3QiLCJ2aXNpdCIsInNlYXJjaFBhdGllbnRzIiwib2Zmc2V0IiwicSIsInJlc3VsdHMiLCJ0b3RhbCIsInBhdCIsImNvdW50Iiwib3IiLCJyYW5nZSIsImdldENvbmZpZyIsImZvb3Rlcl9saW5lcyIsInNpZ25hdG9yaWVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/data/supabase-provider.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSupabase: () => (/* binding */ getSupabase),\n/* harmony export */   getSupabaseBrowser: () => (/* binding */ getSupabaseBrowser),\n/* harmony export */   sbListVitalsByPatient: () => (/* binding */ sbListVitalsByPatient),\n/* harmony export */   sbReadConfig: () => (/* binding */ sbReadConfig),\n/* harmony export */   sbReadLatestVitalsByPatient: () => (/* binding */ sbReadLatestVitalsByPatient),\n/* harmony export */   sbReadPatientById: () => (/* binding */ sbReadPatientById),\n/* harmony export */   sbReadRanges: () => (/* binding */ sbReadRanges),\n/* harmony export */   sbReadResultsByPatient: () => (/* binding */ sbReadResultsByPatient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/../../node_modules/.pnpm/@supabase+supabase-js@2.74.0/node_modules/@supabase/supabase-js/dist/module/index.js\");\n// lib/supabase.ts\n\nconst SUPABASE_URL = process.env.SUPABASE_URL;\nconst SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;\nif (!SUPABASE_URL) throw new Error(\"SUPABASE_URL is required\");\nif (!SUPABASE_SERVICE_ROLE_KEY) throw new Error(\"SUPABASE_SERVICE_ROLE_KEY is required\");\nfunction getSupabase() {\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {\n        auth: {\n            autoRefreshToken: false,\n            persistSession: false\n        }\n    });\n}\nconst SUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpndXdpdmNkZGVqam9wd3hubW55Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg1MDMwMzksImV4cCI6MjA3NDA3OTAzOX0.iHai-vNwyTK3j8yLdbqZrU_BlvLOysevGVn229k_XGg\"; // public-safe\nfunction getSupabaseBrowser() {\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(SUPABASE_URL, SUPABASE_ANON_KEY, {\n        auth: {\n            autoRefreshToken: true,\n            persistSession: true\n        }\n    });\n}\n// ---------- helpers ----------\nfunction snake(row) {\n    const out = {};\n    for (const [k, v] of Object.entries(row)){\n        const nk = String(k).trim().toLowerCase().replace(/[^\\w]+/g, \"_\").replace(/_+/g, \"_\").replace(/^_+|_+$/g, \"\");\n        out[nk] = v;\n    }\n    return out;\n}\n// Escape % and _ so they DON'T act as wildcards in ILIKE\nfunction escapeLikeExact(s) {\n    return s.replace(/[%_]/g, (m)=>`\\\\${m}`);\n}\n// ---------- readers ----------\n/** Config as a simple key→value map */ async function sbReadConfig() {\n    const supabase = getSupabase();\n    const { data, error } = await supabase.from(\"config\").select(\"key,value\");\n    if (error) throw error;\n    const out = {};\n    for (const r of data || []){\n        const k = String(r.key ?? \"\").trim();\n        if (k) out[k] = String(r.value ?? \"\");\n    }\n    return out;\n}\n/** Ranges shaped like the old sheet */ async function sbReadRanges() {\n    const supabase = getSupabase();\n    const { data, error } = await supabase.from(\"ranges\").select(\"*\");\n    if (error) throw error;\n    return (data || []).map(snake);\n}\n/** Prefer results_wide (1 row per visit) */ async function sbReadResultsWideByPatient(patientId) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    const { data, error } = await supabase.from(\"results_wide\").select(\"*\").ilike(\"patient_id\", pid) // exact case-insensitive match (no wildcards)\n    .order(\"date_of_test\", {\n        ascending: true\n    });\n    if (error) throw error;\n    return (data || []).map(snake);\n}\n/** Fallback: read results_flat and pivot flat→wide per visit */ async function sbReadResultsFlatByPatient(patientId) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    const { data, error } = await supabase.from(\"results_flat\").select(\"*\").ilike(\"patient_id\", pid).order(\"date_of_test\", {\n        ascending: true\n    }).order(\"id\", {\n        ascending: true\n    });\n    if (error) throw error;\n    const flat = (data || []).map(snake);\n    if (!flat.length) return [];\n    // discover likely key/value columns\n    const keyField = [\n        \"analyte_key\",\n        \"key\",\n        \"parameter_key\",\n        \"param_key\",\n        \"analyte\",\n        \"parameter\"\n    ].find((k)=>k in flat[0]) || \"analyte_key\";\n    const valField = [\n        \"value\",\n        \"result\",\n        \"val\",\n        \"res\"\n    ].find((k)=>k in flat[0]) || \"value\";\n    const groups = new Map();\n    for (const r of flat){\n        const gk = [\n            r.patient_id ?? \"\",\n            r.date_of_test ?? \"\",\n            r.barcode ?? \"\",\n            r.notes ?? \"\"\n        ].join(\"|\");\n        let obj = groups.get(gk);\n        if (!obj) {\n            obj = {\n                patient_id: r.patient_id ?? \"\",\n                date_of_test: r.date_of_test ?? \"\",\n                barcode: r.barcode ?? \"\",\n                notes: r.notes ?? \"\"\n            };\n            groups.set(gk, obj);\n        }\n        const key = String(r[keyField] ?? \"\").trim();\n        if (key) obj[key] = r[valField] ?? \"\";\n    }\n    return Array.from(groups.values()).map(snake);\n}\n/** Public: read results as \"wide\" rows, using wide first then flat→wide */ async function sbReadResultsByPatient(patientId) {\n    const wide = await sbReadResultsWideByPatient(patientId);\n    if (wide.length) return wide;\n    return await sbReadResultsFlatByPatient(patientId);\n}\n/** Patient summary (Patients table) */ async function sbReadPatientById(patientId) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    const { data, error } = await supabase.from(\"patients\").select(\"*\").ilike(\"patient_id\", pid).limit(1).maybeSingle();\n    if (error) throw error;\n    return data ? snake(data) : null;\n}\nasync function sbListVitalsByPatient(patientId, opts) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    let query = supabase.from(\"vitals_snapshots\").select(\"*\").ilike(\"patient_id\", pid).order(\"measured_at\", {\n        ascending: false\n    });\n    if (opts?.consultationId) query = query.eq(\"consultation_id\", opts.consultationId);\n    if (opts?.encounterId) query = query.eq(\"encounter_id\", opts.encounterId);\n    query = query.limit(opts?.limit ?? 8);\n    const { data, error } = await query;\n    if (error) throw error;\n    return (data || []).map((r)=>snake(r));\n}\nasync function sbReadLatestVitalsByPatient(patientId, opts) {\n    const rows = await sbListVitalsByPatient(patientId, {\n        ...opts,\n        limit: 1\n    });\n    return rows[0] ?? null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVExQyxTQUNURyxJQUFJLENBQUMsb0JBQ0xDLE1BQU0sQ0FBQyxLQUNQUyxLQUFLLENBQUMsY0FBY0QsS0FDcEJFLEtBQUssQ0FBQyxlQUFlO1FBQUVDLFdBQVc7SUFBTTtJQUUzQyxJQUFJMEIsTUFBTUUsZ0JBQWdCRCxRQUFRQSxNQUFNRSxFQUFFLENBQUMsbUJBQW1CSCxLQUFLRSxjQUFjO0lBQ2pGLElBQUlGLE1BQU1JLGFBQWFILFFBQVFBLE1BQU1FLEVBQUUsQ0FBQyxnQkFBZ0JILEtBQUtJLFdBQVc7SUFDeEVILFFBQVFBLE1BQU1KLEtBQUssQ0FBQ0csTUFBTUgsU0FBUztJQUVuQyxNQUFNLEVBQUVyQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU13QztJQUM5QixJQUFJeEMsT0FBTyxNQUFNQTtJQUNqQixPQUFPLENBQUNELFFBQVEsRUFBRSxFQUFFUSxHQUFHLENBQUMsQ0FBQ0osSUFBTXJCLE1BQU1xQjtBQUN2QztBQUVPLGVBQWV5Qyw0QkFDcEJuQyxTQUFpQixFQUNqQjhCLElBQXdEO0lBRXhELE1BQU1NLE9BQU8sTUFBTVAsc0JBQXNCN0IsV0FBVztRQUFFLEdBQUc4QixJQUFJO1FBQUVILE9BQU87SUFBRTtJQUN4RSxPQUFPUyxJQUFJLENBQUMsRUFBRSxJQUFJO0FBQ3BCIiwic291cmNlcyI6WyIvVXNlcnMvcG9jaG9sby9Qcm9qZWN0cy93ZWxsc2Vydi1wb3J0YWwvYXBwcy93ZWIvbGliL3N1cGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9zdXBhYmFzZS50c1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50LCBTdXBhYmFzZUNsaWVudCB9IGZyb20gXCJAc3VwYWJhc2Uvc3VwYWJhc2UtanNcIjtcblxuY29uc3QgU1VQQUJBU0VfVVJMID0gcHJvY2Vzcy5lbnYuU1VQQUJBU0VfVVJMO1xuY29uc3QgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSA9IHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVk7XG5cbmlmICghU1VQQUJBU0VfVVJMKSB0aHJvdyBuZXcgRXJyb3IoXCJTVVBBQkFTRV9VUkwgaXMgcmVxdWlyZWRcIik7XG5pZiAoIVNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkpIHRocm93IG5ldyBFcnJvcihcIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkgaXMgcmVxdWlyZWRcIik7XG5cbmV4cG9ydCB0eXBlIFJvdyA9IFJlY29yZDxzdHJpbmcsIGFueT47XG5leHBvcnQgdHlwZSBWaXRhbHNTbmFwc2hvdFJvdyA9IFJvdyAmIHtcbiAgaWQ6IHN0cmluZztcbiAgcGF0aWVudF9pZDogc3RyaW5nO1xuICBjb25zdWx0YXRpb25faWQ6IHN0cmluZztcbiAgZW5jb3VudGVyX2lkOiBzdHJpbmc7XG4gIG1lYXN1cmVkX2F0OiBzdHJpbmc7XG4gIHN5c3RvbGljX2JwPzogbnVtYmVyIHwgbnVsbDtcbiAgZGlhc3RvbGljX2JwPzogbnVtYmVyIHwgbnVsbDtcbiAgaHI/OiBudW1iZXIgfCBudWxsO1xuICBycj86IG51bWJlciB8IG51bGw7XG4gIHRlbXBfYz86IG51bWJlciB8IG51bGw7XG4gIGhlaWdodF9jbT86IG51bWJlciB8IG51bGw7XG4gIHdlaWdodF9rZz86IG51bWJlciB8IG51bGw7XG4gIGJtaT86IG51bWJlciB8IG51bGw7XG4gIG8yc2F0PzogbnVtYmVyIHwgbnVsbDtcbiAgbm90ZXM/OiBzdHJpbmcgfCBudWxsO1xuICBzb3VyY2U/OiBzdHJpbmcgfCBudWxsO1xuICBjcmVhdGVkX2J5X2luaXRpYWxzPzogc3RyaW5nIHwgbnVsbDtcbiAgY3JlYXRlZF9hdD86IHN0cmluZyB8IG51bGw7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VwYWJhc2UoKTogU3VwYWJhc2VDbGllbnQge1xuICByZXR1cm4gY3JlYXRlQ2xpZW50KFNVUEFCQVNFX1VSTCEsIFNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkhLCB7XG4gICAgYXV0aDogeyBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSwgcGVyc2lzdFNlc3Npb246IGZhbHNlIH0sXG4gIH0pO1xufVxuXG5jb25zdCBTVVBBQkFTRV9BTk9OX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZOyAvLyBwdWJsaWMtc2FmZVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VwYWJhc2VCcm93c2VyKCk6IFN1cGFiYXNlQ2xpZW50IHtcbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChTVVBBQkFTRV9VUkwhLCBTVVBBQkFTRV9BTk9OX0tFWSEsIHtcbiAgICBhdXRoOiB7IGF1dG9SZWZyZXNoVG9rZW46IHRydWUsIHBlcnNpc3RTZXNzaW9uOiB0cnVlIH0sXG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tIGhlbHBlcnMgLS0tLS0tLS0tLVxuZnVuY3Rpb24gc25ha2U8VCBleHRlbmRzIFJvdz4ocm93OiBUKTogVCB7XG4gIGNvbnN0IG91dDogUm93ID0ge307XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHJvdykpIHtcbiAgICBjb25zdCBuayA9IFN0cmluZyhrKVxuICAgICAgLnRyaW0oKVxuICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgIC5yZXBsYWNlKC9bXlxcd10rL2csIFwiX1wiKVxuICAgICAgLnJlcGxhY2UoL18rL2csIFwiX1wiKVxuICAgICAgLnJlcGxhY2UoL15fK3xfKyQvZywgXCJcIik7XG4gICAgb3V0W25rXSA9IHY7XG4gIH1cbiAgcmV0dXJuIG91dCBhcyBUO1xufVxuXG4vLyBFc2NhcGUgJSBhbmQgXyBzbyB0aGV5IERPTidUIGFjdCBhcyB3aWxkY2FyZHMgaW4gSUxJS0VcbmZ1bmN0aW9uIGVzY2FwZUxpa2VFeGFjdChzOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvWyVfXS9nLCAobSkgPT4gYFxcXFwke219YCk7XG59XG5cbi8vIC0tLS0tLS0tLS0gcmVhZGVycyAtLS0tLS0tLS0tXG4vKiogQ29uZmlnIGFzIGEgc2ltcGxlIGtleeKGknZhbHVlIG1hcCAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNiUmVhZENvbmZpZygpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZSgpO1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwiY29uZmlnXCIpLnNlbGVjdChcImtleSx2YWx1ZVwiKTtcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgY29uc3Qgb3V0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGZvciAoY29uc3QgciBvZiBkYXRhIHx8IFtdKSB7XG4gICAgY29uc3QgayA9IFN0cmluZyhyLmtleSA/PyBcIlwiKS50cmltKCk7XG4gICAgaWYgKGspIG91dFtrXSA9IFN0cmluZyhyLnZhbHVlID8/IFwiXCIpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKiBSYW5nZXMgc2hhcGVkIGxpa2UgdGhlIG9sZCBzaGVldCAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNiUmVhZFJhbmdlcygpOiBQcm9taXNlPFJvd1tdPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0U3VwYWJhc2UoKTtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInJhbmdlc1wiKS5zZWxlY3QoXCIqXCIpO1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICByZXR1cm4gKGRhdGEgfHwgW10pLm1hcChzbmFrZSk7XG59XG5cbi8qKiBQcmVmZXIgcmVzdWx0c193aWRlICgxIHJvdyBwZXIgdmlzaXQpICovXG5hc3luYyBmdW5jdGlvbiBzYlJlYWRSZXN1bHRzV2lkZUJ5UGF0aWVudChwYXRpZW50SWQ6IHN0cmluZyk6IFByb21pc2U8Um93W10+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZSgpO1xuICBjb25zdCBwaWQgPSBlc2NhcGVMaWtlRXhhY3QoU3RyaW5nKHBhdGllbnRJZCB8fCBcIlwiKS50cmltKCkpO1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwicmVzdWx0c193aWRlXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZCkgLy8gZXhhY3QgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCAobm8gd2lsZGNhcmRzKVxuICAgIC5vcmRlcihcImRhdGVfb2ZfdGVzdFwiLCB7IGFzY2VuZGluZzogdHJ1ZSB9KTtcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgcmV0dXJuIChkYXRhIHx8IFtdKS5tYXAoc25ha2UpO1xufVxuXG4vKiogRmFsbGJhY2s6IHJlYWQgcmVzdWx0c19mbGF0IGFuZCBwaXZvdCBmbGF04oaSd2lkZSBwZXIgdmlzaXQgKi9cbmFzeW5jIGZ1bmN0aW9uIHNiUmVhZFJlc3VsdHNGbGF0QnlQYXRpZW50KHBhdGllbnRJZDogc3RyaW5nKTogUHJvbWlzZTxSb3dbXT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGdldFN1cGFiYXNlKCk7XG4gIGNvbnN0IHBpZCA9IGVzY2FwZUxpa2VFeGFjdChTdHJpbmcocGF0aWVudElkIHx8IFwiXCIpLnRyaW0oKSk7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJyZXN1bHRzX2ZsYXRcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKVxuICAgIC5vcmRlcihcImRhdGVfb2ZfdGVzdFwiLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgIC5vcmRlcihcImlkXCIsIHsgYXNjZW5kaW5nOiB0cnVlIH0pO1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXG4gIGNvbnN0IGZsYXQgPSAoZGF0YSB8fCBbXSkubWFwKHNuYWtlKTtcbiAgaWYgKCFmbGF0Lmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gIC8vIGRpc2NvdmVyIGxpa2VseSBrZXkvdmFsdWUgY29sdW1uc1xuICBjb25zdCBrZXlGaWVsZCA9XG4gICAgW1wiYW5hbHl0ZV9rZXlcIiwgXCJrZXlcIiwgXCJwYXJhbWV0ZXJfa2V5XCIsIFwicGFyYW1fa2V5XCIsIFwiYW5hbHl0ZVwiLCBcInBhcmFtZXRlclwiXS5maW5kKFxuICAgICAgKGspID0+IGsgaW4gZmxhdFswXVxuICAgICkgfHwgXCJhbmFseXRlX2tleVwiO1xuICBjb25zdCB2YWxGaWVsZCA9XG4gICAgW1widmFsdWVcIiwgXCJyZXN1bHRcIiwgXCJ2YWxcIiwgXCJyZXNcIl0uZmluZCgoaykgPT4gayBpbiBmbGF0WzBdKSB8fCBcInZhbHVlXCI7XG5cbiAgY29uc3QgZ3JvdXBzID0gbmV3IE1hcDxzdHJpbmcsIFJvdz4oKTtcbiAgZm9yIChjb25zdCByIG9mIGZsYXQpIHtcbiAgICBjb25zdCBnayA9IFtyLnBhdGllbnRfaWQgPz8gXCJcIiwgci5kYXRlX29mX3Rlc3QgPz8gXCJcIiwgci5iYXJjb2RlID8/IFwiXCIsIHIubm90ZXMgPz8gXCJcIl0uam9pbihcInxcIik7XG4gICAgbGV0IG9iaiA9IGdyb3Vwcy5nZXQoZ2spO1xuICAgIGlmICghb2JqKSB7XG4gICAgICBvYmogPSB7XG4gICAgICAgIHBhdGllbnRfaWQ6IHIucGF0aWVudF9pZCA/PyBcIlwiLFxuICAgICAgICBkYXRlX29mX3Rlc3Q6IHIuZGF0ZV9vZl90ZXN0ID8/IFwiXCIsXG4gICAgICAgIGJhcmNvZGU6IHIuYmFyY29kZSA/PyBcIlwiLFxuICAgICAgICBub3Rlczogci5ub3RlcyA/PyBcIlwiLFxuICAgICAgfTtcbiAgICAgIGdyb3Vwcy5zZXQoZ2ssIG9iaik7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IFN0cmluZyhyW2tleUZpZWxkXSA/PyBcIlwiKS50cmltKCk7XG4gICAgaWYgKGtleSkgKG9iaiBhcyBhbnkpW2tleV0gPSByW3ZhbEZpZWxkXSA/PyBcIlwiO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGdyb3Vwcy52YWx1ZXMoKSkubWFwKHNuYWtlKTtcbn1cblxuLyoqIFB1YmxpYzogcmVhZCByZXN1bHRzIGFzIFwid2lkZVwiIHJvd3MsIHVzaW5nIHdpZGUgZmlyc3QgdGhlbiBmbGF04oaSd2lkZSAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNiUmVhZFJlc3VsdHNCeVBhdGllbnQocGF0aWVudElkOiBzdHJpbmcpOiBQcm9taXNlPFJvd1tdPiB7XG4gIGNvbnN0IHdpZGUgPSBhd2FpdCBzYlJlYWRSZXN1bHRzV2lkZUJ5UGF0aWVudChwYXRpZW50SWQpO1xuICBpZiAod2lkZS5sZW5ndGgpIHJldHVybiB3aWRlO1xuICByZXR1cm4gYXdhaXQgc2JSZWFkUmVzdWx0c0ZsYXRCeVBhdGllbnQocGF0aWVudElkKTtcbn1cblxuLyoqIFBhdGllbnQgc3VtbWFyeSAoUGF0aWVudHMgdGFibGUpICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2JSZWFkUGF0aWVudEJ5SWQocGF0aWVudElkOiBzdHJpbmcpOiBQcm9taXNlPFJvdyB8IG51bGw+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZSgpO1xuICBjb25zdCBwaWQgPSBlc2NhcGVMaWtlRXhhY3QoU3RyaW5nKHBhdGllbnRJZCB8fCBcIlwiKS50cmltKCkpO1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwicGF0aWVudHNcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKVxuICAgIC5saW1pdCgxKVxuICAgIC5tYXliZVNpbmdsZSgpO1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICByZXR1cm4gZGF0YSA/IHNuYWtlKGRhdGEgYXMgUm93KSA6IG51bGw7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYkxpc3RWaXRhbHNCeVBhdGllbnQoXG4gIHBhdGllbnRJZDogc3RyaW5nLFxuICBvcHRzPzogeyBsaW1pdD86IG51bWJlcjsgY29uc3VsdGF0aW9uSWQ/OiBzdHJpbmc7IGVuY291bnRlcklkPzogc3RyaW5nIH1cbik6IFByb21pc2U8Vml0YWxzU25hcHNob3RSb3dbXT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGdldFN1cGFiYXNlKCk7XG4gIGNvbnN0IHBpZCA9IGVzY2FwZUxpa2VFeGFjdChTdHJpbmcocGF0aWVudElkIHx8IFwiXCIpLnRyaW0oKSk7XG4gIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgLmZyb20oXCJ2aXRhbHNfc25hcHNob3RzXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZClcbiAgICAub3JkZXIoXCJtZWFzdXJlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgaWYgKG9wdHM/LmNvbnN1bHRhdGlvbklkKSBxdWVyeSA9IHF1ZXJ5LmVxKFwiY29uc3VsdGF0aW9uX2lkXCIsIG9wdHMuY29uc3VsdGF0aW9uSWQpO1xuICBpZiAob3B0cz8uZW5jb3VudGVySWQpIHF1ZXJ5ID0gcXVlcnkuZXEoXCJlbmNvdW50ZXJfaWRcIiwgb3B0cy5lbmNvdW50ZXJJZCk7XG4gIHF1ZXJ5ID0gcXVlcnkubGltaXQob3B0cz8ubGltaXQgPz8gOCk7XG5cbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gIHJldHVybiAoZGF0YSB8fCBbXSkubWFwKChyKSA9PiBzbmFrZShyIGFzIFJvdykpIGFzIFZpdGFsc1NuYXBzaG90Um93W107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYlJlYWRMYXRlc3RWaXRhbHNCeVBhdGllbnQoXG4gIHBhdGllbnRJZDogc3RyaW5nLFxuICBvcHRzPzogeyBjb25zdWx0YXRpb25JZD86IHN0cmluZzsgZW5jb3VudGVySWQ/OiBzdHJpbmcgfVxuKTogUHJvbWlzZTxWaXRhbHNTbmFwc2hvdFJvdyB8IG51bGw+IHtcbiAgY29uc3Qgcm93cyA9IGF3YWl0IHNiTGlzdFZpdGFsc0J5UGF0aWVudChwYXRpZW50SWQsIHsgLi4ub3B0cywgbGltaXQ6IDEgfSk7XG4gIHJldHVybiByb3dzWzBdID8/IG51bGw7XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50IiwiU1VQQUJBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkiLCJFcnJvciIsImdldFN1cGFiYXNlIiwiYXV0aCIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsIlNVUEFCQVNFX0FOT05fS0VZIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJnZXRTdXBhYmFzZUJyb3dzZXIiLCJzbmFrZSIsInJvdyIsIm91dCIsImsiLCJ2IiwiT2JqZWN0IiwiZW50cmllcyIsIm5rIiwiU3RyaW5nIiwidHJpbSIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsImVzY2FwZUxpa2VFeGFjdCIsInMiLCJtIiwic2JSZWFkQ29uZmlnIiwic3VwYWJhc2UiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiciIsImtleSIsInZhbHVlIiwic2JSZWFkUmFuZ2VzIiwibWFwIiwic2JSZWFkUmVzdWx0c1dpZGVCeVBhdGllbnQiLCJwYXRpZW50SWQiLCJwaWQiLCJpbGlrZSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwic2JSZWFkUmVzdWx0c0ZsYXRCeVBhdGllbnQiLCJmbGF0IiwibGVuZ3RoIiwia2V5RmllbGQiLCJmaW5kIiwidmFsRmllbGQiLCJncm91cHMiLCJNYXAiLCJnayIsInBhdGllbnRfaWQiLCJkYXRlX29mX3Rlc3QiLCJiYXJjb2RlIiwibm90ZXMiLCJqb2luIiwib2JqIiwiZ2V0Iiwic2V0IiwiQXJyYXkiLCJ2YWx1ZXMiLCJzYlJlYWRSZXN1bHRzQnlQYXRpZW50Iiwid2lkZSIsInNiUmVhZFBhdGllbnRCeUlkIiwibGltaXQiLCJtYXliZVNpbmdsZSIsInNiTGlzdFZpdGFsc0J5UGF0aWVudCIsIm9wdHMiLCJxdWVyeSIsImNvbnN1bHRhdGlvbklkIiwiZXEiLCJlbmNvdW50ZXJJZCIsInNiUmVhZExhdGVzdFZpdGFsc0J5UGF0aWVudCIsInJvd3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase.ts\n");

/***/ })

};
;