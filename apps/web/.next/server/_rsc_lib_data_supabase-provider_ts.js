"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_lib_data_supabase-provider_ts";
exports.ids = ["_rsc_lib_data_supabase-provider_ts"];
exports.modules = {

/***/ "(rsc)/./lib/data/supabase-provider.ts":
/*!***************************************!*\
  !*** ./lib/data/supabase-provider.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSupabaseProvider: () => (/* binding */ createSupabaseProvider)\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(rsc)/./lib/supabase.ts\");\n// lib/data/supabase-provider.ts\n\n/* ----------------- helpers ----------------- */ function isPlaceholder(x) {\n    if (x === null || x === undefined) return true;\n    const s = String(x).trim();\n    return s === \"\" || s === \"-\" || s === \"—\" || s.toLowerCase() === \"n/a\";\n}\n// Parse common date formats → timestamp (ms). Handles ISO and M/D/YYYY (and D/M/YYYY when obvious).\nfunction ts(d) {\n    if (!d) return 0;\n    const s = String(d).trim();\n    // Try native parser first (works for ISO like 2025-09-25)\n    const t = Date.parse(s);\n    if (!Number.isNaN(t)) return t;\n    // Try M/D/YYYY or D/M/YYYY\n    const m = s.match(/^(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{2,4})$/);\n    if (m) {\n        const a = parseInt(m[1], 10);\n        const b = parseInt(m[2], 10);\n        const y = m[3].length === 2 ? 2000 + parseInt(m[3], 10) : parseInt(m[3], 10);\n        // If first number >12, it's D/M/Y; otherwise assume M/D/Y\n        const isDMY = a > 12;\n        const month = isDMY ? b - 1 : a - 1;\n        const day = isDMY ? a : b;\n        return new Date(y, month, day).getTime();\n    }\n    return 0; // fall back\n}\nfunction toNum(x) {\n    if (x === null || x === undefined) return null;\n    const s = String(x).replace(/,/g, \"\").trim();\n    if (isPlaceholder(s)) return null;\n    const n = Number(s);\n    return Number.isFinite(n) ? n : null;\n}\nfunction pick(...vals) {\n    for (const v of vals){\n        if (v === null || v === undefined) continue;\n        if (typeof v === \"string\" && isPlaceholder(v)) continue;\n        return v;\n    }\n    return null;\n}\n// exact, case-insensitive match for ILIKE (escape % and _)\nfunction escapeLikeExact(s) {\n    return s.replace(/[%_]/g, (m)=>`\\\\${m}`);\n}\nfunction prefixToSection(key) {\n    const k = (key || \"\").toLowerCase();\n    if (k.startsWith(\"hema_\")) return \"Hematology\";\n    if (k.startsWith(\"chem_\")) return \"Blood Chemistry\";\n    if (k.startsWith(\"fa_\")) return \"Fecalysis\";\n    if (k.startsWith(\"ua_\")) return \"Urinalysis\";\n    if (k.startsWith(\"sero_\")) return \"Serology\";\n    return \"Others\";\n}\n/* ---------- default per-section order (fallback when no ranges.order) ---------- */ const DEFAULT_ORDER = {\n    Hematology: [\n        \"hema_wbc\",\n        \"hema_lymph\",\n        \"hema_mid\",\n        \"hema_gran\",\n        \"hema_rbc\",\n        \"hema_hgb\",\n        \"hema_hct\",\n        \"hema_mcv\",\n        \"hema_mch\",\n        \"hema_mchc\",\n        \"hema_plt\",\n        \"hema_bt\",\n        \"hema_remarks\"\n    ],\n    \"Blood Chemistry\": [\n        \"chem_ogbase\",\n        \"chem_og1st\",\n        \"chem_og2nd\",\n        \"chem_fbs\",\n        \"chem_rbs\",\n        \"chem_hba1c\",\n        \"chem_chole\",\n        \"chem_trigly\",\n        \"chem_hdl\",\n        \"chem_ldl\",\n        \"chem_vldl\",\n        \"chem_bun\",\n        \"chem_crea\",\n        \"chem_bua\",\n        \"chem_ast\",\n        \"chem_alt\",\n        \"chem_tsh\",\n        \"chem_ft3\",\n        \"chem_ft4\",\n        \"chem_t3\",\n        \"chem_t4\",\n        \"chem_psa\",\n        \"chem_remarks\"\n    ],\n    Urinalysis: [\n        \"ua_color\",\n        \"ua_trans\",\n        \"ua_glu\",\n        \"ua_pro\",\n        \"ua_ph\",\n        \"ua_sg\",\n        \"blood\",\n        \"ua_bilirubin\",\n        \"ua_urobili\",\n        \"ua_ketones\",\n        \"ua_nitrites\",\n        \"ua_le\",\n        \"ua_cast\",\n        \"ua_casttype\",\n        \"ua_crystals\",\n        \"ua_crystalstype\",\n        \"ua_epi\",\n        \"ua_muc\",\n        \"ua_ura\",\n        \"ua_pho\",\n        \"ua_bac\",\n        \"ua_pus\",\n        \"ua_rbc\",\n        \"ua_remarks\"\n    ],\n    Fecalysis: [\n        \"fa_color\",\n        \"fa_cons\",\n        \"fa_pus\",\n        \"fa_rbc\",\n        \"fa_bac\",\n        \"fa_yeast\",\n        \"fa_fat\",\n        \"fa_para\",\n        \"fa_paratype\",\n        \"fa_fobt\",\n        \"fa_remarks\"\n    ],\n    Serology: [\n        \"sero_dengns1\",\n        \"sero_dengm\",\n        \"sero_dengg\",\n        \"sero_hepab\",\n        \"sero_rpv\",\n        \"sero_hiv\",\n        \"sero_hcv\",\n        \"sero_pt\",\n        \"sero_remarks\"\n    ],\n    Others: []\n};\nfunction buildOrderIndex(rangesRows) {\n    const byKeyOrder = new Map();\n    // ranges may have order-like columns; use first that exists\n    for (const r of rangesRows){\n        const key = String(r.analyte_key ?? r.key ?? r.parameter_key ?? r.param_key ?? \"\").trim();\n        if (!key) continue;\n        const orderRaw = r.order ?? r.sort_order ?? r.rank ?? r.prio ?? null;\n        const orderNum = toNum(orderRaw);\n        if (orderNum !== null) byKeyOrder.set(key, orderNum);\n    }\n    return byKeyOrder;\n}\nfunction sortItemsInSections(sections, rangesRows) {\n    const orderIndex = buildOrderIndex(rangesRows);\n    return sections.map((sec)=>{\n        const defaults = DEFAULT_ORDER[sec.name] ?? [];\n        const defaultIndex = new Map();\n        defaults.forEach((k, i)=>defaultIndex.set(k, i));\n        const items = [\n            ...sec.items\n        ].sort((a, b)=>{\n            const ao = orderIndex.get(a.key);\n            const bo = orderIndex.get(b.key);\n            if (ao !== undefined || bo !== undefined) {\n                if (ao === undefined) return 1;\n                if (bo === undefined) return -1;\n                return ao - bo;\n            }\n            const ad = defaultIndex.get(a.key);\n            const bd = defaultIndex.get(b.key);\n            if (ad !== undefined || bd !== undefined) {\n                if (ad === undefined) return 1;\n                if (bd === undefined) return -1;\n                return ad - bd;\n            }\n            // final fallback: alphabetical by label then key\n            const al = (a.label || \"\").toLowerCase();\n            const bl = (b.label || \"\").toLowerCase();\n            if (al !== bl) return al < bl ? -1 : 1;\n            return (a.key || \"\").localeCompare(b.key || \"\");\n        });\n        return {\n            ...sec,\n            items\n        };\n    });\n}\nfunction createSupabaseProvider() {\n    const TABLE_PATIENTS = \"patients\";\n    const TABLE_RESULTS = \"results_flat\";\n    const TABLE_RANGES = \"ranges\";\n    const TABLE_VITALS = \"vitals_snapshots\";\n    const TABLE_RESULTS_WIDE = \"results_wide\";\n    const db = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.getSupabase)();\n    // cache ranges + raw rows (for ordering)\n    let rangesCache = null;\n    let rangesRowsCache = null;\n    async function getRangesMap() {\n        if (rangesCache && rangesRowsCache) return {\n            map: rangesCache,\n            rows: rangesRowsCache\n        };\n        const { data, error } = await db.from(TABLE_RANGES).select(\"*\");\n        if (error) throw error;\n        const rows = data || [];\n        const map = new Map();\n        for (const r of rows){\n            const key = String(r.analyte_key ?? r.key ?? r.parameter_key ?? r.param_key ?? \"\").trim();\n            if (!key) continue;\n            const section = (r.section ?? r.group ?? r.category ?? null) || prefixToSection(key);\n            const label = (r.item_label ?? r.display_name ?? r.label ?? r.name ?? null) || null;\n            const unit = r.unit ?? r.units ?? r.uom ?? null;\n            // Your ranges use \"low\"/\"high\" (may be text); keep raw for display, numeric for flag logic\n            const low = r.low ?? null;\n            const high = r.high ?? null;\n            map.set(key, {\n                section,\n                label,\n                unit,\n                low,\n                high\n            });\n        }\n        rangesCache = map;\n        rangesRowsCache = rows;\n        return {\n            map,\n            rows\n        };\n    }\n    async function fetchVitalsSnapshots(patient_id, opts) {\n        const pid = escapeLikeExact(String(patient_id || \"\").trim());\n        let query = db.from(TABLE_VITALS).select(\"*\").ilike(\"patient_id\", pid).order(\"measured_at\", {\n            ascending: false\n        });\n        if (opts?.consultation_id) query = query.eq(\"consultation_id\", opts.consultation_id);\n        if (opts?.encounter_id) query = query.eq(\"encounter_id\", opts.encounter_id);\n        query = query.limit(opts?.limit ?? 8);\n        const { data, error } = await query;\n        if (error) throw error;\n        const rows = (data || []).map((r)=>({\n                id: String(r.id),\n                patient_id: String(r.patient_id),\n                consultation_id: String(r.consultation_id),\n                encounter_id: String(r.encounter_id),\n                measured_at: r.measured_at ?? r.created_at ?? new Date().toISOString(),\n                systolic_bp: toNum(r.systolic_bp),\n                diastolic_bp: toNum(r.diastolic_bp),\n                hr: toNum(r.hr),\n                rr: toNum(r.rr),\n                temp_c: r.temp_c == null ? null : Number(r.temp_c),\n                height_cm: r.height_cm == null ? null : Number(r.height_cm),\n                weight_kg: r.weight_kg == null ? null : Number(r.weight_kg),\n                bmi: r.bmi == null ? null : Number(r.bmi),\n                o2sat: toNum(r.o2sat),\n                notes: r.notes ?? null,\n                source: r.source ?? null,\n                created_at: r.created_at ?? null,\n                created_by_initials: r.created_by_initials ?? null\n            }));\n        return {\n            latest: rows[0] ?? null,\n            history: rows\n        };\n    }\n    async function fallbackPatientFromResults(patient_id) {\n        const pid = escapeLikeExact(String(patient_id || \"\").trim());\n        const { data, error } = await db.from(TABLE_RESULTS_WIDE).select(\"*\").ilike(\"patient_id\", pid).order(\"date_of_test\", {\n            ascending: false\n        }).limit(1).maybeSingle();\n        if (error) throw error;\n        if (!data) return null;\n        const vitals = await fetchVitalsSnapshots(patient_id).catch(()=>({\n                latest: null,\n                history: []\n            }));\n        return {\n            patient_id: data.patient_id ?? patient_id,\n            full_name: data.full_name ?? \"\",\n            sex: data.sex ?? \"\",\n            age: data.age ?? \"\",\n            birthday: data.birthday ?? \"\",\n            contact: data.contact ?? \"\",\n            address: data.address ?? \"\",\n            email: data.email ?? \"\",\n            systolic_bp: \"\",\n            diastolic_bp: \"\",\n            height_ft: \"\",\n            height_inch: \"\",\n            weight_kg: \"\",\n            medications_current: \"\",\n            medications: \"\",\n            family_history: \"\",\n            smoking_hx: \"\",\n            alcohol_hx: \"\",\n            vitals,\n            last_updated: data.last_updated ?? \"\"\n        };\n    }\n    async function listVisitRows(patient_id) {\n        const pid = escapeLikeExact(String(patient_id || \"\").trim());\n        const { data, error } = await db.from(TABLE_RESULTS).select(\"date_of_test, barcode, branch, notes\").ilike(\"patient_id\", pid);\n        if (error) throw error;\n        if (data && data.length > 0) {\n            return data.map((r)=>({\n                    date_of_test: String(r.date_of_test ?? \"\").trim(),\n                    barcode: r.barcode ?? \"\",\n                    branch: r.branch ?? \"\",\n                    notes: r.notes ?? \"\"\n                }));\n        }\n        // Fallback to wide table for legacy rows\n        const { data: wide, error: wideError } = await db.from(TABLE_RESULTS_WIDE).select(\"date_of_test, barcode, branch, notes\").ilike(\"patient_id\", pid);\n        if (wideError) throw wideError;\n        return (wide || []).map((r)=>({\n                date_of_test: String(r?.date_of_test ?? \"\").trim(),\n                barcode: r?.barcode ?? \"\",\n                branch: r?.branch ?? \"\",\n                notes: r?.notes ?? \"\"\n            }));\n    }\n    async function fetchResultRows(patient_id, visitDate) {\n        const pid = escapeLikeExact(String(patient_id || \"\").trim());\n        let query = db.from(TABLE_RESULTS).select(\"*\").ilike(\"patient_id\", pid);\n        if (visitDate) query = query.eq(\"date_of_test\", visitDate);\n        const { data, error } = await query;\n        if (error) throw error;\n        if (data && data.length > 0) return data;\n        // Fallback to the wide table: explode wide columns into flat rows\n        let wideQuery = db.from(TABLE_RESULTS_WIDE).select(\"*\").ilike(\"patient_id\", pid);\n        if (visitDate) wideQuery = wideQuery.eq(\"date_of_test\", visitDate);\n        const { data: wide, error: wideError } = await wideQuery;\n        if (wideError) throw wideError;\n        if (!wide || wide.length === 0) return [];\n        const skipKeys = new Set([\n            \"patient_id\",\n            \"date_of_test\",\n            \"barcode\",\n            \"notes\",\n            \"branch\",\n            \"id\",\n            \"created_at\",\n            \"updated_at\",\n            \"created_by\",\n            \"updated_by\",\n            \"created_by_initials\"\n        ]);\n        const flat = [];\n        for (const row of wide){\n            const base = {\n                patient_id: row.patient_id ?? patient_id,\n                date_of_test: row.date_of_test ?? visitDate ?? \"\",\n                barcode: row.barcode ?? \"\",\n                notes: row.notes ?? \"\",\n                branch: row.branch ?? \"\"\n            };\n            for (const [key, val] of Object.entries(row)){\n                if (skipKeys.has(key)) continue;\n                if (val === null || val === undefined || isPlaceholder(val)) continue;\n                flat.push({\n                    ...base,\n                    analyte_key: key,\n                    item_key: key,\n                    value: val\n                });\n            }\n        }\n        return flat;\n    }\n    return {\n        async getPatient (patient_id) {\n            const pid = escapeLikeExact(String(patient_id || \"\").trim());\n            const { data, error } = await db.from(TABLE_PATIENTS).select(\"*\").ilike(\"patient_id\", pid).limit(1).maybeSingle();\n            if (error) throw error;\n            if (!data) {\n                // Legacy rows might exist only in results_wide\n                const fallback = await fallbackPatientFromResults(patient_id);\n                if (!fallback) return null;\n                return fallback;\n            }\n            const medsCurrent = data.medications_current ?? \"\";\n            const vitals = await fetchVitalsSnapshots(patient_id).catch(()=>({\n                    latest: null,\n                    history: []\n                }));\n            const p = {\n                patient_id: data.patient_id,\n                full_name: data.full_name ?? \"\",\n                sex: data.sex ?? \"\",\n                age: data.age ?? \"\",\n                birthday: data.birthday ?? \"\",\n                contact: data.contact ?? \"\",\n                address: data.address ?? \"\",\n                email: data.email ?? \"\",\n                height_ft: data.height_ft ?? \"\",\n                height_inch: data.height_inch ?? \"\",\n                weight_kg: data.weight_kg ?? \"\",\n                systolic_bp: data.systolic_bp ?? \"\",\n                diastolic_bp: data.diastolic_bp ?? \"\",\n                last_updated: data.last_updated ?? \"\",\n                present_illness_history: data.present_illness_history ?? \"\",\n                past_medical_history: data.past_medical_history ?? \"\",\n                past_surgical_history: data.past_surgical_history ?? \"\",\n                chief_complaint: data.chief_complaint ?? \"\",\n                allergies_text: data.allergies_text ?? \"\",\n                medications_current: medsCurrent,\n                medications: medsCurrent,\n                family_history: data.family_hx ?? \"\",\n                smoking_hx: data.smoking_hx ?? \"\",\n                alcohol_hx: data.alcohol_hx ?? \"\",\n                vitals\n            };\n            return p;\n        },\n        async getVisits (patient_id) {\n            const visitRows = await listVisitRows(patient_id);\n            const seen = new Map();\n            for (const r of visitRows){\n                const rawDate = r.date_of_test ?? r.date ?? r.test_date ?? \"\";\n                const date = String(rawDate).trim();\n                if (!date || isPlaceholder(date)) continue;\n                if (!seen.has(date)) {\n                    seen.set(date, {\n                        date_of_test: date,\n                        barcode: r.barcode ?? \"\",\n                        branch: r.branch ?? \"\",\n                        notes: r.notes ?? \"\"\n                    });\n                }\n            }\n            return Array.from(seen.values()).sort((a, b)=>ts(b.date_of_test) - ts(a.date_of_test));\n        },\n        async getReport ({ patient_id, visitDate }) {\n            const patient = await this.getPatient(patient_id) || {\n                patient_id,\n                full_name: \"\",\n                vitals: {\n                    latest: null,\n                    history: []\n                }\n            };\n            let date = visitDate;\n            if (!date) {\n                const visits = await this.getVisits(patient_id);\n                date = visits[0]?.date_of_test;\n                if (!date) return null;\n            }\n            const rows = await fetchResultRows(patient_id, date);\n            if (rows.length === 0) return null;\n            const { map: rangesMap, rows: rangesRows } = await getRangesMap();\n            const bySection = new Map();\n            for (const r of rows){\n                const key = String(r.item_key ?? r.analyte_key ?? r.parameter_key ?? r.param_key ?? r.key ?? \"\").trim();\n                const meta = key ? rangesMap.get(key) : undefined;\n                const label = String(pick(r.item_label, r.display_name, r.parameter_label, r.label, meta?.label, key || null) ?? \"\").trim();\n                // unit: never allow \"null\" string\n                const unitRaw = pick(r.unit, r.units, r.uom, meta?.unit);\n                const unit = unitRaw == null ? \"\" : String(unitRaw);\n                // section from ranges or prefix\n                const section = String(pick(r.section, r.item_section, r.dept, r.category, meta?.section, prefixToSection(key || label), \"Others\"));\n                // value: treat \"-\" etc as null; keep numeric if possible for flags\n                const rawVal = pick(r.value, r.result, r.val);\n                const valueNum = toNum(rawVal);\n                const value = valueNum !== null ? valueNum : isPlaceholder(rawVal) ? null : rawVal;\n                // references (display raw, compute flags via numeric)\n                const rawLow = pick(r.ref_low, r.low, meta?.low);\n                const rawHigh = pick(r.ref_high, r.high, meta?.high);\n                const ref_low_display = isPlaceholder(rawLow) ? null : rawLow;\n                const ref_high_display = isPlaceholder(rawHigh) ? null : rawHigh;\n                const refLowNum = toNum(rawLow);\n                const refHighNum = toNum(rawHigh);\n                // flag: prefer DB; else compute L/H only (do NOT show \"N\")\n                let flag = null;\n                const rawFlag = pick(r.flag) ?? null;\n                if (rawFlag) {\n                    const f = String(rawFlag).toUpperCase();\n                    if (f === \"L\" || f === \"H\" || f === \"A\") flag = f;\n                } else if (valueNum !== null) {\n                    if (refLowNum !== null && valueNum < refLowNum) flag = \"L\";\n                    else if (refHighNum !== null && valueNum > refHighNum) flag = \"H\";\n                // else normal → leave null (you don't want \"N\")\n                }\n                const item = {\n                    key,\n                    label,\n                    unit,\n                    value,\n                    ref_low: ref_low_display,\n                    ref_high: ref_high_display,\n                    flag,\n                    method: r.method ?? null,\n                    remarks: r.remarks ?? null\n                };\n                // skip placeholders/blank values entirely (don't render)\n                if (item.value === null || typeof item.value === \"string\" && isPlaceholder(item.value)) {\n                    continue;\n                }\n                const arr = bySection.get(section) ?? [];\n                arr.push(item);\n                bySection.set(section, arr);\n            }\n            // sort items in each section\n            let sections = Array.from(bySection.entries()).map(([name, items])=>({\n                    name,\n                    items\n                })).filter((sec)=>sec.items.some((i)=>i.value !== null && String(i.value).trim() !== \"\"));\n            sections = sortItemsInSections(sections, rangesRows);\n            const first = rows[0] || {};\n            const visit = {\n                date_of_test: date,\n                barcode: first.barcode ?? \"\",\n                branch: first.branch ?? \"\",\n                notes: first.notes ?? \"\"\n            };\n            return {\n                patient,\n                visit,\n                sections\n            };\n        },\n        async searchPatients ({ query, limit = 20, offset = 0 }) {\n            const q = (query || \"\").trim();\n            if (!q) return {\n                results: [],\n                total: 0\n            };\n            const pat = `%${q.replace(/[%_]/g, (m)=>`\\\\${m}`)}%`;\n            const { data, error, count } = await db.from(TABLE_PATIENTS).select(\"patient_id, full_name, sex, age, birthday, contact, address, email\", {\n                count: \"exact\"\n            }).or(`patient_id.ilike.${pat},full_name.ilike.${pat}`).order(\"full_name\", {\n                ascending: true\n            }).range(offset, offset + limit - 1);\n            if (error) throw error;\n            return {\n                results: data || [],\n                total: count ?? undefined\n            };\n        },\n        async getConfig () {\n            return {\n                footer_lines: [],\n                signatories: []\n            };\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxjQUFjLEVBQUU7Z0JBQUVDLGFBQWEsRUFBRTtZQUFDO1FBQzdDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3BvY2hvbG8vUHJvamVjdHMvd2VsbHNlcnYtcG9ydGFsL2FwcHMvd2ViL2xpYi9kYXRhL3N1cGFiYXNlLXByb3ZpZGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9kYXRhL3N1cGFiYXNlLXByb3ZpZGVyLnRzXG5pbXBvcnQgdHlwZSB7XG4gIERhdGFQcm92aWRlcixcbiAgUGF0aWVudCxcbiAgVmlzaXQsXG4gIFJlcG9ydCxcbiAgUmVwb3J0U2VjdGlvbixcbiAgUmVwb3J0SXRlbSxcbiAgVml0YWxzU25hcHNob3QsXG59IGZyb20gXCIuL2RhdGEtcHJvdmlkZXJcIjtcbmltcG9ydCB7IGdldFN1cGFiYXNlIH0gZnJvbSBcIkAvbGliL3N1cGFiYXNlXCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tIGhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0gKi9cbmZ1bmN0aW9uIGlzUGxhY2Vob2xkZXIoeDogYW55KTogYm9vbGVhbiB7XG4gIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG4gIGNvbnN0IHMgPSBTdHJpbmcoeCkudHJpbSgpO1xuICByZXR1cm4gcyA9PT0gXCJcIiB8fCBzID09PSBcIi1cIiB8fCBzID09PSBcIuKAlFwiIHx8IHMudG9Mb3dlckNhc2UoKSA9PT0gXCJuL2FcIjtcbn1cblxuLy8gUGFyc2UgY29tbW9uIGRhdGUgZm9ybWF0cyDihpIgdGltZXN0YW1wIChtcykuIEhhbmRsZXMgSVNPIGFuZCBNL0QvWVlZWSAoYW5kIEQvTS9ZWVlZIHdoZW4gb2J2aW91cykuXG5mdW5jdGlvbiB0cyhkOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgaWYgKCFkKSByZXR1cm4gMDtcbiAgY29uc3QgcyA9IFN0cmluZyhkKS50cmltKCk7XG4gIC8vIFRyeSBuYXRpdmUgcGFyc2VyIGZpcnN0ICh3b3JrcyBmb3IgSVNPIGxpa2UgMjAyNS0wOS0yNSlcbiAgY29uc3QgdCA9IERhdGUucGFyc2Uocyk7XG4gIGlmICghTnVtYmVyLmlzTmFOKHQpKSByZXR1cm4gdDtcblxuICAvLyBUcnkgTS9EL1lZWVkgb3IgRC9NL1lZWVlcbiAgY29uc3QgbSA9IHMubWF0Y2goL14oXFxkezEsMn0pW1xcL1xcLV0oXFxkezEsMn0pW1xcL1xcLV0oXFxkezIsNH0pJC8pO1xuICBpZiAobSkge1xuICAgIGNvbnN0IGEgPSBwYXJzZUludChtWzFdLCAxMCk7XG4gICAgY29uc3QgYiA9IHBhcnNlSW50KG1bMl0sIDEwKTtcbiAgICBjb25zdCB5ID0gbVszXS5sZW5ndGggPT09IDIgPyAyMDAwICsgcGFyc2VJbnQobVszXSwgMTApIDogcGFyc2VJbnQobVszXSwgMTApO1xuICAgIC8vIElmIGZpcnN0IG51bWJlciA+MTIsIGl0J3MgRC9NL1k7IG90aGVyd2lzZSBhc3N1bWUgTS9EL1lcbiAgICBjb25zdCBpc0RNWSA9IGEgPiAxMjtcbiAgICBjb25zdCBtb250aCA9IGlzRE1ZID8gYiAtIDEgOiBhIC0gMTtcbiAgICBjb25zdCBkYXkgICA9IGlzRE1ZID8gYSAgICAgOiBiO1xuICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtb250aCwgZGF5KS5nZXRUaW1lKCk7XG4gIH1cblxuICByZXR1cm4gMDsgLy8gZmFsbCBiYWNrXG59XG5cbmZ1bmN0aW9uIHRvTnVtKHg6IGFueSk6IG51bWJlciB8IG51bGwge1xuICBpZiAoeCA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICBjb25zdCBzID0gU3RyaW5nKHgpLnJlcGxhY2UoLywvZywgXCJcIikudHJpbSgpO1xuICBpZiAoaXNQbGFjZWhvbGRlcihzKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG4gPSBOdW1iZXIocyk7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobikgPyBuIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHBpY2s8VD4oLi4udmFsczogVFtdKTogVCB8IG51bGwge1xuICBmb3IgKGNvbnN0IHYgb2YgdmFscykge1xuICAgIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmIGlzUGxhY2Vob2xkZXIodikpIGNvbnRpbnVlO1xuICAgIHJldHVybiB2O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuLy8gZXhhY3QsIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIElMSUtFIChlc2NhcGUgJSBhbmQgXylcbmZ1bmN0aW9uIGVzY2FwZUxpa2VFeGFjdChzOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvWyVfXS9nLCAobSkgPT4gYFxcXFwke219YCk7XG59XG5mdW5jdGlvbiBwcmVmaXhUb1NlY3Rpb24oa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBrID0gKGtleSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoay5zdGFydHNXaXRoKFwiaGVtYV9cIikpIHJldHVybiBcIkhlbWF0b2xvZ3lcIjtcbiAgaWYgKGsuc3RhcnRzV2l0aChcImNoZW1fXCIpKSByZXR1cm4gXCJCbG9vZCBDaGVtaXN0cnlcIjtcbiAgaWYgKGsuc3RhcnRzV2l0aChcImZhX1wiKSkgICByZXR1cm4gXCJGZWNhbHlzaXNcIjtcbiAgaWYgKGsuc3RhcnRzV2l0aChcInVhX1wiKSkgICByZXR1cm4gXCJVcmluYWx5c2lzXCI7XG4gIGlmIChrLnN0YXJ0c1dpdGgoXCJzZXJvX1wiKSkgcmV0dXJuIFwiU2Vyb2xvZ3lcIjtcbiAgcmV0dXJuIFwiT3RoZXJzXCI7XG59XG5cbi8qIC0tLS0tLS0tLS0gZGVmYXVsdCBwZXItc2VjdGlvbiBvcmRlciAoZmFsbGJhY2sgd2hlbiBubyByYW5nZXMub3JkZXIpIC0tLS0tLS0tLS0gKi9cbmNvbnN0IERFRkFVTFRfT1JERVI6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHtcbiAgSGVtYXRvbG9neTogW1xuICAgIFwiaGVtYV93YmNcIiwgXCJoZW1hX2x5bXBoXCIsIFwiaGVtYV9taWRcIiwgXCJoZW1hX2dyYW5cIixcbiAgICBcImhlbWFfcmJjXCIsIFwiaGVtYV9oZ2JcIiwgXCJoZW1hX2hjdFwiLCBcImhlbWFfbWN2XCIsIFwiaGVtYV9tY2hcIiwgXCJoZW1hX21jaGNcIixcbiAgICBcImhlbWFfcGx0XCIsIFwiaGVtYV9idFwiLCBcImhlbWFfcmVtYXJrc1wiLFxuICBdLFxuICBcIkJsb29kIENoZW1pc3RyeVwiOiBbXG4gICAgXCJjaGVtX29nYmFzZVwiLCBcImNoZW1fb2cxc3RcIiwgXCJjaGVtX29nMm5kXCIsIFwiY2hlbV9mYnNcIiwgXCJjaGVtX3Jic1wiLCBcImNoZW1faGJhMWNcIixcbiAgICBcImNoZW1fY2hvbGVcIiwgXCJjaGVtX3RyaWdseVwiLCBcImNoZW1faGRsXCIsIFwiY2hlbV9sZGxcIiwgXCJjaGVtX3ZsZGxcIixcbiAgICBcImNoZW1fYnVuXCIsIFwiY2hlbV9jcmVhXCIsIFwiY2hlbV9idWFcIixcbiAgICBcImNoZW1fYXN0XCIsIFwiY2hlbV9hbHRcIixcbiAgICBcImNoZW1fdHNoXCIsIFwiY2hlbV9mdDNcIiwgXCJjaGVtX2Z0NFwiLCBcImNoZW1fdDNcIiwgXCJjaGVtX3Q0XCIsXG4gICAgXCJjaGVtX3BzYVwiLCBcImNoZW1fcmVtYXJrc1wiLFxuICBdLFxuICBVcmluYWx5c2lzOiBbXG4gICAgXCJ1YV9jb2xvclwiLCBcInVhX3RyYW5zXCIsIFwidWFfZ2x1XCIsIFwidWFfcHJvXCIsIFwidWFfcGhcIiwgXCJ1YV9zZ1wiLCBcImJsb29kXCIsXG4gICAgXCJ1YV9iaWxpcnViaW5cIiwgXCJ1YV91cm9iaWxpXCIsIFwidWFfa2V0b25lc1wiLCBcInVhX25pdHJpdGVzXCIsIFwidWFfbGVcIixcbiAgICBcInVhX2Nhc3RcIiwgXCJ1YV9jYXN0dHlwZVwiLCBcInVhX2NyeXN0YWxzXCIsIFwidWFfY3J5c3RhbHN0eXBlXCIsXG4gICAgXCJ1YV9lcGlcIiwgXCJ1YV9tdWNcIiwgXCJ1YV91cmFcIiwgXCJ1YV9waG9cIixcbiAgICBcInVhX2JhY1wiLCBcInVhX3B1c1wiLCBcInVhX3JiY1wiLCBcInVhX3JlbWFya3NcIixcbiAgXSxcbiAgRmVjYWx5c2lzOiBbXG4gICAgXCJmYV9jb2xvclwiLFx0XCJmYV9jb25zXCIsIFwiZmFfcHVzXCIsIFwiZmFfcmJjXCIsXG4gICAgXCJmYV9iYWNcIiwgXCJmYV95ZWFzdFwiLCBcImZhX2ZhdFwiLCBcImZhX3BhcmFcIiwgXCJmYV9wYXJhdHlwZVwiLFxuICAgIFwiZmFfZm9idFwiLCBcImZhX3JlbWFya3NcIixcbl0sXG4gIFNlcm9sb2d5OiBbXG4gICAgXCJzZXJvX2RlbmduczFcIiwgXCJzZXJvX2RlbmdtXCIsIFwic2Vyb19kZW5nZ1wiLFxuICAgIFwic2Vyb19oZXBhYlwiLCBcInNlcm9fcnB2XCIsIFwic2Vyb19oaXZcIiwgXCJzZXJvX2hjdlwiLCBcInNlcm9fcHRcIixcbiAgICBcInNlcm9fcmVtYXJrc1wiXG5dLFxuICBPdGhlcnM6IFtdLFxufTtcbmZ1bmN0aW9uIGJ1aWxkT3JkZXJJbmRleChyYW5nZXNSb3dzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+W10pIHtcbiAgY29uc3QgYnlLZXlPcmRlciA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gIC8vIHJhbmdlcyBtYXkgaGF2ZSBvcmRlci1saWtlIGNvbHVtbnM7IHVzZSBmaXJzdCB0aGF0IGV4aXN0c1xuICBmb3IgKGNvbnN0IHIgb2YgcmFuZ2VzUm93cykge1xuICAgIGNvbnN0IGtleSA9IFN0cmluZyhcbiAgICAgIHIuYW5hbHl0ZV9rZXkgPz8gci5rZXkgPz8gci5wYXJhbWV0ZXJfa2V5ID8/IHIucGFyYW1fa2V5ID8/IFwiXCJcbiAgICApLnRyaW0oKTtcbiAgICBpZiAoIWtleSkgY29udGludWU7XG4gICAgY29uc3Qgb3JkZXJSYXcgPSAoci5vcmRlciA/PyByLnNvcnRfb3JkZXIgPz8gci5yYW5rID8/IHIucHJpbyA/PyBudWxsKTtcbiAgICBjb25zdCBvcmRlck51bSA9IHRvTnVtKG9yZGVyUmF3KTtcbiAgICBpZiAob3JkZXJOdW0gIT09IG51bGwpIGJ5S2V5T3JkZXIuc2V0KGtleSwgb3JkZXJOdW0pO1xuICB9XG4gIHJldHVybiBieUtleU9yZGVyO1xufVxuZnVuY3Rpb24gc29ydEl0ZW1zSW5TZWN0aW9ucyhcbiAgc2VjdGlvbnM6IFJlcG9ydFNlY3Rpb25bXSxcbiAgcmFuZ2VzUm93czogUmVjb3JkPHN0cmluZywgYW55PltdXG4pOiBSZXBvcnRTZWN0aW9uW10ge1xuICBjb25zdCBvcmRlckluZGV4ID0gYnVpbGRPcmRlckluZGV4KHJhbmdlc1Jvd3MpO1xuICByZXR1cm4gc2VjdGlvbnMubWFwKChzZWMpID0+IHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IERFRkFVTFRfT1JERVJbc2VjLm5hbWVdID8/IFtdO1xuICAgIGNvbnN0IGRlZmF1bHRJbmRleCA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gICAgZGVmYXVsdHMuZm9yRWFjaCgoaywgaSkgPT4gZGVmYXVsdEluZGV4LnNldChrLCBpKSk7XG5cbiAgICBjb25zdCBpdGVtcyA9IFsuLi5zZWMuaXRlbXNdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFvID0gb3JkZXJJbmRleC5nZXQoYS5rZXkpO1xuICAgICAgY29uc3QgYm8gPSBvcmRlckluZGV4LmdldChiLmtleSk7XG4gICAgICBpZiAoYW8gIT09IHVuZGVmaW5lZCB8fCBibyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhbyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGJvID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICAgICAgcmV0dXJuIGFvIC0gYm87XG4gICAgICB9XG4gICAgICBjb25zdCBhZCA9IGRlZmF1bHRJbmRleC5nZXQoYS5rZXkpO1xuICAgICAgY29uc3QgYmQgPSBkZWZhdWx0SW5kZXguZ2V0KGIua2V5KTtcbiAgICAgIGlmIChhZCAhPT0gdW5kZWZpbmVkIHx8IGJkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFkID09PSB1bmRlZmluZWQpIHJldHVybiAxO1xuICAgICAgICBpZiAoYmQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gYWQgLSBiZDtcbiAgICAgIH1cbiAgICAgIC8vIGZpbmFsIGZhbGxiYWNrOiBhbHBoYWJldGljYWwgYnkgbGFiZWwgdGhlbiBrZXlcbiAgICAgIGNvbnN0IGFsID0gKGEubGFiZWwgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IGJsID0gKGIubGFiZWwgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChhbCAhPT0gYmwpIHJldHVybiBhbCA8IGJsID8gLTEgOiAxO1xuICAgICAgcmV0dXJuIChhLmtleSB8fCBcIlwiKS5sb2NhbGVDb21wYXJlKGIua2V5IHx8IFwiXCIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgLi4uc2VjLCBpdGVtcyB9O1xuICB9KTtcbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0gcHJvdmlkZXIgLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnR5cGUgUmFuZ2VNZXRhID0ge1xuICBzZWN0aW9uPzogc3RyaW5nIHwgbnVsbDtcbiAgbGFiZWw/OiBzdHJpbmcgfCBudWxsO1xuICB1bml0Pzogc3RyaW5nIHwgbnVsbDtcbiAgbG93PzogbnVtYmVyIHwgc3RyaW5nIHwgbnVsbDtcbiAgaGlnaD86IG51bWJlciB8IHN0cmluZyB8IG51bGw7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3VwYWJhc2VQcm92aWRlcigpOiBEYXRhUHJvdmlkZXIge1xuICBjb25zdCBUQUJMRV9QQVRJRU5UUyA9IFwicGF0aWVudHNcIjtcbiAgY29uc3QgVEFCTEVfUkVTVUxUUyAgPSBcInJlc3VsdHNfZmxhdFwiO1xuICBjb25zdCBUQUJMRV9SQU5HRVMgICA9IFwicmFuZ2VzXCI7XG4gIGNvbnN0IFRBQkxFX1ZJVEFMUyAgID0gXCJ2aXRhbHNfc25hcHNob3RzXCI7XG4gIGNvbnN0IFRBQkxFX1JFU1VMVFNfV0lERSA9IFwicmVzdWx0c193aWRlXCI7XG5cbiAgY29uc3QgZGIgPSBnZXRTdXBhYmFzZSgpO1xuXG4gIC8vIGNhY2hlIHJhbmdlcyArIHJhdyByb3dzIChmb3Igb3JkZXJpbmcpXG4gIGxldCByYW5nZXNDYWNoZTogTWFwPHN0cmluZywgUmFuZ2VNZXRhPiB8IG51bGwgPSBudWxsO1xuICBsZXQgcmFuZ2VzUm93c0NhY2hlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+W10gfCBudWxsID0gbnVsbDtcblxuICBhc3luYyBmdW5jdGlvbiBnZXRSYW5nZXNNYXAoKTogUHJvbWlzZTx7IG1hcDogTWFwPHN0cmluZywgUmFuZ2VNZXRhPjsgcm93czogUmVjb3JkPHN0cmluZywgYW55PltdIH0+IHtcbiAgICBpZiAocmFuZ2VzQ2FjaGUgJiYgcmFuZ2VzUm93c0NhY2hlKSByZXR1cm4geyBtYXA6IHJhbmdlc0NhY2hlLCByb3dzOiByYW5nZXNSb3dzQ2FjaGUgfTtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBkYi5mcm9tKFRBQkxFX1JBTkdFUykuc2VsZWN0KFwiKlwiKTtcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXG4gICAgY29uc3Qgcm93cyA9IChkYXRhIHx8IFtdKSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+W107XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcDxzdHJpbmcsIFJhbmdlTWV0YT4oKTtcbiAgICBmb3IgKGNvbnN0IHIgb2Ygcm93cykge1xuICAgICAgY29uc3Qga2V5ID0gU3RyaW5nKFxuICAgICAgICByLmFuYWx5dGVfa2V5ID8/IHIua2V5ID8/IHIucGFyYW1ldGVyX2tleSA/PyByLnBhcmFtX2tleSA/PyBcIlwiXG4gICAgICApLnRyaW0oKTtcbiAgICAgIGlmICgha2V5KSBjb250aW51ZTtcblxuICAgICAgY29uc3Qgc2VjdGlvbiA9XG4gICAgICAgIChyLnNlY3Rpb24gPz8gci5ncm91cCA/PyByLmNhdGVnb3J5ID8/IG51bGwpIHx8IHByZWZpeFRvU2VjdGlvbihrZXkpO1xuICAgICAgY29uc3QgbGFiZWwgPVxuICAgICAgICAoci5pdGVtX2xhYmVsID8/IHIuZGlzcGxheV9uYW1lID8/IHIubGFiZWwgPz8gci5uYW1lID8/IG51bGwpIHx8IG51bGw7XG4gICAgICBjb25zdCB1bml0ID0gci51bml0ID8/IHIudW5pdHMgPz8gci51b20gPz8gbnVsbDtcbiAgICAgIC8vIFlvdXIgcmFuZ2VzIHVzZSBcImxvd1wiL1wiaGlnaFwiIChtYXkgYmUgdGV4dCk7IGtlZXAgcmF3IGZvciBkaXNwbGF5LCBudW1lcmljIGZvciBmbGFnIGxvZ2ljXG4gICAgICBjb25zdCBsb3cgID0gci5sb3cgID8/IG51bGw7XG4gICAgICBjb25zdCBoaWdoID0gci5oaWdoID8/IG51bGw7XG5cbiAgICAgIG1hcC5zZXQoa2V5LCB7IHNlY3Rpb24sIGxhYmVsLCB1bml0LCBsb3csIGhpZ2ggfSk7XG4gICAgfVxuICAgIHJhbmdlc0NhY2hlID0gbWFwO1xuICAgIHJhbmdlc1Jvd3NDYWNoZSA9IHJvd3M7XG4gICAgcmV0dXJuIHsgbWFwLCByb3dzIH07XG4gIH1cblxuICB0eXBlIFZpdGFsc0J1bmRsZSA9IHsgbGF0ZXN0OiBWaXRhbHNTbmFwc2hvdCB8IG51bGw7IGhpc3Rvcnk6IFZpdGFsc1NuYXBzaG90W10gfTtcblxuICBhc3luYyBmdW5jdGlvbiBmZXRjaFZpdGFsc1NuYXBzaG90cyhcbiAgICBwYXRpZW50X2lkOiBzdHJpbmcsXG4gICAgb3B0cz86IHsgbGltaXQ/OiBudW1iZXI7IGNvbnN1bHRhdGlvbl9pZD86IHN0cmluZyB8IG51bGw7IGVuY291bnRlcl9pZD86IHN0cmluZyB8IG51bGw7IH1cbiAgKTogUHJvbWlzZTxWaXRhbHNCdW5kbGU+IHtcbiAgICBjb25zdCBwaWQgPSBlc2NhcGVMaWtlRXhhY3QoU3RyaW5nKHBhdGllbnRfaWQgfHwgXCJcIikudHJpbSgpKTtcbiAgICBsZXQgcXVlcnkgPSBkYlxuICAgICAgLmZyb20oVEFCTEVfVklUQUxTKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKVxuICAgICAgLm9yZGVyKFwibWVhc3VyZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuXG4gICAgaWYgKG9wdHM/LmNvbnN1bHRhdGlvbl9pZCkgcXVlcnkgPSBxdWVyeS5lcShcImNvbnN1bHRhdGlvbl9pZFwiLCBvcHRzLmNvbnN1bHRhdGlvbl9pZCk7XG4gICAgaWYgKG9wdHM/LmVuY291bnRlcl9pZCkgcXVlcnkgPSBxdWVyeS5lcShcImVuY291bnRlcl9pZFwiLCBvcHRzLmVuY291bnRlcl9pZCk7XG4gICAgcXVlcnkgPSBxdWVyeS5saW1pdChvcHRzPy5saW1pdCA/PyA4KTtcblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cbiAgICBjb25zdCByb3dzOiBWaXRhbHNTbmFwc2hvdFtdID0gKGRhdGEgfHwgW10pLm1hcCgocikgPT4gKHtcbiAgICAgIGlkOiBTdHJpbmcoci5pZCksXG4gICAgICBwYXRpZW50X2lkOiBTdHJpbmcoci5wYXRpZW50X2lkKSxcbiAgICAgIGNvbnN1bHRhdGlvbl9pZDogU3RyaW5nKHIuY29uc3VsdGF0aW9uX2lkKSxcbiAgICAgIGVuY291bnRlcl9pZDogU3RyaW5nKHIuZW5jb3VudGVyX2lkKSxcbiAgICAgIG1lYXN1cmVkX2F0OiAoci5tZWFzdXJlZF9hdCA/PyByLmNyZWF0ZWRfYXQgPz8gbmV3IERhdGUoKS50b0lTT1N0cmluZygpKSBhcyBzdHJpbmcsXG4gICAgICBzeXN0b2xpY19icDogdG9OdW0oci5zeXN0b2xpY19icCksXG4gICAgICBkaWFzdG9saWNfYnA6IHRvTnVtKHIuZGlhc3RvbGljX2JwKSxcbiAgICAgIGhyOiB0b051bShyLmhyKSxcbiAgICAgIHJyOiB0b051bShyLnJyKSxcbiAgICAgIHRlbXBfYzogci50ZW1wX2MgPT0gbnVsbCA/IG51bGwgOiBOdW1iZXIoci50ZW1wX2MpLFxuICAgICAgaGVpZ2h0X2NtOiByLmhlaWdodF9jbSA9PSBudWxsID8gbnVsbCA6IE51bWJlcihyLmhlaWdodF9jbSksXG4gICAgICB3ZWlnaHRfa2c6IHIud2VpZ2h0X2tnID09IG51bGwgPyBudWxsIDogTnVtYmVyKHIud2VpZ2h0X2tnKSxcbiAgICAgIGJtaTogci5ibWkgPT0gbnVsbCA/IG51bGwgOiBOdW1iZXIoci5ibWkpLFxuICAgICAgbzJzYXQ6IHRvTnVtKHIubzJzYXQpLFxuICAgICAgbm90ZXM6IHIubm90ZXMgPz8gbnVsbCxcbiAgICAgIHNvdXJjZTogci5zb3VyY2UgPz8gbnVsbCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHIuY3JlYXRlZF9hdCA/PyBudWxsLFxuICAgICAgY3JlYXRlZF9ieV9pbml0aWFsczogci5jcmVhdGVkX2J5X2luaXRpYWxzID8/IG51bGwsXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhdGVzdDogcm93c1swXSA/PyBudWxsLFxuICAgICAgaGlzdG9yeTogcm93cyxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gZmFsbGJhY2tQYXRpZW50RnJvbVJlc3VsdHMocGF0aWVudF9pZDogc3RyaW5nKTogUHJvbWlzZTxQYXRpZW50IHwgbnVsbD4ge1xuICAgIGNvbnN0IHBpZCA9IGVzY2FwZUxpa2VFeGFjdChTdHJpbmcocGF0aWVudF9pZCB8fCBcIlwiKS50cmltKCkpO1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGRiXG4gICAgICAuZnJvbShUQUJMRV9SRVNVTFRTX1dJREUpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmlsaWtlKFwicGF0aWVudF9pZFwiLCBwaWQpXG4gICAgICAub3JkZXIoXCJkYXRlX29mX3Rlc3RcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAubGltaXQoMSlcbiAgICAgIC5tYXliZVNpbmdsZSgpO1xuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3Qgdml0YWxzID0gYXdhaXQgZmV0Y2hWaXRhbHNTbmFwc2hvdHMocGF0aWVudF9pZCkuY2F0Y2goXG4gICAgICAoKTogVml0YWxzQnVuZGxlID0+ICh7IGxhdGVzdDogbnVsbCwgaGlzdG9yeTogW10gfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGllbnRfaWQ6IGRhdGEucGF0aWVudF9pZCA/PyBwYXRpZW50X2lkLFxuICAgICAgZnVsbF9uYW1lOiAgZGF0YS5mdWxsX25hbWUgPz8gXCJcIixcbiAgICAgIHNleDogICAgICAgIGRhdGEuc2V4ID8/IFwiXCIsXG4gICAgICBhZ2U6ICAgICAgICBkYXRhLmFnZSA/PyBcIlwiLFxuICAgICAgYmlydGhkYXk6ICAgZGF0YS5iaXJ0aGRheSA/PyBcIlwiLFxuICAgICAgY29udGFjdDogICAgZGF0YS5jb250YWN0ID8/IFwiXCIsXG4gICAgICBhZGRyZXNzOiAgICBkYXRhLmFkZHJlc3MgPz8gXCJcIixcbiAgICAgIGVtYWlsOiAgICAgIGRhdGEuZW1haWwgPz8gXCJcIixcbiAgICAgIHN5c3RvbGljX2JwOiBcIlwiLFxuICAgICAgZGlhc3RvbGljX2JwOiBcIlwiLFxuICAgICAgaGVpZ2h0X2Z0OiBcIlwiLFxuICAgICAgaGVpZ2h0X2luY2g6IFwiXCIsXG4gICAgICB3ZWlnaHRfa2c6IFwiXCIsXG4gICAgICBtZWRpY2F0aW9uc19jdXJyZW50OiBcIlwiLFxuICAgICAgbWVkaWNhdGlvbnM6IFwiXCIsXG4gICAgICBmYW1pbHlfaGlzdG9yeTogXCJcIixcbiAgICAgIHNtb2tpbmdfaHg6IFwiXCIsXG4gICAgICBhbGNvaG9sX2h4OiBcIlwiLFxuICAgICAgdml0YWxzLFxuICAgICAgbGFzdF91cGRhdGVkOiBkYXRhLmxhc3RfdXBkYXRlZCA/PyBcIlwiLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBsaXN0VmlzaXRSb3dzKHBhdGllbnRfaWQ6IHN0cmluZyk6IFByb21pc2U8VmlzaXRbXT4ge1xuICAgIGNvbnN0IHBpZCA9IGVzY2FwZUxpa2VFeGFjdChTdHJpbmcocGF0aWVudF9pZCB8fCBcIlwiKS50cmltKCkpO1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgZGJcbiAgICAgIC5mcm9tKFRBQkxFX1JFU1VMVFMpXG4gICAgICAuc2VsZWN0KFwiZGF0ZV9vZl90ZXN0LCBiYXJjb2RlLCBicmFuY2gsIG5vdGVzXCIpXG4gICAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZCk7XG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIChkYXRhIGFzIFJlY29yZDxzdHJpbmcsIGFueT5bXSkubWFwKChyKSA9PiAoe1xuICAgICAgICBkYXRlX29mX3Rlc3Q6IFN0cmluZyhyLmRhdGVfb2ZfdGVzdCA/PyBcIlwiKS50cmltKCksXG4gICAgICAgIGJhcmNvZGU6IHIuYmFyY29kZSA/PyBcIlwiLFxuICAgICAgICBicmFuY2g6IHIuYnJhbmNoID8/IFwiXCIsXG4gICAgICAgIG5vdGVzOiByLm5vdGVzID8/IFwiXCIsXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gd2lkZSB0YWJsZSBmb3IgbGVnYWN5IHJvd3NcbiAgICBjb25zdCB7IGRhdGE6IHdpZGUsIGVycm9yOiB3aWRlRXJyb3IgfSA9IGF3YWl0IGRiXG4gICAgICAuZnJvbShUQUJMRV9SRVNVTFRTX1dJREUpXG4gICAgICAuc2VsZWN0KFwiZGF0ZV9vZl90ZXN0LCBiYXJjb2RlLCBicmFuY2gsIG5vdGVzXCIpXG4gICAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZCk7XG5cbiAgICBpZiAod2lkZUVycm9yKSB0aHJvdyB3aWRlRXJyb3I7XG5cbiAgICByZXR1cm4gKHdpZGUgfHwgW10pLm1hcCgocjogYW55KSA9PiAoe1xuICAgICAgZGF0ZV9vZl90ZXN0OiBTdHJpbmcocj8uZGF0ZV9vZl90ZXN0ID8/IFwiXCIpLnRyaW0oKSxcbiAgICAgIGJhcmNvZGU6IHI/LmJhcmNvZGUgPz8gXCJcIixcbiAgICAgIGJyYW5jaDogcj8uYnJhbmNoID8/IFwiXCIsXG4gICAgICBub3Rlczogcj8ubm90ZXMgPz8gXCJcIixcbiAgICB9KSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBmZXRjaFJlc3VsdFJvd3MocGF0aWVudF9pZDogc3RyaW5nLCB2aXNpdERhdGU/OiBzdHJpbmcpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIGFueT5bXT4ge1xuICAgIGNvbnN0IHBpZCA9IGVzY2FwZUxpa2VFeGFjdChTdHJpbmcocGF0aWVudF9pZCB8fCBcIlwiKS50cmltKCkpO1xuICAgIGxldCBxdWVyeSA9IGRiXG4gICAgICAuZnJvbShUQUJMRV9SRVNVTFRTKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKTtcblxuICAgIGlmICh2aXNpdERhdGUpIHF1ZXJ5ID0gcXVlcnkuZXEoXCJkYXRlX29mX3Rlc3RcIiwgdmlzaXREYXRlKTtcblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSByZXR1cm4gZGF0YSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+W107XG5cbiAgICAvLyBGYWxsYmFjayB0byB0aGUgd2lkZSB0YWJsZTogZXhwbG9kZSB3aWRlIGNvbHVtbnMgaW50byBmbGF0IHJvd3NcbiAgICBsZXQgd2lkZVF1ZXJ5ID0gZGJcbiAgICAgIC5mcm9tKFRBQkxFX1JFU1VMVFNfV0lERSlcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZCk7XG5cbiAgICBpZiAodmlzaXREYXRlKSB3aWRlUXVlcnkgPSB3aWRlUXVlcnkuZXEoXCJkYXRlX29mX3Rlc3RcIiwgdmlzaXREYXRlKTtcblxuICAgIGNvbnN0IHsgZGF0YTogd2lkZSwgZXJyb3I6IHdpZGVFcnJvciB9ID0gYXdhaXQgd2lkZVF1ZXJ5O1xuICAgIGlmICh3aWRlRXJyb3IpIHRocm93IHdpZGVFcnJvcjtcbiAgICBpZiAoIXdpZGUgfHwgd2lkZS5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICAgIGNvbnN0IHNraXBLZXlzID0gbmV3IFNldChbXG4gICAgICBcInBhdGllbnRfaWRcIixcbiAgICAgIFwiZGF0ZV9vZl90ZXN0XCIsXG4gICAgICBcImJhcmNvZGVcIixcbiAgICAgIFwibm90ZXNcIixcbiAgICAgIFwiYnJhbmNoXCIsXG4gICAgICBcImlkXCIsXG4gICAgICBcImNyZWF0ZWRfYXRcIixcbiAgICAgIFwidXBkYXRlZF9hdFwiLFxuICAgICAgXCJjcmVhdGVkX2J5XCIsXG4gICAgICBcInVwZGF0ZWRfYnlcIixcbiAgICAgIFwiY3JlYXRlZF9ieV9pbml0aWFsc1wiLFxuICAgIF0pO1xuXG4gICAgY29uc3QgZmxhdDogUmVjb3JkPHN0cmluZywgYW55PltdID0gW107XG4gICAgZm9yIChjb25zdCByb3cgb2Ygd2lkZSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+W10pIHtcbiAgICAgIGNvbnN0IGJhc2UgPSB7XG4gICAgICAgIHBhdGllbnRfaWQ6IHJvdy5wYXRpZW50X2lkID8/IHBhdGllbnRfaWQsXG4gICAgICAgIGRhdGVfb2ZfdGVzdDogcm93LmRhdGVfb2ZfdGVzdCA/PyB2aXNpdERhdGUgPz8gXCJcIixcbiAgICAgICAgYmFyY29kZTogcm93LmJhcmNvZGUgPz8gXCJcIixcbiAgICAgICAgbm90ZXM6IHJvdy5ub3RlcyA/PyBcIlwiLFxuICAgICAgICBicmFuY2g6IHJvdy5icmFuY2ggPz8gXCJcIixcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMocm93KSkge1xuICAgICAgICBpZiAoc2tpcEtleXMuaGFzKGtleSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkIHx8IGlzUGxhY2Vob2xkZXIodmFsKSkgY29udGludWU7XG4gICAgICAgIGZsYXQucHVzaCh7XG4gICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICBhbmFseXRlX2tleToga2V5LFxuICAgICAgICAgIGl0ZW1fa2V5OiBrZXksXG4gICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsYXQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFzeW5jIGdldFBhdGllbnQocGF0aWVudF9pZDogc3RyaW5nKTogUHJvbWlzZTxQYXRpZW50IHwgbnVsbD4ge1xuICAgICAgY29uc3QgcGlkID0gZXNjYXBlTGlrZUV4YWN0KFN0cmluZyhwYXRpZW50X2lkIHx8IFwiXCIpLnRyaW0oKSk7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBkYlxuICAgICAgICAuZnJvbShUQUJMRV9QQVRJRU5UUylcbiAgICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgICAgLmlsaWtlKFwicGF0aWVudF9pZFwiLCBwaWQpXG4gICAgICAgIC5saW1pdCgxKVxuICAgICAgICAubWF5YmVTaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAvLyBMZWdhY3kgcm93cyBtaWdodCBleGlzdCBvbmx5IGluIHJlc3VsdHNfd2lkZVxuICAgICAgICBjb25zdCBmYWxsYmFjayA9IGF3YWl0IGZhbGxiYWNrUGF0aWVudEZyb21SZXN1bHRzKHBhdGllbnRfaWQpO1xuICAgICAgICBpZiAoIWZhbGxiYWNrKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtZWRzQ3VycmVudCA9IGRhdGEubWVkaWNhdGlvbnNfY3VycmVudCA/PyBcIlwiO1xuXG4gICAgICBjb25zdCB2aXRhbHMgPSBhd2FpdCBmZXRjaFZpdGFsc1NuYXBzaG90cyhwYXRpZW50X2lkKS5jYXRjaChcbiAgICAgICAgKCk6IFZpdGFsc0J1bmRsZSA9PiAoeyBsYXRlc3Q6IG51bGwsIGhpc3Rvcnk6IFtdIH0pXG4gICAgICApO1xuXG4gICAgICBjb25zdCBwOiBQYXRpZW50ID0ge1xuICAgICAgICBwYXRpZW50X2lkOiBkYXRhLnBhdGllbnRfaWQsXG4gICAgICAgIGZ1bGxfbmFtZTogIGRhdGEuZnVsbF9uYW1lID8/IFwiXCIsXG4gICAgICAgIHNleDogICAgICAgIGRhdGEuc2V4ID8/IFwiXCIsXG4gICAgICAgIGFnZTogICAgICAgIGRhdGEuYWdlID8/IFwiXCIsXG4gICAgICAgIGJpcnRoZGF5OiAgIGRhdGEuYmlydGhkYXkgPz8gXCJcIixcbiAgICAgICAgY29udGFjdDogICAgZGF0YS5jb250YWN0ID8/IFwiXCIsXG4gICAgICAgIGFkZHJlc3M6ICAgIGRhdGEuYWRkcmVzcyA/PyBcIlwiLFxuICAgICAgICBlbWFpbDogICAgICBkYXRhLmVtYWlsID8/IFwiXCIsXG4gICAgICAgIGhlaWdodF9mdDogIGRhdGEuaGVpZ2h0X2Z0ID8/IFwiXCIsXG4gICAgICAgIGhlaWdodF9pbmNoOmRhdGEuaGVpZ2h0X2luY2ggPz8gXCJcIixcbiAgICAgICAgd2VpZ2h0X2tnOiAgZGF0YS53ZWlnaHRfa2cgPz8gXCJcIixcbiAgICAgICAgc3lzdG9saWNfYnA6ZGF0YS5zeXN0b2xpY19icCA/PyBcIlwiLFxuICAgICAgICBkaWFzdG9saWNfYnA6ZGF0YS5kaWFzdG9saWNfYnAgPz8gXCJcIixcbiAgICAgICAgbGFzdF91cGRhdGVkOiBkYXRhLmxhc3RfdXBkYXRlZCA/PyBcIlwiLFxuICAgICAgICBwcmVzZW50X2lsbG5lc3NfaGlzdG9yeTogZGF0YS5wcmVzZW50X2lsbG5lc3NfaGlzdG9yeSA/PyBcIlwiLFxuICAgICAgICBwYXN0X21lZGljYWxfaGlzdG9yeTogICAgZGF0YS5wYXN0X21lZGljYWxfaGlzdG9yeSA/PyBcIlwiLFxuICAgICAgICBwYXN0X3N1cmdpY2FsX2hpc3Rvcnk6ICAgZGF0YS5wYXN0X3N1cmdpY2FsX2hpc3RvcnkgPz8gXCJcIixcbiAgICAgICAgY2hpZWZfY29tcGxhaW50OiAgICAgICAgIGRhdGEuY2hpZWZfY29tcGxhaW50ID8/IFwiXCIsXG4gICAgICAgIGFsbGVyZ2llc190ZXh0OiAgICAgICAgICBkYXRhLmFsbGVyZ2llc190ZXh0ID8/IFwiXCIsXG4gICAgICAgIG1lZGljYXRpb25zX2N1cnJlbnQ6ICAgICBtZWRzQ3VycmVudCxcbiAgICAgICAgbWVkaWNhdGlvbnM6ICAgICAgICAgICAgIG1lZHNDdXJyZW50LCAgICAgICAgICAgLy8gbWlycm9yIGZvciBVSSBjb21wYXRpYmlsaXR5XG4gICAgICAgIGZhbWlseV9oaXN0b3J5OiAgICAgICAgICBkYXRhLmZhbWlseV9oeCA/PyBcIlwiLCAgLy8gc291cmNlIGlzIGZhbWlseV9oeFxuICAgICAgICBzbW9raW5nX2h4OiAgICAgICAgICAgICAgZGF0YS5zbW9raW5nX2h4ID8/IFwiXCIsXG4gICAgICAgIGFsY29ob2xfaHg6ICAgICAgICAgICAgICBkYXRhLmFsY29ob2xfaHggPz8gXCJcIixcbiAgICAgICAgdml0YWxzLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICBhc3luYyBnZXRWaXNpdHMocGF0aWVudF9pZDogc3RyaW5nKTogUHJvbWlzZTxWaXNpdFtdPiB7XG4gICAgICBjb25zdCB2aXNpdFJvd3MgPSBhd2FpdCBsaXN0VmlzaXRSb3dzKHBhdGllbnRfaWQpO1xuXG4gICAgICBjb25zdCBzZWVuID0gbmV3IE1hcDxzdHJpbmcsIFZpc2l0PigpO1xuICAgICAgZm9yIChjb25zdCByIG9mIHZpc2l0Um93cykge1xuICAgICAgICBjb25zdCByYXdEYXRlID0gKHIgYXMgYW55KS5kYXRlX29mX3Rlc3QgPz8gKHIgYXMgYW55KS5kYXRlID8/IChyIGFzIGFueSkudGVzdF9kYXRlID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBTdHJpbmcocmF3RGF0ZSkudHJpbSgpO1xuICAgICAgICBpZiAoIWRhdGUgfHwgaXNQbGFjZWhvbGRlcihkYXRlKSkgY29udGludWU7XG4gICAgICAgIGlmICghc2Vlbi5oYXMoZGF0ZSkpIHtcbiAgICAgICAgICBzZWVuLnNldChkYXRlLCB7XG4gICAgICAgICAgICBkYXRlX29mX3Rlc3Q6IGRhdGUsXG4gICAgICAgICAgICBiYXJjb2RlOiByLmJhcmNvZGUgPz8gXCJcIixcbiAgICAgICAgICAgIGJyYW5jaDogIHIuYnJhbmNoID8/IFwiXCIsXG4gICAgICAgICAgICBub3RlczogICByLm5vdGVzID8/IFwiXCIsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHNlZW4udmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IHRzKGIuZGF0ZV9vZl90ZXN0KSAtIHRzKGEuZGF0ZV9vZl90ZXN0KSk7XG4gICAgfSxcblxuICAgIGFzeW5jIGdldFJlcG9ydCh7IHBhdGllbnRfaWQsIHZpc2l0RGF0ZSB9OiB7IHBhdGllbnRfaWQ6IHN0cmluZzsgdmlzaXREYXRlPzogc3RyaW5nOyB9KTogUHJvbWlzZTxSZXBvcnQgfCBudWxsPiB7XG4gICAgICBjb25zdCBwYXRpZW50ID1cbiAgICAgICAgKGF3YWl0IHRoaXMuZ2V0UGF0aWVudChwYXRpZW50X2lkKSkgfHxcbiAgICAgICAgKHtcbiAgICAgICAgICBwYXRpZW50X2lkLFxuICAgICAgICAgIGZ1bGxfbmFtZTogXCJcIixcbiAgICAgICAgICB2aXRhbHM6IHsgbGF0ZXN0OiBudWxsLCBoaXN0b3J5OiBbXSB9LFxuICAgICAgICB9IGFzIFBhdGllbnQpO1xuXG4gICAgICBsZXQgZGF0ZSA9IHZpc2l0RGF0ZTtcbiAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICBjb25zdCB2aXNpdHMgPSBhd2FpdCB0aGlzLmdldFZpc2l0cyhwYXRpZW50X2lkKTtcbiAgICAgICAgZGF0ZSA9IHZpc2l0c1swXT8uZGF0ZV9vZl90ZXN0O1xuICAgICAgICBpZiAoIWRhdGUpIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByb3dzID0gYXdhaXQgZmV0Y2hSZXN1bHRSb3dzKHBhdGllbnRfaWQsIGRhdGUpO1xuICAgICAgaWYgKHJvd3MubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgY29uc3QgeyBtYXA6IHJhbmdlc01hcCwgcm93czogcmFuZ2VzUm93cyB9ID0gYXdhaXQgZ2V0UmFuZ2VzTWFwKCk7XG4gICAgICBjb25zdCBieVNlY3Rpb24gPSBuZXcgTWFwPHN0cmluZywgUmVwb3J0SXRlbVtdPigpO1xuXG4gICAgICBmb3IgKGNvbnN0IHIgb2Ygcm93cykge1xuICAgICAgICBjb25zdCBrZXkgPSBTdHJpbmcoXG4gICAgICAgICAgci5pdGVtX2tleSA/P1xuICAgICAgICAgIHIuYW5hbHl0ZV9rZXkgPz9cbiAgICAgICAgICByLnBhcmFtZXRlcl9rZXkgPz9cbiAgICAgICAgICByLnBhcmFtX2tleSA/P1xuICAgICAgICAgIHIua2V5ID8/XG4gICAgICAgICAgXCJcIlxuICAgICAgICApLnRyaW0oKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IGtleSA/IHJhbmdlc01hcC5nZXQoa2V5KSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjb25zdCBsYWJlbCA9IFN0cmluZyhcbiAgICAgICAgICBwaWNrKFxuICAgICAgICAgICAgci5pdGVtX2xhYmVsLFxuICAgICAgICAgICAgci5kaXNwbGF5X25hbWUsXG4gICAgICAgICAgICByLnBhcmFtZXRlcl9sYWJlbCxcbiAgICAgICAgICAgIHIubGFiZWwsXG4gICAgICAgICAgICBtZXRhPy5sYWJlbCxcbiAgICAgICAgICAgIGtleSB8fCBudWxsXG4gICAgICAgICAgKSA/PyBcIlwiXG4gICAgICAgICkudHJpbSgpO1xuXG4gICAgICAgIC8vIHVuaXQ6IG5ldmVyIGFsbG93IFwibnVsbFwiIHN0cmluZ1xuICAgICAgICBjb25zdCB1bml0UmF3ID0gcGljayhyLnVuaXQsIHIudW5pdHMsIHIudW9tLCBtZXRhPy51bml0KTtcbiAgICAgICAgY29uc3QgdW5pdCA9IHVuaXRSYXcgPT0gbnVsbCA/IFwiXCIgOiBTdHJpbmcodW5pdFJhdyk7XG5cbiAgICAgICAgLy8gc2VjdGlvbiBmcm9tIHJhbmdlcyBvciBwcmVmaXhcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IFN0cmluZyhcbiAgICAgICAgICBwaWNrKHIuc2VjdGlvbiwgci5pdGVtX3NlY3Rpb24sIHIuZGVwdCwgci5jYXRlZ29yeSwgbWV0YT8uc2VjdGlvbiwgcHJlZml4VG9TZWN0aW9uKGtleSB8fCBsYWJlbCksIFwiT3RoZXJzXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdmFsdWU6IHRyZWF0IFwiLVwiIGV0YyBhcyBudWxsOyBrZWVwIG51bWVyaWMgaWYgcG9zc2libGUgZm9yIGZsYWdzXG4gICAgICAgIGNvbnN0IHJhd1ZhbCA9IHBpY2soci52YWx1ZSwgci5yZXN1bHQsIHIudmFsKTtcbiAgICAgICAgY29uc3QgdmFsdWVOdW0gPSB0b051bShyYXdWYWwpO1xuICAgICAgICBjb25zdCB2YWx1ZTogbnVtYmVyIHwgc3RyaW5nIHwgbnVsbCA9XG4gICAgICAgICAgdmFsdWVOdW0gIT09IG51bGwgPyB2YWx1ZU51bSA6IChpc1BsYWNlaG9sZGVyKHJhd1ZhbCkgPyBudWxsIDogKHJhd1ZhbCBhcyBhbnkpKTtcblxuICAgICAgICAvLyByZWZlcmVuY2VzIChkaXNwbGF5IHJhdywgY29tcHV0ZSBmbGFncyB2aWEgbnVtZXJpYylcbiAgICAgICAgY29uc3QgcmF3TG93ICA9IHBpY2soci5yZWZfbG93LCAgci5sb3csICBtZXRhPy5sb3cpO1xuICAgICAgICBjb25zdCByYXdIaWdoID0gcGljayhyLnJlZl9oaWdoLCByLmhpZ2gsIG1ldGE/LmhpZ2gpO1xuICAgICAgICBjb25zdCByZWZfbG93X2Rpc3BsYXkgID0gaXNQbGFjZWhvbGRlcihyYXdMb3cpICA/IG51bGwgOiAocmF3TG93ICBhcyBhbnkpO1xuICAgICAgICBjb25zdCByZWZfaGlnaF9kaXNwbGF5ID0gaXNQbGFjZWhvbGRlcihyYXdIaWdoKSA/IG51bGwgOiAocmF3SGlnaCBhcyBhbnkpO1xuICAgICAgICBjb25zdCByZWZMb3dOdW0gID0gdG9OdW0ocmF3TG93KTtcbiAgICAgICAgY29uc3QgcmVmSGlnaE51bSA9IHRvTnVtKHJhd0hpZ2gpO1xuXG4gICAgICAgIC8vIGZsYWc6IHByZWZlciBEQjsgZWxzZSBjb21wdXRlIEwvSCBvbmx5IChkbyBOT1Qgc2hvdyBcIk5cIilcbiAgICAgICAgbGV0IGZsYWc6IFwiTFwiIHwgXCJIXCIgfCBcIkFcIiB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCByYXdGbGFnID0gKHBpY2soci5mbGFnKSBhcyBhbnkpID8/IG51bGw7XG4gICAgICAgIGlmIChyYXdGbGFnKSB7XG4gICAgICAgICAgY29uc3QgZiA9IFN0cmluZyhyYXdGbGFnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGlmIChmID09PSBcIkxcIiB8fCBmID09PSBcIkhcIiB8fCBmID09PSBcIkFcIikgZmxhZyA9IGYgYXMgYW55O1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlTnVtICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJlZkxvd051bSAhPT0gbnVsbCAmJiB2YWx1ZU51bSA8IHJlZkxvd051bSkgZmxhZyA9IFwiTFwiO1xuICAgICAgICAgIGVsc2UgaWYgKHJlZkhpZ2hOdW0gIT09IG51bGwgJiYgdmFsdWVOdW0gPiByZWZIaWdoTnVtKSBmbGFnID0gXCJIXCI7XG4gICAgICAgICAgLy8gZWxzZSBub3JtYWwg4oaSIGxlYXZlIG51bGwgKHlvdSBkb24ndCB3YW50IFwiTlwiKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXRlbTogUmVwb3J0SXRlbSA9IHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgdW5pdCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICByZWZfbG93OiAgcmVmX2xvd19kaXNwbGF5LFxuICAgICAgICAgIHJlZl9oaWdoOiByZWZfaGlnaF9kaXNwbGF5LFxuICAgICAgICAgIGZsYWcsXG4gICAgICAgICAgbWV0aG9kOiAgci5tZXRob2QgPz8gbnVsbCxcbiAgICAgICAgICByZW1hcmtzOiByLnJlbWFya3MgPz8gbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBza2lwIHBsYWNlaG9sZGVycy9ibGFuayB2YWx1ZXMgZW50aXJlbHkgKGRvbid0IHJlbmRlcilcbiAgICAgICAgaWYgKGl0ZW0udmFsdWUgPT09IG51bGwgfHwgKHR5cGVvZiBpdGVtLnZhbHVlID09PSBcInN0cmluZ1wiICYmIGlzUGxhY2Vob2xkZXIoaXRlbS52YWx1ZSkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcnIgPSBieVNlY3Rpb24uZ2V0KHNlY3Rpb24pID8/IFtdO1xuICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgYnlTZWN0aW9uLnNldChzZWN0aW9uLCBhcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBzb3J0IGl0ZW1zIGluIGVhY2ggc2VjdGlvblxuICAgICAgbGV0IHNlY3Rpb25zOiBSZXBvcnRTZWN0aW9uW10gPVxuICAgICAgICBBcnJheS5mcm9tKGJ5U2VjdGlvbi5lbnRyaWVzKCkpXG4gICAgICAgICAgLm1hcCgoW25hbWUsIGl0ZW1zXSkgPT4gKHsgbmFtZSwgaXRlbXMgfSkpXG4gICAgICAgICAgLmZpbHRlcihzZWMgPT4gc2VjLml0ZW1zLnNvbWUoaSA9PiBpLnZhbHVlICE9PSBudWxsICYmIFN0cmluZyhpLnZhbHVlKS50cmltKCkgIT09IFwiXCIpKTtcbiAgICAgIHNlY3Rpb25zID0gc29ydEl0ZW1zSW5TZWN0aW9ucyhzZWN0aW9ucywgcmFuZ2VzUm93cyk7XG5cbiAgICAgIGNvbnN0IGZpcnN0ID0gcm93c1swXSB8fCB7fTtcbiAgICAgIGNvbnN0IHZpc2l0OiBWaXNpdCA9IHtcbiAgICAgICAgZGF0ZV9vZl90ZXN0OiBkYXRlLFxuICAgICAgICBiYXJjb2RlOiBmaXJzdC5iYXJjb2RlID8/IFwiXCIsXG4gICAgICAgIGJyYW5jaDogIGZpcnN0LmJyYW5jaCA/PyBcIlwiLFxuICAgICAgICBub3RlczogICBmaXJzdC5ub3RlcyA/PyBcIlwiLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHsgcGF0aWVudCwgdmlzaXQsIHNlY3Rpb25zIH07XG4gICAgfSxcblxuICAgIGFzeW5jIHNlYXJjaFBhdGllbnRzKHsgcXVlcnksIGxpbWl0ID0gMjAsIG9mZnNldCA9IDAgfSkge1xuICAgICAgY29uc3QgcSA9IChxdWVyeSB8fCBcIlwiKS50cmltKCk7XG4gICAgICBpZiAoIXEpIHJldHVybiB7IHJlc3VsdHM6IFtdLCB0b3RhbDogMCB9O1xuXG4gICAgICBjb25zdCBwYXQgPSBgJSR7cS5yZXBsYWNlKC9bJV9dL2csIChtKSA9PiBgXFxcXCR7bX1gKX0lYDtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IsIGNvdW50IH0gPSBhd2FpdCBkYlxuICAgICAgICAuZnJvbShUQUJMRV9QQVRJRU5UUylcbiAgICAgICAgLnNlbGVjdChcInBhdGllbnRfaWQsIGZ1bGxfbmFtZSwgc2V4LCBhZ2UsIGJpcnRoZGF5LCBjb250YWN0LCBhZGRyZXNzLCBlbWFpbFwiLCB7IGNvdW50OiBcImV4YWN0XCIgfSlcbiAgICAgICAgLm9yKGBwYXRpZW50X2lkLmlsaWtlLiR7cGF0fSxmdWxsX25hbWUuaWxpa2UuJHtwYXR9YClcbiAgICAgICAgLm9yZGVyKFwiZnVsbF9uYW1lXCIsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG4gICAgICAgIC5yYW5nZShvZmZzZXQsIG9mZnNldCArIGxpbWl0IC0gMSk7XG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgICByZXR1cm4geyByZXN1bHRzOiAoZGF0YSB8fCBbXSkgYXMgUGF0aWVudFtdLCB0b3RhbDogY291bnQgPz8gdW5kZWZpbmVkIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGdldENvbmZpZygpIHtcbiAgICAgIHJldHVybiB7IGZvb3Rlcl9saW5lczogW10sIHNpZ25hdG9yaWVzOiBbXSB9O1xuICAgIH0sXG4gIH07XG59XG4iXSwibmFtZXMiOlsiZ2V0U3VwYWJhc2UiLCJpc1BsYWNlaG9sZGVyIiwieCIsInVuZGVmaW5lZCIsInMiLCJTdHJpbmciLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJ0cyIsImQiLCJ0IiwiRGF0ZSIsInBhcnNlIiwiTnVtYmVyIiwiaXNOYU4iLCJtIiwibWF0Y2giLCJhIiwicGFyc2VJbnQiLCJiIiwieSIsImxlbmd0aCIsImlzRE1ZIiwibW9udGgiLCJkYXkiLCJnZXRUaW1lIiwidG9OdW0iLCJyZXBsYWNlIiwibiIsImlzRmluaXRlIiwicGljayIsInZhbHMiLCJ2IiwiZXNjYXBlTGlrZUV4YWN0IiwicHJlZml4VG9TZWN0aW9uIiwia2V5IiwiayIsInN0YXJ0c1dpdGgiLCJERUZBVUxUX09SREVSIiwiSGVtYXRvbG9neSIsIlVyaW5hbHlzaXMiLCJGZWNhbHlzaXMiLCJTZXJvbG9neSIsIk90aGVycyIsImJ1aWxkT3JkZXJJbmRleCIsInJhbmdlc1Jvd3MiLCJieUtleU9yZGVyIiwiTWFwIiwiciIsImFuYWx5dGVfa2V5IiwicGFyYW1ldGVyX2tleSIsInBhcmFtX2tleSIsIm9yZGVyUmF3Iiwib3JkZXIiLCJzb3J0X29yZGVyIiwicmFuayIsInByaW8iLCJvcmRlck51bSIsInNldCIsInNvcnRJdGVtc0luU2VjdGlvbnMiLCJzZWN0aW9ucyIsIm9yZGVySW5kZXgiLCJtYXAiLCJzZWMiLCJkZWZhdWx0cyIsIm5hbWUiLCJkZWZhdWx0SW5kZXgiLCJmb3JFYWNoIiwiaSIsIml0ZW1zIiwic29ydCIsImFvIiwiZ2V0IiwiYm8iLCJhZCIsImJkIiwiYWwiLCJsYWJlbCIsImJsIiwibG9jYWxlQ29tcGFyZSIsImNyZWF0ZVN1cGFiYXNlUHJvdmlkZXIiLCJUQUJMRV9QQVRJRU5UUyIsIlRBQkxFX1JFU1VMVFMiLCJUQUJMRV9SQU5HRVMiLCJUQUJMRV9WSVRBTFMiLCJUQUJMRV9SRVNVTFRTX1dJREUiLCJkYiIsInJhbmdlc0NhY2hlIiwicmFuZ2VzUm93c0NhY2hlIiwiZ2V0UmFuZ2VzTWFwIiwicm93cyIsImRhdGEiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJzZWN0aW9uIiwiZ3JvdXAiLCJjYXRlZ29yeSIsIml0ZW1fbGFiZWwiLCJkaXNwbGF5X25hbWUiLCJ1bml0IiwidW5pdHMiLCJ1b20iLCJsb3ciLCJoaWdoIiwiZmV0Y2hWaXRhbHNTbmFwc2hvdHMiLCJwYXRpZW50X2lkIiwib3B0cyIsInBpZCIsInF1ZXJ5IiwiaWxpa2UiLCJhc2NlbmRpbmciLCJjb25zdWx0YXRpb25faWQiLCJlcSIsImVuY291bnRlcl9pZCIsImxpbWl0IiwiaWQiLCJtZWFzdXJlZF9hdCIsImNyZWF0ZWRfYXQiLCJ0b0lTT1N0cmluZyIsInN5c3RvbGljX2JwIiwiZGlhc3RvbGljX2JwIiwiaHIiLCJyciIsInRlbXBfYyIsImhlaWdodF9jbSIsIndlaWdodF9rZyIsImJtaSIsIm8yc2F0Iiwibm90ZXMiLCJzb3VyY2UiLCJjcmVhdGVkX2J5X2luaXRpYWxzIiwibGF0ZXN0IiwiaGlzdG9yeSIsImZhbGxiYWNrUGF0aWVudEZyb21SZXN1bHRzIiwibWF5YmVTaW5nbGUiLCJ2aXRhbHMiLCJjYXRjaCIsImZ1bGxfbmFtZSIsInNleCIsImFnZSIsImJpcnRoZGF5IiwiY29udGFjdCIsImFkZHJlc3MiLCJlbWFpbCIsImhlaWdodF9mdCIsImhlaWdodF9pbmNoIiwibWVkaWNhdGlvbnNfY3VycmVudCIsIm1lZGljYXRpb25zIiwiZmFtaWx5X2hpc3RvcnkiLCJzbW9raW5nX2h4IiwiYWxjb2hvbF9oeCIsImxhc3RfdXBkYXRlZCIsImxpc3RWaXNpdFJvd3MiLCJkYXRlX29mX3Rlc3QiLCJiYXJjb2RlIiwiYnJhbmNoIiwid2lkZSIsIndpZGVFcnJvciIsImZldGNoUmVzdWx0Um93cyIsInZpc2l0RGF0ZSIsIndpZGVRdWVyeSIsInNraXBLZXlzIiwiU2V0IiwiZmxhdCIsInJvdyIsImJhc2UiLCJ2YWwiLCJPYmplY3QiLCJlbnRyaWVzIiwiaGFzIiwicHVzaCIsIml0ZW1fa2V5IiwidmFsdWUiLCJnZXRQYXRpZW50IiwiZmFsbGJhY2siLCJtZWRzQ3VycmVudCIsInAiLCJwcmVzZW50X2lsbG5lc3NfaGlzdG9yeSIsInBhc3RfbWVkaWNhbF9oaXN0b3J5IiwicGFzdF9zdXJnaWNhbF9oaXN0b3J5IiwiY2hpZWZfY29tcGxhaW50IiwiYWxsZXJnaWVzX3RleHQiLCJmYW1pbHlfaHgiLCJnZXRWaXNpdHMiLCJ2aXNpdFJvd3MiLCJzZWVuIiwicmF3RGF0ZSIsImRhdGUiLCJ0ZXN0X2RhdGUiLCJBcnJheSIsInZhbHVlcyIsImdldFJlcG9ydCIsInBhdGllbnQiLCJ2aXNpdHMiLCJyYW5nZXNNYXAiLCJieVNlY3Rpb24iLCJtZXRhIiwicGFyYW1ldGVyX2xhYmVsIiwidW5pdFJhdyIsIml0ZW1fc2VjdGlvbiIsImRlcHQiLCJyYXdWYWwiLCJyZXN1bHQiLCJ2YWx1ZU51bSIsInJhd0xvdyIsInJlZl9sb3ciLCJyYXdIaWdoIiwicmVmX2hpZ2giLCJyZWZfbG93X2Rpc3BsYXkiLCJyZWZfaGlnaF9kaXNwbGF5IiwicmVmTG93TnVtIiwicmVmSGlnaE51bSIsImZsYWciLCJyYXdGbGFnIiwiZiIsInRvVXBwZXJDYXNlIiwiaXRlbSIsIm1ldGhvZCIsInJlbWFya3MiLCJhcnIiLCJmaWx0ZXIiLCJzb21lIiwiZmlyc3QiLCJ2aXNpdCIsInNlYXJjaFBhdGllbnRzIiwib2Zmc2V0IiwicSIsInJlc3VsdHMiLCJ0b3RhbCIsInBhdCIsImNvdW50Iiwib3IiLCJyYW5nZSIsImdldENvbmZpZyIsImZvb3Rlcl9saW5lcyIsInNpZ25hdG9yaWVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/data/supabase-provider.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSupabase: () => (/* binding */ getSupabase),\n/* harmony export */   getSupabaseBrowser: () => (/* binding */ getSupabaseBrowser),\n/* harmony export */   sbListVitalsByPatient: () => (/* binding */ sbListVitalsByPatient),\n/* harmony export */   sbReadConfig: () => (/* binding */ sbReadConfig),\n/* harmony export */   sbReadLatestVitalsByPatient: () => (/* binding */ sbReadLatestVitalsByPatient),\n/* harmony export */   sbReadPatientById: () => (/* binding */ sbReadPatientById),\n/* harmony export */   sbReadRanges: () => (/* binding */ sbReadRanges),\n/* harmony export */   sbReadResultsByPatient: () => (/* binding */ sbReadResultsByPatient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/../../node_modules/.pnpm/@supabase+supabase-js@2.74.0/node_modules/@supabase/supabase-js/dist/module/index.js\");\n// lib/supabase.ts\n\nconst SUPABASE_URL = process.env.SUPABASE_URL;\nconst SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;\nif (!SUPABASE_URL) throw new Error(\"SUPABASE_URL is required\");\nif (!SUPABASE_SERVICE_ROLE_KEY) throw new Error(\"SUPABASE_SERVICE_ROLE_KEY is required\");\nfunction getSupabase() {\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {\n        auth: {\n            autoRefreshToken: false,\n            persistSession: false\n        }\n    });\n}\nconst SUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpndXdpdmNkZGVqam9wd3hubW55Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg1MDMwMzksImV4cCI6MjA3NDA3OTAzOX0.iHai-vNwyTK3j8yLdbqZrU_BlvLOysevGVn229k_XGg\"; // public-safe\nfunction getSupabaseBrowser() {\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(SUPABASE_URL, SUPABASE_ANON_KEY, {\n        auth: {\n            autoRefreshToken: true,\n            persistSession: true\n        }\n    });\n}\n// ---------- helpers ----------\nfunction snake(row) {\n    const out = {};\n    for (const [k, v] of Object.entries(row)){\n        const nk = String(k).trim().toLowerCase().replace(/[^\\w]+/g, \"_\").replace(/_+/g, \"_\").replace(/^_+|_+$/g, \"\");\n        out[nk] = v;\n    }\n    return out;\n}\n// Escape % and _ so they DON'T act as wildcards in ILIKE\nfunction escapeLikeExact(s) {\n    return s.replace(/[%_]/g, (m)=>`\\\\${m}`);\n}\n// ---------- readers ----------\n/** Config as a simple key→value map */ async function sbReadConfig() {\n    const supabase = getSupabase();\n    const { data, error } = await supabase.from(\"config\").select(\"key,value\");\n    if (error) throw error;\n    const out = {};\n    for (const r of data || []){\n        const k = String(r.key ?? \"\").trim();\n        if (k) out[k] = String(r.value ?? \"\");\n    }\n    return out;\n}\n/** Ranges shaped like the old sheet */ async function sbReadRanges() {\n    const supabase = getSupabase();\n    const { data, error } = await supabase.from(\"ranges\").select(\"*\");\n    if (error) throw error;\n    return (data || []).map(snake);\n}\n/** Prefer results_wide (1 row per visit) */ async function sbReadResultsWideByPatient(patientId) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    const { data, error } = await supabase.from(\"results_wide\").select(\"*\").ilike(\"patient_id\", pid) // exact case-insensitive match (no wildcards)\n    .order(\"date_of_test\", {\n        ascending: true\n    });\n    if (error) throw error;\n    return (data || []).map(snake);\n}\n/** Fallback: read results_flat and pivot flat→wide per visit */ async function sbReadResultsFlatByPatient(patientId) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    const { data, error } = await supabase.from(\"results_flat\").select(\"*\").ilike(\"patient_id\", pid).order(\"date_of_test\", {\n        ascending: true\n    }).order(\"id\", {\n        ascending: true\n    });\n    if (error) throw error;\n    const flat = (data || []).map(snake);\n    if (!flat.length) return [];\n    // discover likely key/value columns\n    const keyField = [\n        \"analyte_key\",\n        \"key\",\n        \"parameter_key\",\n        \"param_key\",\n        \"analyte\",\n        \"parameter\"\n    ].find((k)=>k in flat[0]) || \"analyte_key\";\n    const valField = [\n        \"value\",\n        \"result\",\n        \"val\",\n        \"res\"\n    ].find((k)=>k in flat[0]) || \"value\";\n    const groups = new Map();\n    for (const r of flat){\n        const gk = [\n            r.patient_id ?? \"\",\n            r.date_of_test ?? \"\",\n            r.barcode ?? \"\",\n            r.notes ?? \"\"\n        ].join(\"|\");\n        let obj = groups.get(gk);\n        if (!obj) {\n            obj = {\n                patient_id: r.patient_id ?? \"\",\n                date_of_test: r.date_of_test ?? \"\",\n                barcode: r.barcode ?? \"\",\n                notes: r.notes ?? \"\"\n            };\n            groups.set(gk, obj);\n        }\n        const key = String(r[keyField] ?? \"\").trim();\n        if (key) obj[key] = r[valField] ?? \"\";\n    }\n    return Array.from(groups.values()).map(snake);\n}\n/** Public: read results as \"wide\" rows, using wide first then flat→wide */ async function sbReadResultsByPatient(patientId) {\n    const wide = await sbReadResultsWideByPatient(patientId);\n    if (wide.length) return wide;\n    return await sbReadResultsFlatByPatient(patientId);\n}\n/** Patient summary (Patients table) */ async function sbReadPatientById(patientId) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    const { data, error } = await supabase.from(\"patients\").select(\"*\").ilike(\"patient_id\", pid).limit(1).maybeSingle();\n    if (error) throw error;\n    return data ? snake(data) : null;\n}\nasync function sbListVitalsByPatient(patientId, opts) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    let query = supabase.from(\"vitals_snapshots\").select(\"*\").ilike(\"patient_id\", pid).order(\"measured_at\", {\n        ascending: false\n    });\n    if (opts?.consultationId) query = query.eq(\"consultation_id\", opts.consultationId);\n    if (opts?.encounterId) query = query.eq(\"encounter_id\", opts.encounterId);\n    query = query.limit(opts?.limit ?? 8);\n    const { data, error } = await query;\n    if (error) throw error;\n    return (data || []).map((r)=>snake(r));\n}\nasync function sbReadLatestVitalsByPatient(patientId, opts) {\n    const rows = await sbListVitalsByPatient(patientId, {\n        ...opts,\n        limit: 1\n    });\n    return rows[0] ?? null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVExQyxTQUNURyxJQUFJLENBQUMsb0JBQ0xDLE1BQU0sQ0FBQyxLQUNQUyxLQUFLLENBQUMsY0FBY0QsS0FDcEJFLEtBQUssQ0FBQyxlQUFlO1FBQUVDLFdBQVc7SUFBTTtJQUUzQyxJQUFJMEIsTUFBTUUsZ0JBQWdCRCxRQUFRQSxNQUFNRSxFQUFFLENBQUMsbUJBQW1CSCxLQUFLRSxjQUFjO0lBQ2pGLElBQUlGLE1BQU1JLGFBQWFILFFBQVFBLE1BQU1FLEVBQUUsQ0FBQyxnQkFBZ0JILEtBQUtJLFdBQVc7SUFDeEVILFFBQVFBLE1BQU1KLEtBQUssQ0FBQ0csTUFBTUgsU0FBUztJQUVuQyxNQUFNLEVBQUVyQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU13QztJQUM5QixJQUFJeEMsT0FBTyxNQUFNQTtJQUNqQixPQUFPLENBQUNELFFBQVEsRUFBRSxFQUFFUSxHQUFHLENBQUMsQ0FBQ0osSUFBTXJCLE1BQU1xQjtBQUN2QztBQUVPLGVBQWV5Qyw0QkFDcEJuQyxTQUFpQixFQUNqQjhCLElBQXdEO0lBRXhELE1BQU1NLE9BQU8sTUFBTVAsc0JBQXNCN0IsV0FBVztRQUFFLEdBQUc4QixJQUFJO1FBQUVILE9BQU87SUFBRTtJQUN4RSxPQUFPUyxJQUFJLENBQUMsRUFBRSxJQUFJO0FBQ3BCIiwic291cmNlcyI6WyIvVXNlcnMvcG9jaG9sby9Qcm9qZWN0cy93ZWxsc2Vydi1wb3J0YWwvYXBwcy93ZWIvbGliL3N1cGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9zdXBhYmFzZS50c1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50LCBTdXBhYmFzZUNsaWVudCB9IGZyb20gXCJAc3VwYWJhc2Uvc3VwYWJhc2UtanNcIjtcblxuY29uc3QgU1VQQUJBU0VfVVJMID0gcHJvY2Vzcy5lbnYuU1VQQUJBU0VfVVJMO1xuY29uc3QgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSA9IHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVk7XG5cbmlmICghU1VQQUJBU0VfVVJMKSB0aHJvdyBuZXcgRXJyb3IoXCJTVVBBQkFTRV9VUkwgaXMgcmVxdWlyZWRcIik7XG5pZiAoIVNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkpIHRocm93IG5ldyBFcnJvcihcIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkgaXMgcmVxdWlyZWRcIik7XG5cbmV4cG9ydCB0eXBlIFJvdyA9IFJlY29yZDxzdHJpbmcsIGFueT47XG5leHBvcnQgdHlwZSBWaXRhbHNTbmFwc2hvdFJvdyA9IFJvdyAmIHtcbiAgaWQ6IHN0cmluZztcbiAgcGF0aWVudF9pZDogc3RyaW5nO1xuICBjb25zdWx0YXRpb25faWQ6IHN0cmluZztcbiAgZW5jb3VudGVyX2lkOiBzdHJpbmc7XG4gIG1lYXN1cmVkX2F0OiBzdHJpbmc7XG4gIHN5c3RvbGljX2JwPzogbnVtYmVyIHwgbnVsbDtcbiAgZGlhc3RvbGljX2JwPzogbnVtYmVyIHwgbnVsbDtcbiAgaHI/OiBudW1iZXIgfCBudWxsO1xuICBycj86IG51bWJlciB8IG51bGw7XG4gIHRlbXBfYz86IG51bWJlciB8IG51bGw7XG4gIGhlaWdodF9jbT86IG51bWJlciB8IG51bGw7XG4gIHdlaWdodF9rZz86IG51bWJlciB8IG51bGw7XG4gIGJtaT86IG51bWJlciB8IG51bGw7XG4gIG8yc2F0PzogbnVtYmVyIHwgbnVsbDtcbiAgbm90ZXM/OiBzdHJpbmcgfCBudWxsO1xuICBzb3VyY2U/OiBzdHJpbmcgfCBudWxsO1xuICBjcmVhdGVkX2J5X2luaXRpYWxzPzogc3RyaW5nIHwgbnVsbDtcbiAgY3JlYXRlZF9hdD86IHN0cmluZyB8IG51bGw7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VwYWJhc2UoKTogU3VwYWJhc2VDbGllbnQge1xuICByZXR1cm4gY3JlYXRlQ2xpZW50KFNVUEFCQVNFX1VSTCEsIFNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkhLCB7XG4gICAgYXV0aDogeyBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSwgcGVyc2lzdFNlc3Npb246IGZhbHNlIH0sXG4gIH0pO1xufVxuXG5jb25zdCBTVVBBQkFTRV9BTk9OX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZOyAvLyBwdWJsaWMtc2FmZVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VwYWJhc2VCcm93c2VyKCk6IFN1cGFiYXNlQ2xpZW50IHtcbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChTVVBBQkFTRV9VUkwhLCBTVVBBQkFTRV9BTk9OX0tFWSEsIHtcbiAgICBhdXRoOiB7IGF1dG9SZWZyZXNoVG9rZW46IHRydWUsIHBlcnNpc3RTZXNzaW9uOiB0cnVlIH0sXG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tIGhlbHBlcnMgLS0tLS0tLS0tLVxuZnVuY3Rpb24gc25ha2U8VCBleHRlbmRzIFJvdz4ocm93OiBUKTogVCB7XG4gIGNvbnN0IG91dDogUm93ID0ge307XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHJvdykpIHtcbiAgICBjb25zdCBuayA9IFN0cmluZyhrKVxuICAgICAgLnRyaW0oKVxuICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgIC5yZXBsYWNlKC9bXlxcd10rL2csIFwiX1wiKVxuICAgICAgLnJlcGxhY2UoL18rL2csIFwiX1wiKVxuICAgICAgLnJlcGxhY2UoL15fK3xfKyQvZywgXCJcIik7XG4gICAgb3V0W25rXSA9IHY7XG4gIH1cbiAgcmV0dXJuIG91dCBhcyBUO1xufVxuXG4vLyBFc2NhcGUgJSBhbmQgXyBzbyB0aGV5IERPTidUIGFjdCBhcyB3aWxkY2FyZHMgaW4gSUxJS0VcbmZ1bmN0aW9uIGVzY2FwZUxpa2VFeGFjdChzOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvWyVfXS9nLCAobSkgPT4gYFxcXFwke219YCk7XG59XG5cbi8vIC0tLS0tLS0tLS0gcmVhZGVycyAtLS0tLS0tLS0tXG4vKiogQ29uZmlnIGFzIGEgc2ltcGxlIGtleeKGknZhbHVlIG1hcCAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNiUmVhZENvbmZpZygpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZSgpO1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwiY29uZmlnXCIpLnNlbGVjdChcImtleSx2YWx1ZVwiKTtcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgY29uc3Qgb3V0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGZvciAoY29uc3QgciBvZiBkYXRhIHx8IFtdKSB7XG4gICAgY29uc3QgayA9IFN0cmluZyhyLmtleSA/PyBcIlwiKS50cmltKCk7XG4gICAgaWYgKGspIG91dFtrXSA9IFN0cmluZyhyLnZhbHVlID8/IFwiXCIpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKiBSYW5nZXMgc2hhcGVkIGxpa2UgdGhlIG9sZCBzaGVldCAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNiUmVhZFJhbmdlcygpOiBQcm9taXNlPFJvd1tdPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0U3VwYWJhc2UoKTtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInJhbmdlc1wiKS5zZWxlY3QoXCIqXCIpO1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICByZXR1cm4gKGRhdGEgfHwgW10pLm1hcChzbmFrZSk7XG59XG5cbi8qKiBQcmVmZXIgcmVzdWx0c193aWRlICgxIHJvdyBwZXIgdmlzaXQpICovXG5hc3luYyBmdW5jdGlvbiBzYlJlYWRSZXN1bHRzV2lkZUJ5UGF0aWVudChwYXRpZW50SWQ6IHN0cmluZyk6IFByb21pc2U8Um93W10+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZSgpO1xuICBjb25zdCBwaWQgPSBlc2NhcGVMaWtlRXhhY3QoU3RyaW5nKHBhdGllbnRJZCB8fCBcIlwiKS50cmltKCkpO1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwicmVzdWx0c193aWRlXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZCkgLy8gZXhhY3QgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCAobm8gd2lsZGNhcmRzKVxuICAgIC5vcmRlcihcImRhdGVfb2ZfdGVzdFwiLCB7IGFzY2VuZGluZzogdHJ1ZSB9KTtcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgcmV0dXJuIChkYXRhIHx8IFtdKS5tYXAoc25ha2UpO1xufVxuXG4vKiogRmFsbGJhY2s6IHJlYWQgcmVzdWx0c19mbGF0IGFuZCBwaXZvdCBmbGF04oaSd2lkZSBwZXIgdmlzaXQgKi9cbmFzeW5jIGZ1bmN0aW9uIHNiUmVhZFJlc3VsdHNGbGF0QnlQYXRpZW50KHBhdGllbnRJZDogc3RyaW5nKTogUHJvbWlzZTxSb3dbXT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGdldFN1cGFiYXNlKCk7XG4gIGNvbnN0IHBpZCA9IGVzY2FwZUxpa2VFeGFjdChTdHJpbmcocGF0aWVudElkIHx8IFwiXCIpLnRyaW0oKSk7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJyZXN1bHRzX2ZsYXRcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKVxuICAgIC5vcmRlcihcImRhdGVfb2ZfdGVzdFwiLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgIC5vcmRlcihcImlkXCIsIHsgYXNjZW5kaW5nOiB0cnVlIH0pO1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXG4gIGNvbnN0IGZsYXQgPSAoZGF0YSB8fCBbXSkubWFwKHNuYWtlKTtcbiAgaWYgKCFmbGF0Lmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gIC8vIGRpc2NvdmVyIGxpa2VseSBrZXkvdmFsdWUgY29sdW1uc1xuICBjb25zdCBrZXlGaWVsZCA9XG4gICAgW1wiYW5hbHl0ZV9rZXlcIiwgXCJrZXlcIiwgXCJwYXJhbWV0ZXJfa2V5XCIsIFwicGFyYW1fa2V5XCIsIFwiYW5hbHl0ZVwiLCBcInBhcmFtZXRlclwiXS5maW5kKFxuICAgICAgKGspID0+IGsgaW4gZmxhdFswXVxuICAgICkgfHwgXCJhbmFseXRlX2tleVwiO1xuICBjb25zdCB2YWxGaWVsZCA9XG4gICAgW1widmFsdWVcIiwgXCJyZXN1bHRcIiwgXCJ2YWxcIiwgXCJyZXNcIl0uZmluZCgoaykgPT4gayBpbiBmbGF0WzBdKSB8fCBcInZhbHVlXCI7XG5cbiAgY29uc3QgZ3JvdXBzID0gbmV3IE1hcDxzdHJpbmcsIFJvdz4oKTtcbiAgZm9yIChjb25zdCByIG9mIGZsYXQpIHtcbiAgICBjb25zdCBnayA9IFtyLnBhdGllbnRfaWQgPz8gXCJcIiwgci5kYXRlX29mX3Rlc3QgPz8gXCJcIiwgci5iYXJjb2RlID8/IFwiXCIsIHIubm90ZXMgPz8gXCJcIl0uam9pbihcInxcIik7XG4gICAgbGV0IG9iaiA9IGdyb3Vwcy5nZXQoZ2spO1xuICAgIGlmICghb2JqKSB7XG4gICAgICBvYmogPSB7XG4gICAgICAgIHBhdGllbnRfaWQ6IHIucGF0aWVudF9pZCA/PyBcIlwiLFxuICAgICAgICBkYXRlX29mX3Rlc3Q6IHIuZGF0ZV9vZl90ZXN0ID8/IFwiXCIsXG4gICAgICAgIGJhcmNvZGU6IHIuYmFyY29kZSA/PyBcIlwiLFxuICAgICAgICBub3Rlczogci5ub3RlcyA/PyBcIlwiLFxuICAgICAgfTtcbiAgICAgIGdyb3Vwcy5zZXQoZ2ssIG9iaik7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IFN0cmluZyhyW2tleUZpZWxkXSA/PyBcIlwiKS50cmltKCk7XG4gICAgaWYgKGtleSkgKG9iaiBhcyBhbnkpW2tleV0gPSByW3ZhbEZpZWxkXSA/PyBcIlwiO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGdyb3Vwcy52YWx1ZXMoKSkubWFwKHNuYWtlKTtcbn1cblxuLyoqIFB1YmxpYzogcmVhZCByZXN1bHRzIGFzIFwid2lkZVwiIHJvd3MsIHVzaW5nIHdpZGUgZmlyc3QgdGhlbiBmbGF04oaSd2lkZSAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNiUmVhZFJlc3VsdHNCeVBhdGllbnQocGF0aWVudElkOiBzdHJpbmcpOiBQcm9taXNlPFJvd1tdPiB7XG4gIGNvbnN0IHdpZGUgPSBhd2FpdCBzYlJlYWRSZXN1bHRzV2lkZUJ5UGF0aWVudChwYXRpZW50SWQpO1xuICBpZiAod2lkZS5sZW5ndGgpIHJldHVybiB3aWRlO1xuICByZXR1cm4gYXdhaXQgc2JSZWFkUmVzdWx0c0ZsYXRCeVBhdGllbnQocGF0aWVudElkKTtcbn1cblxuLyoqIFBhdGllbnQgc3VtbWFyeSAoUGF0aWVudHMgdGFibGUpICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2JSZWFkUGF0aWVudEJ5SWQocGF0aWVudElkOiBzdHJpbmcpOiBQcm9taXNlPFJvdyB8IG51bGw+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZSgpO1xuICBjb25zdCBwaWQgPSBlc2NhcGVMaWtlRXhhY3QoU3RyaW5nKHBhdGllbnRJZCB8fCBcIlwiKS50cmltKCkpO1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwicGF0aWVudHNcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKVxuICAgIC5saW1pdCgxKVxuICAgIC5tYXliZVNpbmdsZSgpO1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICByZXR1cm4gZGF0YSA/IHNuYWtlKGRhdGEgYXMgUm93KSA6IG51bGw7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYkxpc3RWaXRhbHNCeVBhdGllbnQoXG4gIHBhdGllbnRJZDogc3RyaW5nLFxuICBvcHRzPzogeyBsaW1pdD86IG51bWJlcjsgY29uc3VsdGF0aW9uSWQ/OiBzdHJpbmc7IGVuY291bnRlcklkPzogc3RyaW5nIH1cbik6IFByb21pc2U8Vml0YWxzU25hcHNob3RSb3dbXT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGdldFN1cGFiYXNlKCk7XG4gIGNvbnN0IHBpZCA9IGVzY2FwZUxpa2VFeGFjdChTdHJpbmcocGF0aWVudElkIHx8IFwiXCIpLnRyaW0oKSk7XG4gIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgLmZyb20oXCJ2aXRhbHNfc25hcHNob3RzXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZClcbiAgICAub3JkZXIoXCJtZWFzdXJlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgaWYgKG9wdHM/LmNvbnN1bHRhdGlvbklkKSBxdWVyeSA9IHF1ZXJ5LmVxKFwiY29uc3VsdGF0aW9uX2lkXCIsIG9wdHMuY29uc3VsdGF0aW9uSWQpO1xuICBpZiAob3B0cz8uZW5jb3VudGVySWQpIHF1ZXJ5ID0gcXVlcnkuZXEoXCJlbmNvdW50ZXJfaWRcIiwgb3B0cy5lbmNvdW50ZXJJZCk7XG4gIHF1ZXJ5ID0gcXVlcnkubGltaXQob3B0cz8ubGltaXQgPz8gOCk7XG5cbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gIHJldHVybiAoZGF0YSB8fCBbXSkubWFwKChyKSA9PiBzbmFrZShyIGFzIFJvdykpIGFzIFZpdGFsc1NuYXBzaG90Um93W107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYlJlYWRMYXRlc3RWaXRhbHNCeVBhdGllbnQoXG4gIHBhdGllbnRJZDogc3RyaW5nLFxuICBvcHRzPzogeyBjb25zdWx0YXRpb25JZD86IHN0cmluZzsgZW5jb3VudGVySWQ/OiBzdHJpbmcgfVxuKTogUHJvbWlzZTxWaXRhbHNTbmFwc2hvdFJvdyB8IG51bGw+IHtcbiAgY29uc3Qgcm93cyA9IGF3YWl0IHNiTGlzdFZpdGFsc0J5UGF0aWVudChwYXRpZW50SWQsIHsgLi4ub3B0cywgbGltaXQ6IDEgfSk7XG4gIHJldHVybiByb3dzWzBdID8/IG51bGw7XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50IiwiU1VQQUJBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkiLCJFcnJvciIsImdldFN1cGFiYXNlIiwiYXV0aCIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsIlNVUEFCQVNFX0FOT05fS0VZIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJnZXRTdXBhYmFzZUJyb3dzZXIiLCJzbmFrZSIsInJvdyIsIm91dCIsImsiLCJ2IiwiT2JqZWN0IiwiZW50cmllcyIsIm5rIiwiU3RyaW5nIiwidHJpbSIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsImVzY2FwZUxpa2VFeGFjdCIsInMiLCJtIiwic2JSZWFkQ29uZmlnIiwic3VwYWJhc2UiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiciIsImtleSIsInZhbHVlIiwic2JSZWFkUmFuZ2VzIiwibWFwIiwic2JSZWFkUmVzdWx0c1dpZGVCeVBhdGllbnQiLCJwYXRpZW50SWQiLCJwaWQiLCJpbGlrZSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwic2JSZWFkUmVzdWx0c0ZsYXRCeVBhdGllbnQiLCJmbGF0IiwibGVuZ3RoIiwia2V5RmllbGQiLCJmaW5kIiwidmFsRmllbGQiLCJncm91cHMiLCJNYXAiLCJnayIsInBhdGllbnRfaWQiLCJkYXRlX29mX3Rlc3QiLCJiYXJjb2RlIiwibm90ZXMiLCJqb2luIiwib2JqIiwiZ2V0Iiwic2V0IiwiQXJyYXkiLCJ2YWx1ZXMiLCJzYlJlYWRSZXN1bHRzQnlQYXRpZW50Iiwid2lkZSIsInNiUmVhZFBhdGllbnRCeUlkIiwibGltaXQiLCJtYXliZVNpbmdsZSIsInNiTGlzdFZpdGFsc0J5UGF0aWVudCIsIm9wdHMiLCJxdWVyeSIsImNvbnN1bHRhdGlvbklkIiwiZXEiLCJlbmNvdW50ZXJJZCIsInNiUmVhZExhdGVzdFZpdGFsc0J5UGF0aWVudCIsInJvd3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase.ts\n");

/***/ })

};
;