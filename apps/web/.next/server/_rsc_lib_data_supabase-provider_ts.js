"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_lib_data_supabase-provider_ts";
exports.ids = ["_rsc_lib_data_supabase-provider_ts"];
exports.modules = {

/***/ "(rsc)/./lib/data/supabase-provider.ts":
/*!***************************************!*\
  !*** ./lib/data/supabase-provider.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSupabaseProvider: () => (/* binding */ createSupabaseProvider)\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(rsc)/./lib/supabase.ts\");\n// lib/data/supabase-provider.ts\n\n/* ----------------- helpers ----------------- */ function isPlaceholder(x) {\n    if (x === null || x === undefined) return true;\n    const s = String(x).trim();\n    return s === \"\" || s === \"-\" || s === \"—\" || s.toLowerCase() === \"n/a\";\n}\n// Parse common date formats → timestamp (ms). Handles ISO and M/D/YYYY (and D/M/YYYY when obvious).\nfunction ts(d) {\n    if (!d) return 0;\n    const s = String(d).trim();\n    // Try native parser first (works for ISO like 2025-09-25)\n    const t = Date.parse(s);\n    if (!Number.isNaN(t)) return t;\n    // Try M/D/YYYY or D/M/YYYY\n    const m = s.match(/^(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{2,4})$/);\n    if (m) {\n        const a = parseInt(m[1], 10);\n        const b = parseInt(m[2], 10);\n        const y = m[3].length === 2 ? 2000 + parseInt(m[3], 10) : parseInt(m[3], 10);\n        // If first number >12, it's D/M/Y; otherwise assume M/D/Y\n        const isDMY = a > 12;\n        const month = isDMY ? b - 1 : a - 1;\n        const day = isDMY ? a : b;\n        return new Date(y, month, day).getTime();\n    }\n    return 0; // fall back\n}\nfunction toNum(x) {\n    if (x === null || x === undefined) return null;\n    const s = String(x).replace(/,/g, \"\").trim();\n    if (isPlaceholder(s)) return null;\n    const n = Number(s);\n    return Number.isFinite(n) ? n : null;\n}\nfunction pick(...vals) {\n    for (const v of vals){\n        if (v === null || v === undefined) continue;\n        if (typeof v === \"string\" && isPlaceholder(v)) continue;\n        return v;\n    }\n    return null;\n}\n// exact, case-insensitive match for ILIKE (escape % and _)\nfunction escapeLikeExact(s) {\n    return s.replace(/[%_]/g, (m)=>`\\\\${m}`);\n}\nfunction prefixToSection(key) {\n    const k = (key || \"\").toLowerCase();\n    if (k.startsWith(\"hema_\")) return \"Hematology\";\n    if (k.startsWith(\"chem_\")) return \"Blood Chemistry\";\n    if (k.startsWith(\"fa_\")) return \"Fecalysis\";\n    if (k.startsWith(\"ua_\")) return \"Urinalysis\";\n    if (k.startsWith(\"sero_\")) return \"Serology\";\n    return \"Others\";\n}\n/* ---------- default per-section order (fallback when no ranges.order) ---------- */ const DEFAULT_ORDER = {\n    Hematology: [\n        \"hema_wbc\",\n        \"hema_lymph\",\n        \"hema_mid\",\n        \"hema_gran\",\n        \"hema_rbc\",\n        \"hema_hgb\",\n        \"hema_hct\",\n        \"hema_mcv\",\n        \"hema_mch\",\n        \"hema_mchc\",\n        \"hema_plt\",\n        \"hema_bt\",\n        \"hema_remarks\"\n    ],\n    \"Blood Chemistry\": [\n        \"chem_ogbase\",\n        \"chem_og1st\",\n        \"chem_og2nd\",\n        \"chem_fbs\",\n        \"chem_rbs\",\n        \"chem_hba1c\",\n        \"chem_chole\",\n        \"chem_trigly\",\n        \"chem_hdl\",\n        \"chem_ldl\",\n        \"chem_vldl\",\n        \"chem_bun\",\n        \"chem_crea\",\n        \"chem_bua\",\n        \"chem_ast\",\n        \"chem_alt\",\n        \"chem_tsh\",\n        \"chem_ft3\",\n        \"chem_ft4\",\n        \"chem_t3\",\n        \"chem_t4\",\n        \"chem_psa\",\n        \"chem_remarks\"\n    ],\n    Urinalysis: [\n        \"ua_color\",\n        \"ua_trans\",\n        \"ua_glu\",\n        \"ua_pro\",\n        \"ua_ph\",\n        \"ua_sg\",\n        \"blood\",\n        \"ua_bilirubin\",\n        \"ua_urobili\",\n        \"ua_ketones\",\n        \"ua_nitrites\",\n        \"ua_le\",\n        \"ua_cast\",\n        \"ua_casttype\",\n        \"ua_crystals\",\n        \"ua_crystalstype\",\n        \"ua_epi\",\n        \"ua_muc\",\n        \"ua_ura\",\n        \"ua_pho\",\n        \"ua_bac\",\n        \"ua_pus\",\n        \"ua_rbc\",\n        \"ua_remarks\"\n    ],\n    Fecalysis: [\n        \"fa_color\",\n        \"fa_cons\",\n        \"fa_pus\",\n        \"fa_rbc\",\n        \"fa_bac\",\n        \"fa_yeast\",\n        \"fa_fat\",\n        \"fa_para\",\n        \"fa_paratype\",\n        \"fa_fobt\",\n        \"fa_remarks\"\n    ],\n    Serology: [\n        \"sero_dengns1\",\n        \"sero_dengm\",\n        \"sero_dengg\",\n        \"sero_hepab\",\n        \"sero_rpv\",\n        \"sero_hiv\",\n        \"sero_hcv\",\n        \"sero_pt\",\n        \"sero_remarks\"\n    ],\n    Others: []\n};\nfunction buildOrderIndex(rangesRows) {\n    const byKeyOrder = new Map();\n    // ranges may have order-like columns; use first that exists\n    for (const r of rangesRows){\n        const key = String(r.analyte_key ?? r.key ?? r.parameter_key ?? r.param_key ?? \"\").trim();\n        if (!key) continue;\n        const orderRaw = r.order ?? r.sort_order ?? r.rank ?? r.prio ?? null;\n        const orderNum = toNum(orderRaw);\n        if (orderNum !== null) byKeyOrder.set(key, orderNum);\n    }\n    return byKeyOrder;\n}\nfunction sortItemsInSections(sections, rangesRows) {\n    const orderIndex = buildOrderIndex(rangesRows);\n    return sections.map((sec)=>{\n        const defaults = DEFAULT_ORDER[sec.name] ?? [];\n        const defaultIndex = new Map();\n        defaults.forEach((k, i)=>defaultIndex.set(k, i));\n        const items = [\n            ...sec.items\n        ].sort((a, b)=>{\n            const ao = orderIndex.get(a.key);\n            const bo = orderIndex.get(b.key);\n            if (ao !== undefined || bo !== undefined) {\n                if (ao === undefined) return 1;\n                if (bo === undefined) return -1;\n                return ao - bo;\n            }\n            const ad = defaultIndex.get(a.key);\n            const bd = defaultIndex.get(b.key);\n            if (ad !== undefined || bd !== undefined) {\n                if (ad === undefined) return 1;\n                if (bd === undefined) return -1;\n                return ad - bd;\n            }\n            // final fallback: alphabetical by label then key\n            const al = (a.label || \"\").toLowerCase();\n            const bl = (b.label || \"\").toLowerCase();\n            if (al !== bl) return al < bl ? -1 : 1;\n            return (a.key || \"\").localeCompare(b.key || \"\");\n        });\n        return {\n            ...sec,\n            items\n        };\n    });\n}\nfunction createSupabaseProvider() {\n    const TABLE_PATIENTS = \"patients\";\n    const TABLE_RESULTS = \"results_flat\";\n    const TABLE_RANGES = \"ranges\";\n    const TABLE_VITALS = \"vitals_snapshots\";\n    const db = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.getSupabase)();\n    // cache ranges + raw rows (for ordering)\n    let rangesCache = null;\n    let rangesRowsCache = null;\n    async function getRangesMap() {\n        if (rangesCache && rangesRowsCache) return {\n            map: rangesCache,\n            rows: rangesRowsCache\n        };\n        const { data, error } = await db.from(TABLE_RANGES).select(\"*\");\n        if (error) throw error;\n        const rows = data || [];\n        const map = new Map();\n        for (const r of rows){\n            const key = String(r.analyte_key ?? r.key ?? r.parameter_key ?? r.param_key ?? \"\").trim();\n            if (!key) continue;\n            const section = (r.section ?? r.group ?? r.category ?? null) || prefixToSection(key);\n            const label = (r.item_label ?? r.display_name ?? r.label ?? r.name ?? null) || null;\n            const unit = r.unit ?? r.units ?? r.uom ?? null;\n            // Your ranges use \"low\"/\"high\" (may be text); keep raw for display, numeric for flag logic\n            const low = r.low ?? null;\n            const high = r.high ?? null;\n            map.set(key, {\n                section,\n                label,\n                unit,\n                low,\n                high\n            });\n        }\n        rangesCache = map;\n        rangesRowsCache = rows;\n        return {\n            map,\n            rows\n        };\n    }\n    async function fetchVitalsSnapshots(patient_id, opts) {\n        const pid = escapeLikeExact(String(patient_id || \"\").trim());\n        let query = db.from(TABLE_VITALS).select(\"*\").ilike(\"patient_id\", pid).order(\"measured_at\", {\n            ascending: false\n        });\n        if (opts?.consultation_id) query = query.eq(\"consultation_id\", opts.consultation_id);\n        if (opts?.encounter_id) query = query.eq(\"encounter_id\", opts.encounter_id);\n        query = query.limit(opts?.limit ?? 8);\n        const { data, error } = await query;\n        if (error) throw error;\n        const rows = (data || []).map((r)=>({\n                id: String(r.id),\n                patient_id: String(r.patient_id),\n                consultation_id: String(r.consultation_id),\n                encounter_id: String(r.encounter_id),\n                measured_at: r.measured_at ?? r.created_at ?? new Date().toISOString(),\n                systolic_bp: toNum(r.systolic_bp),\n                diastolic_bp: toNum(r.diastolic_bp),\n                hr: toNum(r.hr),\n                rr: toNum(r.rr),\n                temp_c: r.temp_c == null ? null : Number(r.temp_c),\n                height_cm: r.height_cm == null ? null : Number(r.height_cm),\n                weight_kg: r.weight_kg == null ? null : Number(r.weight_kg),\n                bmi: r.bmi == null ? null : Number(r.bmi),\n                o2sat: toNum(r.o2sat),\n                notes: r.notes ?? null,\n                source: r.source ?? null,\n                created_at: r.created_at ?? null,\n                created_by_initials: r.created_by_initials ?? null\n            }));\n        return {\n            latest: rows[0] ?? null,\n            history: rows\n        };\n    }\n    return {\n        async getPatient (patient_id) {\n            const pid = escapeLikeExact(String(patient_id || \"\").trim());\n            const { data, error } = await db.from(TABLE_PATIENTS).select(\"*\").ilike(\"patient_id\", pid).limit(1).maybeSingle();\n            if (error) throw error;\n            if (!data) return null;\n            const medsCurrent = data.medications_current ?? \"\";\n            const vitals = await fetchVitalsSnapshots(patient_id).catch(()=>({\n                    latest: null,\n                    history: []\n                }));\n            const p = {\n                patient_id: data.patient_id,\n                full_name: data.full_name ?? \"\",\n                sex: data.sex ?? \"\",\n                age: data.age ?? \"\",\n                birthday: data.birthday ?? \"\",\n                contact: data.contact ?? \"\",\n                address: data.address ?? \"\",\n                email: data.email ?? \"\",\n                height_ft: data.height_ft ?? \"\",\n                height_inch: data.height_inch ?? \"\",\n                weight_kg: data.weight_kg ?? \"\",\n                systolic_bp: data.systolic_bp ?? \"\",\n                diastolic_bp: data.diastolic_bp ?? \"\",\n                last_updated: data.last_updated ?? \"\",\n                present_illness_history: data.present_illness_history ?? \"\",\n                past_medical_history: data.past_medical_history ?? \"\",\n                past_surgical_history: data.past_surgical_history ?? \"\",\n                chief_complaint: data.chief_complaint ?? \"\",\n                allergies_text: data.allergies_text ?? \"\",\n                medications_current: medsCurrent,\n                medications: medsCurrent,\n                family_history: data.family_hx ?? \"\",\n                smoking_hx: data.smoking_hx ?? \"\",\n                alcohol_hx: data.alcohol_hx ?? \"\",\n                vitals\n            };\n            return p;\n        },\n        async getVisits (patient_id) {\n            const pid = escapeLikeExact(String(patient_id || \"\").trim());\n            const { data, error } = await db.from(TABLE_RESULTS).select(\"*\").ilike(\"patient_id\", pid);\n            if (error) throw error;\n            const seen = new Map();\n            for (const r of data || []){\n                const date = String(r.date_of_test ?? r.date ?? r.test_date ?? \"\").trim();\n                if (!date || isPlaceholder(date)) continue;\n                if (!seen.has(date)) {\n                    seen.set(date, {\n                        date_of_test: date,\n                        barcode: r.barcode ?? \"\",\n                        branch: r.branch ?? \"\",\n                        notes: r.notes ?? \"\"\n                    });\n                }\n            }\n            return Array.from(seen.values()).sort((a, b)=>ts(b.date_of_test) - ts(a.date_of_test));\n        },\n        async getReport ({ patient_id, visitDate }) {\n            const patient = await this.getPatient(patient_id);\n            if (!patient) return null;\n            let date = visitDate;\n            if (!date) {\n                const visits = await this.getVisits(patient_id);\n                date = visits[0]?.date_of_test;\n                if (!date) return null;\n            }\n            const pid = escapeLikeExact(String(patient_id || \"\").trim());\n            const { data, error } = await db.from(TABLE_RESULTS).select(\"*\").ilike(\"patient_id\", pid).eq(\"date_of_test\", date);\n            if (error) throw error;\n            const rows = data ?? [];\n            if (rows.length === 0) return null;\n            const { map: rangesMap, rows: rangesRows } = await getRangesMap();\n            const bySection = new Map();\n            for (const r of rows){\n                const key = String(r.item_key ?? r.analyte_key ?? r.parameter_key ?? r.param_key ?? r.key ?? \"\").trim();\n                const meta = key ? rangesMap.get(key) : undefined;\n                const label = String(pick(r.item_label, r.display_name, r.parameter_label, r.label, meta?.label, key || null) ?? \"\").trim();\n                // unit: never allow \"null\" string\n                const unitRaw = pick(r.unit, r.units, r.uom, meta?.unit);\n                const unit = unitRaw == null ? \"\" : String(unitRaw);\n                // section from ranges or prefix\n                const section = String(pick(r.section, r.item_section, r.dept, r.category, meta?.section, prefixToSection(key || label), \"Others\"));\n                // value: treat \"-\" etc as null; keep numeric if possible for flags\n                const rawVal = pick(r.value, r.result, r.val);\n                const valueNum = toNum(rawVal);\n                const value = valueNum !== null ? valueNum : isPlaceholder(rawVal) ? null : rawVal;\n                // references (display raw, compute flags via numeric)\n                const rawLow = pick(r.ref_low, r.low, meta?.low);\n                const rawHigh = pick(r.ref_high, r.high, meta?.high);\n                const ref_low_display = isPlaceholder(rawLow) ? null : rawLow;\n                const ref_high_display = isPlaceholder(rawHigh) ? null : rawHigh;\n                const refLowNum = toNum(rawLow);\n                const refHighNum = toNum(rawHigh);\n                // flag: prefer DB; else compute L/H only (do NOT show \"N\")\n                let flag = null;\n                const rawFlag = pick(r.flag) ?? null;\n                if (rawFlag) {\n                    const f = String(rawFlag).toUpperCase();\n                    if (f === \"L\" || f === \"H\" || f === \"A\") flag = f;\n                } else if (valueNum !== null) {\n                    if (refLowNum !== null && valueNum < refLowNum) flag = \"L\";\n                    else if (refHighNum !== null && valueNum > refHighNum) flag = \"H\";\n                // else normal → leave null (you don't want \"N\")\n                }\n                const item = {\n                    key,\n                    label,\n                    unit,\n                    value,\n                    ref_low: ref_low_display,\n                    ref_high: ref_high_display,\n                    flag,\n                    method: r.method ?? null,\n                    remarks: r.remarks ?? null\n                };\n                // skip placeholders/blank values entirely (don't render)\n                if (item.value === null || typeof item.value === \"string\" && isPlaceholder(item.value)) {\n                    continue;\n                }\n                const arr = bySection.get(section) ?? [];\n                arr.push(item);\n                bySection.set(section, arr);\n            }\n            // sort items in each section\n            let sections = Array.from(bySection.entries()).map(([name, items])=>({\n                    name,\n                    items\n                })).filter((sec)=>sec.items.some((i)=>i.value !== null && String(i.value).trim() !== \"\"));\n            sections = sortItemsInSections(sections, rangesRows);\n            const first = rows[0] || {};\n            const visit = {\n                date_of_test: date,\n                barcode: first.barcode ?? \"\",\n                branch: first.branch ?? \"\",\n                notes: first.notes ?? \"\"\n            };\n            return {\n                patient,\n                visit,\n                sections\n            };\n        },\n        async searchPatients ({ query, limit = 20, offset = 0 }) {\n            const q = (query || \"\").trim();\n            if (!q) return {\n                results: [],\n                total: 0\n            };\n            const pat = `%${q.replace(/[%_]/g, (m)=>`\\\\${m}`)}%`;\n            const { data, error, count } = await db.from(TABLE_PATIENTS).select(\"patient_id, full_name, sex, age, birthday, contact, address, email\", {\n                count: \"exact\"\n            }).or(`patient_id.ilike.${pat},full_name.ilike.${pat}`).order(\"full_name\", {\n                ascending: true\n            }).range(offset, offset + limit - 1);\n            if (error) throw error;\n            return {\n                results: data || [],\n                total: count ?? undefined\n            };\n        },\n        async getConfig () {\n            return {\n                footer_lines: [],\n                signatories: []\n            };\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0osT0FBTztnQkFBRUMsY0FBYyxFQUFFO2dCQUFFQyxhQUFhLEVBQUU7WUFBQztRQUM3QztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb2Nob2xvL1Byb2plY3RzL3dlbGxzZXJ2LXBvcnRhbC9hcHBzL3dlYi9saWIvZGF0YS9zdXBhYmFzZS1wcm92aWRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsaWIvZGF0YS9zdXBhYmFzZS1wcm92aWRlci50c1xuaW1wb3J0IHR5cGUge1xuICBEYXRhUHJvdmlkZXIsXG4gIFBhdGllbnQsXG4gIFZpc2l0LFxuICBSZXBvcnQsXG4gIFJlcG9ydFNlY3Rpb24sXG4gIFJlcG9ydEl0ZW0sXG4gIFZpdGFsc1NuYXBzaG90LFxufSBmcm9tIFwiLi9kYXRhLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBnZXRTdXBhYmFzZSB9IGZyb20gXCJAL2xpYi9zdXBhYmFzZVwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLSBoZWxwZXJzIC0tLS0tLS0tLS0tLS0tLS0tICovXG5mdW5jdGlvbiBpc1BsYWNlaG9sZGVyKHg6IGFueSk6IGJvb2xlYW4ge1xuICBpZiAoeCA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICBjb25zdCBzID0gU3RyaW5nKHgpLnRyaW0oKTtcbiAgcmV0dXJuIHMgPT09IFwiXCIgfHwgcyA9PT0gXCItXCIgfHwgcyA9PT0gXCLigJRcIiB8fCBzLnRvTG93ZXJDYXNlKCkgPT09IFwibi9hXCI7XG59XG5cbi8vIFBhcnNlIGNvbW1vbiBkYXRlIGZvcm1hdHMg4oaSIHRpbWVzdGFtcCAobXMpLiBIYW5kbGVzIElTTyBhbmQgTS9EL1lZWVkgKGFuZCBEL00vWVlZWSB3aGVuIG9idmlvdXMpLlxuZnVuY3Rpb24gdHMoZDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gIGlmICghZCkgcmV0dXJuIDA7XG4gIGNvbnN0IHMgPSBTdHJpbmcoZCkudHJpbSgpO1xuICAvLyBUcnkgbmF0aXZlIHBhcnNlciBmaXJzdCAod29ya3MgZm9yIElTTyBsaWtlIDIwMjUtMDktMjUpXG4gIGNvbnN0IHQgPSBEYXRlLnBhcnNlKHMpO1xuICBpZiAoIU51bWJlci5pc05hTih0KSkgcmV0dXJuIHQ7XG5cbiAgLy8gVHJ5IE0vRC9ZWVlZIG9yIEQvTS9ZWVlZXG4gIGNvbnN0IG0gPSBzLm1hdGNoKC9eKFxcZHsxLDJ9KVtcXC9cXC1dKFxcZHsxLDJ9KVtcXC9cXC1dKFxcZHsyLDR9KSQvKTtcbiAgaWYgKG0pIHtcbiAgICBjb25zdCBhID0gcGFyc2VJbnQobVsxXSwgMTApO1xuICAgIGNvbnN0IGIgPSBwYXJzZUludChtWzJdLCAxMCk7XG4gICAgY29uc3QgeSA9IG1bM10ubGVuZ3RoID09PSAyID8gMjAwMCArIHBhcnNlSW50KG1bM10sIDEwKSA6IHBhcnNlSW50KG1bM10sIDEwKTtcbiAgICAvLyBJZiBmaXJzdCBudW1iZXIgPjEyLCBpdCdzIEQvTS9ZOyBvdGhlcndpc2UgYXNzdW1lIE0vRC9ZXG4gICAgY29uc3QgaXNETVkgPSBhID4gMTI7XG4gICAgY29uc3QgbW9udGggPSBpc0RNWSA/IGIgLSAxIDogYSAtIDE7XG4gICAgY29uc3QgZGF5ICAgPSBpc0RNWSA/IGEgICAgIDogYjtcbiAgICByZXR1cm4gbmV3IERhdGUoeSwgbW9udGgsIGRheSkuZ2V0VGltZSgpO1xuICB9XG5cbiAgcmV0dXJuIDA7IC8vIGZhbGwgYmFja1xufVxuXG5mdW5jdGlvbiB0b051bSh4OiBhbnkpOiBudW1iZXIgfCBudWxsIHtcbiAgaWYgKHggPT09IG51bGwgfHwgeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgcyA9IFN0cmluZyh4KS5yZXBsYWNlKC8sL2csIFwiXCIpLnRyaW0oKTtcbiAgaWYgKGlzUGxhY2Vob2xkZXIocykpIHJldHVybiBudWxsO1xuICBjb25zdCBuID0gTnVtYmVyKHMpO1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG4pID8gbiA6IG51bGw7XG59XG5mdW5jdGlvbiBwaWNrPFQ+KC4uLnZhbHM6IFRbXSk6IFQgfCBudWxsIHtcbiAgZm9yIChjb25zdCB2IG9mIHZhbHMpIHtcbiAgICBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiAmJiBpc1BsYWNlaG9sZGVyKHYpKSBjb250aW51ZTtcbiAgICByZXR1cm4gdjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbi8vIGV4YWN0LCBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBJTElLRSAoZXNjYXBlICUgYW5kIF8pXG5mdW5jdGlvbiBlc2NhcGVMaWtlRXhhY3Qoczogc3RyaW5nKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1slX10vZywgKG0pID0+IGBcXFxcJHttfWApO1xufVxuZnVuY3Rpb24gcHJlZml4VG9TZWN0aW9uKGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgayA9IChrZXkgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGsuc3RhcnRzV2l0aChcImhlbWFfXCIpKSByZXR1cm4gXCJIZW1hdG9sb2d5XCI7XG4gIGlmIChrLnN0YXJ0c1dpdGgoXCJjaGVtX1wiKSkgcmV0dXJuIFwiQmxvb2QgQ2hlbWlzdHJ5XCI7XG4gIGlmIChrLnN0YXJ0c1dpdGgoXCJmYV9cIikpICAgcmV0dXJuIFwiRmVjYWx5c2lzXCI7XG4gIGlmIChrLnN0YXJ0c1dpdGgoXCJ1YV9cIikpICAgcmV0dXJuIFwiVXJpbmFseXNpc1wiO1xuICBpZiAoay5zdGFydHNXaXRoKFwic2Vyb19cIikpIHJldHVybiBcIlNlcm9sb2d5XCI7XG4gIHJldHVybiBcIk90aGVyc1wiO1xufVxuXG4vKiAtLS0tLS0tLS0tIGRlZmF1bHQgcGVyLXNlY3Rpb24gb3JkZXIgKGZhbGxiYWNrIHdoZW4gbm8gcmFuZ2VzLm9yZGVyKSAtLS0tLS0tLS0tICovXG5jb25zdCBERUZBVUxUX09SREVSOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7XG4gIEhlbWF0b2xvZ3k6IFtcbiAgICBcImhlbWFfd2JjXCIsIFwiaGVtYV9seW1waFwiLCBcImhlbWFfbWlkXCIsIFwiaGVtYV9ncmFuXCIsXG4gICAgXCJoZW1hX3JiY1wiLCBcImhlbWFfaGdiXCIsIFwiaGVtYV9oY3RcIiwgXCJoZW1hX21jdlwiLCBcImhlbWFfbWNoXCIsIFwiaGVtYV9tY2hjXCIsXG4gICAgXCJoZW1hX3BsdFwiLCBcImhlbWFfYnRcIiwgXCJoZW1hX3JlbWFya3NcIixcbiAgXSxcbiAgXCJCbG9vZCBDaGVtaXN0cnlcIjogW1xuICAgIFwiY2hlbV9vZ2Jhc2VcIiwgXCJjaGVtX29nMXN0XCIsIFwiY2hlbV9vZzJuZFwiLCBcImNoZW1fZmJzXCIsIFwiY2hlbV9yYnNcIiwgXCJjaGVtX2hiYTFjXCIsXG4gICAgXCJjaGVtX2Nob2xlXCIsIFwiY2hlbV90cmlnbHlcIiwgXCJjaGVtX2hkbFwiLCBcImNoZW1fbGRsXCIsIFwiY2hlbV92bGRsXCIsXG4gICAgXCJjaGVtX2J1blwiLCBcImNoZW1fY3JlYVwiLCBcImNoZW1fYnVhXCIsXG4gICAgXCJjaGVtX2FzdFwiLCBcImNoZW1fYWx0XCIsXG4gICAgXCJjaGVtX3RzaFwiLCBcImNoZW1fZnQzXCIsIFwiY2hlbV9mdDRcIiwgXCJjaGVtX3QzXCIsIFwiY2hlbV90NFwiLFxuICAgIFwiY2hlbV9wc2FcIiwgXCJjaGVtX3JlbWFya3NcIixcbiAgXSxcbiAgVXJpbmFseXNpczogW1xuICAgIFwidWFfY29sb3JcIiwgXCJ1YV90cmFuc1wiLCBcInVhX2dsdVwiLCBcInVhX3Byb1wiLCBcInVhX3BoXCIsIFwidWFfc2dcIiwgXCJibG9vZFwiLFxuICAgIFwidWFfYmlsaXJ1YmluXCIsIFwidWFfdXJvYmlsaVwiLCBcInVhX2tldG9uZXNcIiwgXCJ1YV9uaXRyaXRlc1wiLCBcInVhX2xlXCIsXG4gICAgXCJ1YV9jYXN0XCIsIFwidWFfY2FzdHR5cGVcIiwgXCJ1YV9jcnlzdGFsc1wiLCBcInVhX2NyeXN0YWxzdHlwZVwiLFxuICAgIFwidWFfZXBpXCIsIFwidWFfbXVjXCIsIFwidWFfdXJhXCIsIFwidWFfcGhvXCIsXG4gICAgXCJ1YV9iYWNcIiwgXCJ1YV9wdXNcIiwgXCJ1YV9yYmNcIiwgXCJ1YV9yZW1hcmtzXCIsXG4gIF0sXG4gIEZlY2FseXNpczogW1xuICAgIFwiZmFfY29sb3JcIixcdFwiZmFfY29uc1wiLCBcImZhX3B1c1wiLCBcImZhX3JiY1wiLFxuICAgIFwiZmFfYmFjXCIsIFwiZmFfeWVhc3RcIiwgXCJmYV9mYXRcIiwgXCJmYV9wYXJhXCIsIFwiZmFfcGFyYXR5cGVcIixcbiAgICBcImZhX2ZvYnRcIiwgXCJmYV9yZW1hcmtzXCIsXG5dLFxuICBTZXJvbG9neTogW1xuICAgIFwic2Vyb19kZW5nbnMxXCIsIFwic2Vyb19kZW5nbVwiLCBcInNlcm9fZGVuZ2dcIixcbiAgICBcInNlcm9faGVwYWJcIiwgXCJzZXJvX3JwdlwiLCBcInNlcm9faGl2XCIsIFwic2Vyb19oY3ZcIiwgXCJzZXJvX3B0XCIsXG4gICAgXCJzZXJvX3JlbWFya3NcIlxuXSxcbiAgT3RoZXJzOiBbXSxcbn07XG5mdW5jdGlvbiBidWlsZE9yZGVySW5kZXgocmFuZ2VzUm93czogUmVjb3JkPHN0cmluZywgYW55PltdKSB7XG4gIGNvbnN0IGJ5S2V5T3JkZXIgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICAvLyByYW5nZXMgbWF5IGhhdmUgb3JkZXItbGlrZSBjb2x1bW5zOyB1c2UgZmlyc3QgdGhhdCBleGlzdHNcbiAgZm9yIChjb25zdCByIG9mIHJhbmdlc1Jvd3MpIHtcbiAgICBjb25zdCBrZXkgPSBTdHJpbmcoXG4gICAgICByLmFuYWx5dGVfa2V5ID8/IHIua2V5ID8/IHIucGFyYW1ldGVyX2tleSA/PyByLnBhcmFtX2tleSA/PyBcIlwiXG4gICAgKS50cmltKCk7XG4gICAgaWYgKCFrZXkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IG9yZGVyUmF3ID0gKHIub3JkZXIgPz8gci5zb3J0X29yZGVyID8/IHIucmFuayA/PyByLnByaW8gPz8gbnVsbCk7XG4gICAgY29uc3Qgb3JkZXJOdW0gPSB0b051bShvcmRlclJhdyk7XG4gICAgaWYgKG9yZGVyTnVtICE9PSBudWxsKSBieUtleU9yZGVyLnNldChrZXksIG9yZGVyTnVtKTtcbiAgfVxuICByZXR1cm4gYnlLZXlPcmRlcjtcbn1cbmZ1bmN0aW9uIHNvcnRJdGVtc0luU2VjdGlvbnMoXG4gIHNlY3Rpb25zOiBSZXBvcnRTZWN0aW9uW10sXG4gIHJhbmdlc1Jvd3M6IFJlY29yZDxzdHJpbmcsIGFueT5bXVxuKTogUmVwb3J0U2VjdGlvbltdIHtcbiAgY29uc3Qgb3JkZXJJbmRleCA9IGJ1aWxkT3JkZXJJbmRleChyYW5nZXNSb3dzKTtcbiAgcmV0dXJuIHNlY3Rpb25zLm1hcCgoc2VjKSA9PiB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSBERUZBVUxUX09SREVSW3NlYy5uYW1lXSA/PyBbXTtcbiAgICBjb25zdCBkZWZhdWx0SW5kZXggPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICAgIGRlZmF1bHRzLmZvckVhY2goKGssIGkpID0+IGRlZmF1bHRJbmRleC5zZXQoaywgaSkpO1xuXG4gICAgY29uc3QgaXRlbXMgPSBbLi4uc2VjLml0ZW1zXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBhbyA9IG9yZGVySW5kZXguZ2V0KGEua2V5KTtcbiAgICAgIGNvbnN0IGJvID0gb3JkZXJJbmRleC5nZXQoYi5rZXkpO1xuICAgICAgaWYgKGFvICE9PSB1bmRlZmluZWQgfHwgYm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYW8gPT09IHVuZGVmaW5lZCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChibyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiBhbyAtIGJvO1xuICAgICAgfVxuICAgICAgY29uc3QgYWQgPSBkZWZhdWx0SW5kZXguZ2V0KGEua2V5KTtcbiAgICAgIGNvbnN0IGJkID0gZGVmYXVsdEluZGV4LmdldChiLmtleSk7XG4gICAgICBpZiAoYWQgIT09IHVuZGVmaW5lZCB8fCBiZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGJkID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICAgICAgcmV0dXJuIGFkIC0gYmQ7XG4gICAgICB9XG4gICAgICAvLyBmaW5hbCBmYWxsYmFjazogYWxwaGFiZXRpY2FsIGJ5IGxhYmVsIHRoZW4ga2V5XG4gICAgICBjb25zdCBhbCA9IChhLmxhYmVsIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBibCA9IChiLmxhYmVsIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoYWwgIT09IGJsKSByZXR1cm4gYWwgPCBibCA/IC0xIDogMTtcbiAgICAgIHJldHVybiAoYS5rZXkgfHwgXCJcIikubG9jYWxlQ29tcGFyZShiLmtleSB8fCBcIlwiKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IC4uLnNlYywgaXRlbXMgfTtcbiAgfSk7XG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tIHByb3ZpZGVyIC0tLS0tLS0tLS0tLS0tLS0tICovXG50eXBlIFJhbmdlTWV0YSA9IHtcbiAgc2VjdGlvbj86IHN0cmluZyB8IG51bGw7XG4gIGxhYmVsPzogc3RyaW5nIHwgbnVsbDtcbiAgdW5pdD86IHN0cmluZyB8IG51bGw7XG4gIGxvdz86IG51bWJlciB8IHN0cmluZyB8IG51bGw7XG4gIGhpZ2g/OiBudW1iZXIgfCBzdHJpbmcgfCBudWxsO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1cGFiYXNlUHJvdmlkZXIoKTogRGF0YVByb3ZpZGVyIHtcbiAgY29uc3QgVEFCTEVfUEFUSUVOVFMgPSBcInBhdGllbnRzXCI7XG4gIGNvbnN0IFRBQkxFX1JFU1VMVFMgID0gXCJyZXN1bHRzX2ZsYXRcIjtcbiAgY29uc3QgVEFCTEVfUkFOR0VTICAgPSBcInJhbmdlc1wiO1xuICBjb25zdCBUQUJMRV9WSVRBTFMgICA9IFwidml0YWxzX3NuYXBzaG90c1wiO1xuXG4gIGNvbnN0IGRiID0gZ2V0U3VwYWJhc2UoKTtcblxuICAvLyBjYWNoZSByYW5nZXMgKyByYXcgcm93cyAoZm9yIG9yZGVyaW5nKVxuICBsZXQgcmFuZ2VzQ2FjaGU6IE1hcDxzdHJpbmcsIFJhbmdlTWV0YT4gfCBudWxsID0gbnVsbDtcbiAgbGV0IHJhbmdlc1Jvd3NDYWNoZTogUmVjb3JkPHN0cmluZywgYW55PltdIHwgbnVsbCA9IG51bGw7XG5cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0UmFuZ2VzTWFwKCk6IFByb21pc2U8eyBtYXA6IE1hcDxzdHJpbmcsIFJhbmdlTWV0YT47IHJvd3M6IFJlY29yZDxzdHJpbmcsIGFueT5bXSB9PiB7XG4gICAgaWYgKHJhbmdlc0NhY2hlICYmIHJhbmdlc1Jvd3NDYWNoZSkgcmV0dXJuIHsgbWFwOiByYW5nZXNDYWNoZSwgcm93czogcmFuZ2VzUm93c0NhY2hlIH07XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgZGIuZnJvbShUQUJMRV9SQU5HRVMpLnNlbGVjdChcIipcIik7XG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblxuICAgIGNvbnN0IHJvd3MgPSAoZGF0YSB8fCBbXSkgYXMgUmVjb3JkPHN0cmluZywgYW55PltdO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXA8c3RyaW5nLCBSYW5nZU1ldGE+KCk7XG4gICAgZm9yIChjb25zdCByIG9mIHJvd3MpIHtcbiAgICAgIGNvbnN0IGtleSA9IFN0cmluZyhcbiAgICAgICAgci5hbmFseXRlX2tleSA/PyByLmtleSA/PyByLnBhcmFtZXRlcl9rZXkgPz8gci5wYXJhbV9rZXkgPz8gXCJcIlxuICAgICAgKS50cmltKCk7XG4gICAgICBpZiAoIWtleSkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IHNlY3Rpb24gPVxuICAgICAgICAoci5zZWN0aW9uID8/IHIuZ3JvdXAgPz8gci5jYXRlZ29yeSA/PyBudWxsKSB8fCBwcmVmaXhUb1NlY3Rpb24oa2V5KTtcbiAgICAgIGNvbnN0IGxhYmVsID1cbiAgICAgICAgKHIuaXRlbV9sYWJlbCA/PyByLmRpc3BsYXlfbmFtZSA/PyByLmxhYmVsID8/IHIubmFtZSA/PyBudWxsKSB8fCBudWxsO1xuICAgICAgY29uc3QgdW5pdCA9IHIudW5pdCA/PyByLnVuaXRzID8/IHIudW9tID8/IG51bGw7XG4gICAgICAvLyBZb3VyIHJhbmdlcyB1c2UgXCJsb3dcIi9cImhpZ2hcIiAobWF5IGJlIHRleHQpOyBrZWVwIHJhdyBmb3IgZGlzcGxheSwgbnVtZXJpYyBmb3IgZmxhZyBsb2dpY1xuICAgICAgY29uc3QgbG93ICA9IHIubG93ICA/PyBudWxsO1xuICAgICAgY29uc3QgaGlnaCA9IHIuaGlnaCA/PyBudWxsO1xuXG4gICAgICBtYXAuc2V0KGtleSwgeyBzZWN0aW9uLCBsYWJlbCwgdW5pdCwgbG93LCBoaWdoIH0pO1xuICAgIH1cbiAgICByYW5nZXNDYWNoZSA9IG1hcDtcbiAgICByYW5nZXNSb3dzQ2FjaGUgPSByb3dzO1xuICAgIHJldHVybiB7IG1hcCwgcm93cyB9O1xuICB9XG5cbiAgdHlwZSBWaXRhbHNCdW5kbGUgPSB7IGxhdGVzdDogVml0YWxzU25hcHNob3QgfCBudWxsOyBoaXN0b3J5OiBWaXRhbHNTbmFwc2hvdFtdIH07XG5cbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hWaXRhbHNTbmFwc2hvdHMoXG4gICAgcGF0aWVudF9pZDogc3RyaW5nLFxuICAgIG9wdHM/OiB7IGxpbWl0PzogbnVtYmVyOyBjb25zdWx0YXRpb25faWQ/OiBzdHJpbmcgfCBudWxsOyBlbmNvdW50ZXJfaWQ/OiBzdHJpbmcgfCBudWxsOyB9XG4gICk6IFByb21pc2U8Vml0YWxzQnVuZGxlPiB7XG4gICAgY29uc3QgcGlkID0gZXNjYXBlTGlrZUV4YWN0KFN0cmluZyhwYXRpZW50X2lkIHx8IFwiXCIpLnRyaW0oKSk7XG4gICAgbGV0IHF1ZXJ5ID0gZGJcbiAgICAgIC5mcm9tKFRBQkxFX1ZJVEFMUylcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZClcbiAgICAgIC5vcmRlcihcIm1lYXN1cmVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcblxuICAgIGlmIChvcHRzPy5jb25zdWx0YXRpb25faWQpIHF1ZXJ5ID0gcXVlcnkuZXEoXCJjb25zdWx0YXRpb25faWRcIiwgb3B0cy5jb25zdWx0YXRpb25faWQpO1xuICAgIGlmIChvcHRzPy5lbmNvdW50ZXJfaWQpIHF1ZXJ5ID0gcXVlcnkuZXEoXCJlbmNvdW50ZXJfaWRcIiwgb3B0cy5lbmNvdW50ZXJfaWQpO1xuICAgIHF1ZXJ5ID0gcXVlcnkubGltaXQob3B0cz8ubGltaXQgPz8gOCk7XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeTtcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXG4gICAgY29uc3Qgcm93czogVml0YWxzU25hcHNob3RbXSA9IChkYXRhIHx8IFtdKS5tYXAoKHIpID0+ICh7XG4gICAgICBpZDogU3RyaW5nKHIuaWQpLFxuICAgICAgcGF0aWVudF9pZDogU3RyaW5nKHIucGF0aWVudF9pZCksXG4gICAgICBjb25zdWx0YXRpb25faWQ6IFN0cmluZyhyLmNvbnN1bHRhdGlvbl9pZCksXG4gICAgICBlbmNvdW50ZXJfaWQ6IFN0cmluZyhyLmVuY291bnRlcl9pZCksXG4gICAgICBtZWFzdXJlZF9hdDogKHIubWVhc3VyZWRfYXQgPz8gci5jcmVhdGVkX2F0ID8/IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSkgYXMgc3RyaW5nLFxuICAgICAgc3lzdG9saWNfYnA6IHRvTnVtKHIuc3lzdG9saWNfYnApLFxuICAgICAgZGlhc3RvbGljX2JwOiB0b051bShyLmRpYXN0b2xpY19icCksXG4gICAgICBocjogdG9OdW0oci5ociksXG4gICAgICBycjogdG9OdW0oci5yciksXG4gICAgICB0ZW1wX2M6IHIudGVtcF9jID09IG51bGwgPyBudWxsIDogTnVtYmVyKHIudGVtcF9jKSxcbiAgICAgIGhlaWdodF9jbTogci5oZWlnaHRfY20gPT0gbnVsbCA/IG51bGwgOiBOdW1iZXIoci5oZWlnaHRfY20pLFxuICAgICAgd2VpZ2h0X2tnOiByLndlaWdodF9rZyA9PSBudWxsID8gbnVsbCA6IE51bWJlcihyLndlaWdodF9rZyksXG4gICAgICBibWk6IHIuYm1pID09IG51bGwgPyBudWxsIDogTnVtYmVyKHIuYm1pKSxcbiAgICAgIG8yc2F0OiB0b051bShyLm8yc2F0KSxcbiAgICAgIG5vdGVzOiByLm5vdGVzID8/IG51bGwsXG4gICAgICBzb3VyY2U6IHIuc291cmNlID8/IG51bGwsXG4gICAgICBjcmVhdGVkX2F0OiByLmNyZWF0ZWRfYXQgPz8gbnVsbCxcbiAgICAgIGNyZWF0ZWRfYnlfaW5pdGlhbHM6IHIuY3JlYXRlZF9ieV9pbml0aWFscyA/PyBudWxsLFxuICAgIH0pKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYXRlc3Q6IHJvd3NbMF0gPz8gbnVsbCxcbiAgICAgIGhpc3Rvcnk6IHJvd3MsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXN5bmMgZ2V0UGF0aWVudChwYXRpZW50X2lkOiBzdHJpbmcpOiBQcm9taXNlPFBhdGllbnQgfCBudWxsPiB7XG4gICAgICBjb25zdCBwaWQgPSBlc2NhcGVMaWtlRXhhY3QoU3RyaW5nKHBhdGllbnRfaWQgfHwgXCJcIikudHJpbSgpKTtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGRiXG4gICAgICAgIC5mcm9tKFRBQkxFX1BBVElFTlRTKVxuICAgICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZClcbiAgICAgICAgLmxpbWl0KDEpXG4gICAgICAgIC5tYXliZVNpbmdsZSgpO1xuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgICAgaWYgKCFkYXRhKSByZXR1cm4gbnVsbDtcblxuICAgICAgY29uc3QgbWVkc0N1cnJlbnQgPSBkYXRhLm1lZGljYXRpb25zX2N1cnJlbnQgPz8gXCJcIjtcblxuICAgICAgY29uc3Qgdml0YWxzID0gYXdhaXQgZmV0Y2hWaXRhbHNTbmFwc2hvdHMocGF0aWVudF9pZCkuY2F0Y2goXG4gICAgICAgICgpOiBWaXRhbHNCdW5kbGUgPT4gKHsgbGF0ZXN0OiBudWxsLCBoaXN0b3J5OiBbXSB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcDogUGF0aWVudCA9IHtcbiAgICAgICAgcGF0aWVudF9pZDogZGF0YS5wYXRpZW50X2lkLFxuICAgICAgICBmdWxsX25hbWU6ICBkYXRhLmZ1bGxfbmFtZSA/PyBcIlwiLFxuICAgICAgICBzZXg6ICAgICAgICBkYXRhLnNleCA/PyBcIlwiLFxuICAgICAgICBhZ2U6ICAgICAgICBkYXRhLmFnZSA/PyBcIlwiLFxuICAgICAgICBiaXJ0aGRheTogICBkYXRhLmJpcnRoZGF5ID8/IFwiXCIsXG4gICAgICAgIGNvbnRhY3Q6ICAgIGRhdGEuY29udGFjdCA/PyBcIlwiLFxuICAgICAgICBhZGRyZXNzOiAgICBkYXRhLmFkZHJlc3MgPz8gXCJcIixcbiAgICAgICAgZW1haWw6ICAgICAgZGF0YS5lbWFpbCA/PyBcIlwiLFxuICAgICAgICBoZWlnaHRfZnQ6ICBkYXRhLmhlaWdodF9mdCA/PyBcIlwiLFxuICAgICAgICBoZWlnaHRfaW5jaDpkYXRhLmhlaWdodF9pbmNoID8/IFwiXCIsXG4gICAgICAgIHdlaWdodF9rZzogIGRhdGEud2VpZ2h0X2tnID8/IFwiXCIsXG4gICAgICAgIHN5c3RvbGljX2JwOmRhdGEuc3lzdG9saWNfYnAgPz8gXCJcIixcbiAgICAgICAgZGlhc3RvbGljX2JwOmRhdGEuZGlhc3RvbGljX2JwID8/IFwiXCIsXG4gICAgICAgIGxhc3RfdXBkYXRlZDogZGF0YS5sYXN0X3VwZGF0ZWQgPz8gXCJcIixcbiAgICAgICAgcHJlc2VudF9pbGxuZXNzX2hpc3Rvcnk6IGRhdGEucHJlc2VudF9pbGxuZXNzX2hpc3RvcnkgPz8gXCJcIixcbiAgICAgICAgcGFzdF9tZWRpY2FsX2hpc3Rvcnk6ICAgIGRhdGEucGFzdF9tZWRpY2FsX2hpc3RvcnkgPz8gXCJcIixcbiAgICAgICAgcGFzdF9zdXJnaWNhbF9oaXN0b3J5OiAgIGRhdGEucGFzdF9zdXJnaWNhbF9oaXN0b3J5ID8/IFwiXCIsXG4gICAgICAgIGNoaWVmX2NvbXBsYWludDogICAgICAgICBkYXRhLmNoaWVmX2NvbXBsYWludCA/PyBcIlwiLFxuICAgICAgICBhbGxlcmdpZXNfdGV4dDogICAgICAgICAgZGF0YS5hbGxlcmdpZXNfdGV4dCA/PyBcIlwiLFxuICAgICAgICBtZWRpY2F0aW9uc19jdXJyZW50OiAgICAgbWVkc0N1cnJlbnQsXG4gICAgICAgIG1lZGljYXRpb25zOiAgICAgICAgICAgICBtZWRzQ3VycmVudCwgICAgICAgICAgIC8vIG1pcnJvciBmb3IgVUkgY29tcGF0aWJpbGl0eVxuICAgICAgICBmYW1pbHlfaGlzdG9yeTogICAgICAgICAgZGF0YS5mYW1pbHlfaHggPz8gXCJcIiwgIC8vIHNvdXJjZSBpcyBmYW1pbHlfaHhcbiAgICAgICAgc21va2luZ19oeDogICAgICAgICAgICAgIGRhdGEuc21va2luZ19oeCA/PyBcIlwiLFxuICAgICAgICBhbGNvaG9sX2h4OiAgICAgICAgICAgICAgZGF0YS5hbGNvaG9sX2h4ID8/IFwiXCIsXG4gICAgICAgIHZpdGFscyxcbiAgICAgIH07XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZ2V0VmlzaXRzKHBhdGllbnRfaWQ6IHN0cmluZyk6IFByb21pc2U8VmlzaXRbXT4ge1xuICAgICAgY29uc3QgcGlkID0gZXNjYXBlTGlrZUV4YWN0KFN0cmluZyhwYXRpZW50X2lkIHx8IFwiXCIpLnRyaW0oKSk7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBkYlxuICAgICAgICAuZnJvbShUQUJMRV9SRVNVTFRTKVxuICAgICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZCk7XG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cbiAgICAgIGNvbnN0IHNlZW4gPSBuZXcgTWFwPHN0cmluZywgVmlzaXQ+KCk7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgKGRhdGEgfHwgW10pIGFzIFJlY29yZDxzdHJpbmcsIGFueT5bXSkge1xuICAgICAgICBjb25zdCBkYXRlID0gU3RyaW5nKHIuZGF0ZV9vZl90ZXN0ID8/IHIuZGF0ZSA/PyByLnRlc3RfZGF0ZSA/PyBcIlwiKS50cmltKCk7XG4gICAgICAgIGlmICghZGF0ZSB8fCBpc1BsYWNlaG9sZGVyKGRhdGUpKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFzZWVuLmhhcyhkYXRlKSkge1xuICAgICAgICAgIHNlZW4uc2V0KGRhdGUsIHtcbiAgICAgICAgICAgIGRhdGVfb2ZfdGVzdDogZGF0ZSxcbiAgICAgICAgICAgIGJhcmNvZGU6IHIuYmFyY29kZSA/PyBcIlwiLFxuICAgICAgICAgICAgYnJhbmNoOiAgci5icmFuY2ggPz8gXCJcIixcbiAgICAgICAgICAgIG5vdGVzOiAgIHIubm90ZXMgPz8gXCJcIixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oc2Vlbi52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gdHMoYi5kYXRlX29mX3Rlc3QpIC0gdHMoYS5kYXRlX29mX3Rlc3QpKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZ2V0UmVwb3J0KHsgcGF0aWVudF9pZCwgdmlzaXREYXRlIH06IHsgcGF0aWVudF9pZDogc3RyaW5nOyB2aXNpdERhdGU/OiBzdHJpbmc7IH0pOiBQcm9taXNlPFJlcG9ydCB8IG51bGw+IHtcbiAgICAgIGNvbnN0IHBhdGllbnQgPSBhd2FpdCB0aGlzLmdldFBhdGllbnQocGF0aWVudF9pZCk7XG4gICAgICBpZiAoIXBhdGllbnQpIHJldHVybiBudWxsO1xuXG4gICAgICBsZXQgZGF0ZSA9IHZpc2l0RGF0ZTtcbiAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICBjb25zdCB2aXNpdHMgPSBhd2FpdCB0aGlzLmdldFZpc2l0cyhwYXRpZW50X2lkKTtcbiAgICAgICAgZGF0ZSA9IHZpc2l0c1swXT8uZGF0ZV9vZl90ZXN0O1xuICAgICAgICBpZiAoIWRhdGUpIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwaWQgPSBlc2NhcGVMaWtlRXhhY3QoU3RyaW5nKHBhdGllbnRfaWQgfHwgXCJcIikudHJpbSgpKTtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGRiXG4gICAgICAgIC5mcm9tKFRBQkxFX1JFU1VMVFMpXG4gICAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKVxuICAgICAgICAuZXEoXCJkYXRlX29mX3Rlc3RcIiwgZGF0ZSk7XG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgICBjb25zdCByb3dzID0gKGRhdGEgPz8gW10pIGFzIFJlY29yZDxzdHJpbmcsIGFueT5bXTtcbiAgICAgIGlmIChyb3dzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNvbnN0IHsgbWFwOiByYW5nZXNNYXAsIHJvd3M6IHJhbmdlc1Jvd3MgfSA9IGF3YWl0IGdldFJhbmdlc01hcCgpO1xuICAgICAgY29uc3QgYnlTZWN0aW9uID0gbmV3IE1hcDxzdHJpbmcsIFJlcG9ydEl0ZW1bXT4oKTtcblxuICAgICAgZm9yIChjb25zdCByIG9mIHJvd3MpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gU3RyaW5nKFxuICAgICAgICAgIHIuaXRlbV9rZXkgPz9cbiAgICAgICAgICByLmFuYWx5dGVfa2V5ID8/XG4gICAgICAgICAgci5wYXJhbWV0ZXJfa2V5ID8/XG4gICAgICAgICAgci5wYXJhbV9rZXkgPz9cbiAgICAgICAgICByLmtleSA/P1xuICAgICAgICAgIFwiXCJcbiAgICAgICAgKS50cmltKCk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBrZXkgPyByYW5nZXNNYXAuZ2V0KGtleSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY29uc3QgbGFiZWwgPSBTdHJpbmcoXG4gICAgICAgICAgcGljayhcbiAgICAgICAgICAgIHIuaXRlbV9sYWJlbCxcbiAgICAgICAgICAgIHIuZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgci5wYXJhbWV0ZXJfbGFiZWwsXG4gICAgICAgICAgICByLmxhYmVsLFxuICAgICAgICAgICAgbWV0YT8ubGFiZWwsXG4gICAgICAgICAgICBrZXkgfHwgbnVsbFxuICAgICAgICAgICkgPz8gXCJcIlxuICAgICAgICApLnRyaW0oKTtcblxuICAgICAgICAvLyB1bml0OiBuZXZlciBhbGxvdyBcIm51bGxcIiBzdHJpbmdcbiAgICAgICAgY29uc3QgdW5pdFJhdyA9IHBpY2soci51bml0LCByLnVuaXRzLCByLnVvbSwgbWV0YT8udW5pdCk7XG4gICAgICAgIGNvbnN0IHVuaXQgPSB1bml0UmF3ID09IG51bGwgPyBcIlwiIDogU3RyaW5nKHVuaXRSYXcpO1xuXG4gICAgICAgIC8vIHNlY3Rpb24gZnJvbSByYW5nZXMgb3IgcHJlZml4XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSBTdHJpbmcoXG4gICAgICAgICAgcGljayhyLnNlY3Rpb24sIHIuaXRlbV9zZWN0aW9uLCByLmRlcHQsIHIuY2F0ZWdvcnksIG1ldGE/LnNlY3Rpb24sIHByZWZpeFRvU2VjdGlvbihrZXkgfHwgbGFiZWwpLCBcIk90aGVyc1wiKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHZhbHVlOiB0cmVhdCBcIi1cIiBldGMgYXMgbnVsbDsga2VlcCBudW1lcmljIGlmIHBvc3NpYmxlIGZvciBmbGFnc1xuICAgICAgICBjb25zdCByYXdWYWwgPSBwaWNrKHIudmFsdWUsIHIucmVzdWx0LCByLnZhbCk7XG4gICAgICAgIGNvbnN0IHZhbHVlTnVtID0gdG9OdW0ocmF3VmFsKTtcbiAgICAgICAgY29uc3QgdmFsdWU6IG51bWJlciB8IHN0cmluZyB8IG51bGwgPVxuICAgICAgICAgIHZhbHVlTnVtICE9PSBudWxsID8gdmFsdWVOdW0gOiAoaXNQbGFjZWhvbGRlcihyYXdWYWwpID8gbnVsbCA6IChyYXdWYWwgYXMgYW55KSk7XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlcyAoZGlzcGxheSByYXcsIGNvbXB1dGUgZmxhZ3MgdmlhIG51bWVyaWMpXG4gICAgICAgIGNvbnN0IHJhd0xvdyAgPSBwaWNrKHIucmVmX2xvdywgIHIubG93LCAgbWV0YT8ubG93KTtcbiAgICAgICAgY29uc3QgcmF3SGlnaCA9IHBpY2soci5yZWZfaGlnaCwgci5oaWdoLCBtZXRhPy5oaWdoKTtcbiAgICAgICAgY29uc3QgcmVmX2xvd19kaXNwbGF5ICA9IGlzUGxhY2Vob2xkZXIocmF3TG93KSAgPyBudWxsIDogKHJhd0xvdyAgYXMgYW55KTtcbiAgICAgICAgY29uc3QgcmVmX2hpZ2hfZGlzcGxheSA9IGlzUGxhY2Vob2xkZXIocmF3SGlnaCkgPyBudWxsIDogKHJhd0hpZ2ggYXMgYW55KTtcbiAgICAgICAgY29uc3QgcmVmTG93TnVtICA9IHRvTnVtKHJhd0xvdyk7XG4gICAgICAgIGNvbnN0IHJlZkhpZ2hOdW0gPSB0b051bShyYXdIaWdoKTtcblxuICAgICAgICAvLyBmbGFnOiBwcmVmZXIgREI7IGVsc2UgY29tcHV0ZSBML0ggb25seSAoZG8gTk9UIHNob3cgXCJOXCIpXG4gICAgICAgIGxldCBmbGFnOiBcIkxcIiB8IFwiSFwiIHwgXCJBXCIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgY29uc3QgcmF3RmxhZyA9IChwaWNrKHIuZmxhZykgYXMgYW55KSA/PyBudWxsO1xuICAgICAgICBpZiAocmF3RmxhZykge1xuICAgICAgICAgIGNvbnN0IGYgPSBTdHJpbmcocmF3RmxhZykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBpZiAoZiA9PT0gXCJMXCIgfHwgZiA9PT0gXCJIXCIgfHwgZiA9PT0gXCJBXCIpIGZsYWcgPSBmIGFzIGFueTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZU51bSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZWZMb3dOdW0gIT09IG51bGwgJiYgdmFsdWVOdW0gPCByZWZMb3dOdW0pIGZsYWcgPSBcIkxcIjtcbiAgICAgICAgICBlbHNlIGlmIChyZWZIaWdoTnVtICE9PSBudWxsICYmIHZhbHVlTnVtID4gcmVmSGlnaE51bSkgZmxhZyA9IFwiSFwiO1xuICAgICAgICAgIC8vIGVsc2Ugbm9ybWFsIOKGkiBsZWF2ZSBudWxsICh5b3UgZG9uJ3Qgd2FudCBcIk5cIilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGl0ZW06IFJlcG9ydEl0ZW0gPSB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgcmVmX2xvdzogIHJlZl9sb3dfZGlzcGxheSxcbiAgICAgICAgICByZWZfaGlnaDogcmVmX2hpZ2hfZGlzcGxheSxcbiAgICAgICAgICBmbGFnLFxuICAgICAgICAgIG1ldGhvZDogIHIubWV0aG9kID8/IG51bGwsXG4gICAgICAgICAgcmVtYXJrczogci5yZW1hcmtzID8/IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2tpcCBwbGFjZWhvbGRlcnMvYmxhbmsgdmFsdWVzIGVudGlyZWx5IChkb24ndCByZW5kZXIpXG4gICAgICAgIGlmIChpdGVtLnZhbHVlID09PSBudWxsIHx8ICh0eXBlb2YgaXRlbS52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBpc1BsYWNlaG9sZGVyKGl0ZW0udmFsdWUpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXJyID0gYnlTZWN0aW9uLmdldChzZWN0aW9uKSA/PyBbXTtcbiAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgICAgIGJ5U2VjdGlvbi5zZXQoc2VjdGlvbiwgYXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gc29ydCBpdGVtcyBpbiBlYWNoIHNlY3Rpb25cbiAgICAgIGxldCBzZWN0aW9uczogUmVwb3J0U2VjdGlvbltdID1cbiAgICAgICAgQXJyYXkuZnJvbShieVNlY3Rpb24uZW50cmllcygpKVxuICAgICAgICAgIC5tYXAoKFtuYW1lLCBpdGVtc10pID0+ICh7IG5hbWUsIGl0ZW1zIH0pKVxuICAgICAgICAgIC5maWx0ZXIoc2VjID0+IHNlYy5pdGVtcy5zb21lKGkgPT4gaS52YWx1ZSAhPT0gbnVsbCAmJiBTdHJpbmcoaS52YWx1ZSkudHJpbSgpICE9PSBcIlwiKSk7XG4gICAgICBzZWN0aW9ucyA9IHNvcnRJdGVtc0luU2VjdGlvbnMoc2VjdGlvbnMsIHJhbmdlc1Jvd3MpO1xuXG4gICAgICBjb25zdCBmaXJzdCA9IHJvd3NbMF0gfHwge307XG4gICAgICBjb25zdCB2aXNpdDogVmlzaXQgPSB7XG4gICAgICAgIGRhdGVfb2ZfdGVzdDogZGF0ZSxcbiAgICAgICAgYmFyY29kZTogZmlyc3QuYmFyY29kZSA/PyBcIlwiLFxuICAgICAgICBicmFuY2g6ICBmaXJzdC5icmFuY2ggPz8gXCJcIixcbiAgICAgICAgbm90ZXM6ICAgZmlyc3Qubm90ZXMgPz8gXCJcIixcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7IHBhdGllbnQsIHZpc2l0LCBzZWN0aW9ucyB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBzZWFyY2hQYXRpZW50cyh7IHF1ZXJ5LCBsaW1pdCA9IDIwLCBvZmZzZXQgPSAwIH0pIHtcbiAgICAgIGNvbnN0IHEgPSAocXVlcnkgfHwgXCJcIikudHJpbSgpO1xuICAgICAgaWYgKCFxKSByZXR1cm4geyByZXN1bHRzOiBbXSwgdG90YWw6IDAgfTtcblxuICAgICAgY29uc3QgcGF0ID0gYCUke3EucmVwbGFjZSgvWyVfXS9nLCAobSkgPT4gYFxcXFwke219YCl9JWA7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yLCBjb3VudCB9ID0gYXdhaXQgZGJcbiAgICAgICAgLmZyb20oVEFCTEVfUEFUSUVOVFMpXG4gICAgICAgIC5zZWxlY3QoXCJwYXRpZW50X2lkLCBmdWxsX25hbWUsIHNleCwgYWdlLCBiaXJ0aGRheSwgY29udGFjdCwgYWRkcmVzcywgZW1haWxcIiwgeyBjb3VudDogXCJleGFjdFwiIH0pXG4gICAgICAgIC5vcihgcGF0aWVudF9pZC5pbGlrZS4ke3BhdH0sZnVsbF9uYW1lLmlsaWtlLiR7cGF0fWApXG4gICAgICAgIC5vcmRlcihcImZ1bGxfbmFtZVwiLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgICAgICAucmFuZ2Uob2Zmc2V0LCBvZmZzZXQgKyBsaW1pdCAtIDEpO1xuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgICAgcmV0dXJuIHsgcmVzdWx0czogKGRhdGEgfHwgW10pIGFzIFBhdGllbnRbXSwgdG90YWw6IGNvdW50ID8/IHVuZGVmaW5lZCB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBnZXRDb25maWcoKSB7XG4gICAgICByZXR1cm4geyBmb290ZXJfbGluZXM6IFtdLCBzaWduYXRvcmllczogW10gfTtcbiAgICB9LFxuICB9O1xufVxuIl0sIm5hbWVzIjpbImdldFN1cGFiYXNlIiwiaXNQbGFjZWhvbGRlciIsIngiLCJ1bmRlZmluZWQiLCJzIiwiU3RyaW5nIiwidHJpbSIsInRvTG93ZXJDYXNlIiwidHMiLCJkIiwidCIsIkRhdGUiLCJwYXJzZSIsIk51bWJlciIsImlzTmFOIiwibSIsIm1hdGNoIiwiYSIsInBhcnNlSW50IiwiYiIsInkiLCJsZW5ndGgiLCJpc0RNWSIsIm1vbnRoIiwiZGF5IiwiZ2V0VGltZSIsInRvTnVtIiwicmVwbGFjZSIsIm4iLCJpc0Zpbml0ZSIsInBpY2siLCJ2YWxzIiwidiIsImVzY2FwZUxpa2VFeGFjdCIsInByZWZpeFRvU2VjdGlvbiIsImtleSIsImsiLCJzdGFydHNXaXRoIiwiREVGQVVMVF9PUkRFUiIsIkhlbWF0b2xvZ3kiLCJVcmluYWx5c2lzIiwiRmVjYWx5c2lzIiwiU2Vyb2xvZ3kiLCJPdGhlcnMiLCJidWlsZE9yZGVySW5kZXgiLCJyYW5nZXNSb3dzIiwiYnlLZXlPcmRlciIsIk1hcCIsInIiLCJhbmFseXRlX2tleSIsInBhcmFtZXRlcl9rZXkiLCJwYXJhbV9rZXkiLCJvcmRlclJhdyIsIm9yZGVyIiwic29ydF9vcmRlciIsInJhbmsiLCJwcmlvIiwib3JkZXJOdW0iLCJzZXQiLCJzb3J0SXRlbXNJblNlY3Rpb25zIiwic2VjdGlvbnMiLCJvcmRlckluZGV4IiwibWFwIiwic2VjIiwiZGVmYXVsdHMiLCJuYW1lIiwiZGVmYXVsdEluZGV4IiwiZm9yRWFjaCIsImkiLCJpdGVtcyIsInNvcnQiLCJhbyIsImdldCIsImJvIiwiYWQiLCJiZCIsImFsIiwibGFiZWwiLCJibCIsImxvY2FsZUNvbXBhcmUiLCJjcmVhdGVTdXBhYmFzZVByb3ZpZGVyIiwiVEFCTEVfUEFUSUVOVFMiLCJUQUJMRV9SRVNVTFRTIiwiVEFCTEVfUkFOR0VTIiwiVEFCTEVfVklUQUxTIiwiZGIiLCJyYW5nZXNDYWNoZSIsInJhbmdlc1Jvd3NDYWNoZSIsImdldFJhbmdlc01hcCIsInJvd3MiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwic2VjdGlvbiIsImdyb3VwIiwiY2F0ZWdvcnkiLCJpdGVtX2xhYmVsIiwiZGlzcGxheV9uYW1lIiwidW5pdCIsInVuaXRzIiwidW9tIiwibG93IiwiaGlnaCIsImZldGNoVml0YWxzU25hcHNob3RzIiwicGF0aWVudF9pZCIsIm9wdHMiLCJwaWQiLCJxdWVyeSIsImlsaWtlIiwiYXNjZW5kaW5nIiwiY29uc3VsdGF0aW9uX2lkIiwiZXEiLCJlbmNvdW50ZXJfaWQiLCJsaW1pdCIsImlkIiwibWVhc3VyZWRfYXQiLCJjcmVhdGVkX2F0IiwidG9JU09TdHJpbmciLCJzeXN0b2xpY19icCIsImRpYXN0b2xpY19icCIsImhyIiwicnIiLCJ0ZW1wX2MiLCJoZWlnaHRfY20iLCJ3ZWlnaHRfa2ciLCJibWkiLCJvMnNhdCIsIm5vdGVzIiwic291cmNlIiwiY3JlYXRlZF9ieV9pbml0aWFscyIsImxhdGVzdCIsImhpc3RvcnkiLCJnZXRQYXRpZW50IiwibWF5YmVTaW5nbGUiLCJtZWRzQ3VycmVudCIsIm1lZGljYXRpb25zX2N1cnJlbnQiLCJ2aXRhbHMiLCJjYXRjaCIsInAiLCJmdWxsX25hbWUiLCJzZXgiLCJhZ2UiLCJiaXJ0aGRheSIsImNvbnRhY3QiLCJhZGRyZXNzIiwiZW1haWwiLCJoZWlnaHRfZnQiLCJoZWlnaHRfaW5jaCIsImxhc3RfdXBkYXRlZCIsInByZXNlbnRfaWxsbmVzc19oaXN0b3J5IiwicGFzdF9tZWRpY2FsX2hpc3RvcnkiLCJwYXN0X3N1cmdpY2FsX2hpc3RvcnkiLCJjaGllZl9jb21wbGFpbnQiLCJhbGxlcmdpZXNfdGV4dCIsIm1lZGljYXRpb25zIiwiZmFtaWx5X2hpc3RvcnkiLCJmYW1pbHlfaHgiLCJzbW9raW5nX2h4IiwiYWxjb2hvbF9oeCIsImdldFZpc2l0cyIsInNlZW4iLCJkYXRlIiwiZGF0ZV9vZl90ZXN0IiwidGVzdF9kYXRlIiwiaGFzIiwiYmFyY29kZSIsImJyYW5jaCIsIkFycmF5IiwidmFsdWVzIiwiZ2V0UmVwb3J0IiwidmlzaXREYXRlIiwicGF0aWVudCIsInZpc2l0cyIsInJhbmdlc01hcCIsImJ5U2VjdGlvbiIsIml0ZW1fa2V5IiwibWV0YSIsInBhcmFtZXRlcl9sYWJlbCIsInVuaXRSYXciLCJpdGVtX3NlY3Rpb24iLCJkZXB0IiwicmF3VmFsIiwidmFsdWUiLCJyZXN1bHQiLCJ2YWwiLCJ2YWx1ZU51bSIsInJhd0xvdyIsInJlZl9sb3ciLCJyYXdIaWdoIiwicmVmX2hpZ2giLCJyZWZfbG93X2Rpc3BsYXkiLCJyZWZfaGlnaF9kaXNwbGF5IiwicmVmTG93TnVtIiwicmVmSGlnaE51bSIsImZsYWciLCJyYXdGbGFnIiwiZiIsInRvVXBwZXJDYXNlIiwiaXRlbSIsIm1ldGhvZCIsInJlbWFya3MiLCJhcnIiLCJwdXNoIiwiZW50cmllcyIsImZpbHRlciIsInNvbWUiLCJmaXJzdCIsInZpc2l0Iiwic2VhcmNoUGF0aWVudHMiLCJvZmZzZXQiLCJxIiwicmVzdWx0cyIsInRvdGFsIiwicGF0IiwiY291bnQiLCJvciIsInJhbmdlIiwiZ2V0Q29uZmlnIiwiZm9vdGVyX2xpbmVzIiwic2lnbmF0b3JpZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/data/supabase-provider.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSupabase: () => (/* binding */ getSupabase),\n/* harmony export */   getSupabaseBrowser: () => (/* binding */ getSupabaseBrowser),\n/* harmony export */   sbListVitalsByPatient: () => (/* binding */ sbListVitalsByPatient),\n/* harmony export */   sbReadConfig: () => (/* binding */ sbReadConfig),\n/* harmony export */   sbReadLatestVitalsByPatient: () => (/* binding */ sbReadLatestVitalsByPatient),\n/* harmony export */   sbReadPatientById: () => (/* binding */ sbReadPatientById),\n/* harmony export */   sbReadRanges: () => (/* binding */ sbReadRanges),\n/* harmony export */   sbReadResultsByPatient: () => (/* binding */ sbReadResultsByPatient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/../../node_modules/.pnpm/@supabase+supabase-js@2.74.0/node_modules/@supabase/supabase-js/dist/module/index.js\");\n// lib/supabase.ts\n\nconst SUPABASE_URL = process.env.SUPABASE_URL;\nconst SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;\nif (!SUPABASE_URL) throw new Error(\"SUPABASE_URL is required\");\nif (!SUPABASE_SERVICE_ROLE_KEY) throw new Error(\"SUPABASE_SERVICE_ROLE_KEY is required\");\nfunction getSupabase() {\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {\n        auth: {\n            autoRefreshToken: false,\n            persistSession: false\n        }\n    });\n}\nconst SUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpndXdpdmNkZGVqam9wd3hubW55Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg1MDMwMzksImV4cCI6MjA3NDA3OTAzOX0.iHai-vNwyTK3j8yLdbqZrU_BlvLOysevGVn229k_XGg\"; // public-safe\nfunction getSupabaseBrowser() {\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(SUPABASE_URL, SUPABASE_ANON_KEY, {\n        auth: {\n            autoRefreshToken: true,\n            persistSession: true\n        }\n    });\n}\n// ---------- helpers ----------\nfunction snake(row) {\n    const out = {};\n    for (const [k, v] of Object.entries(row)){\n        const nk = String(k).trim().toLowerCase().replace(/[^\\w]+/g, \"_\").replace(/_+/g, \"_\").replace(/^_+|_+$/g, \"\");\n        out[nk] = v;\n    }\n    return out;\n}\n// Escape % and _ so they DON'T act as wildcards in ILIKE\nfunction escapeLikeExact(s) {\n    return s.replace(/[%_]/g, (m)=>`\\\\${m}`);\n}\n// ---------- readers ----------\n/** Config as a simple key→value map */ async function sbReadConfig() {\n    const supabase = getSupabase();\n    const { data, error } = await supabase.from(\"config\").select(\"key,value\");\n    if (error) throw error;\n    const out = {};\n    for (const r of data || []){\n        const k = String(r.key ?? \"\").trim();\n        if (k) out[k] = String(r.value ?? \"\");\n    }\n    return out;\n}\n/** Ranges shaped like the old sheet */ async function sbReadRanges() {\n    const supabase = getSupabase();\n    const { data, error } = await supabase.from(\"ranges\").select(\"*\");\n    if (error) throw error;\n    return (data || []).map(snake);\n}\n/** Prefer results_wide (1 row per visit) */ async function sbReadResultsWideByPatient(patientId) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    const { data, error } = await supabase.from(\"results_wide\").select(\"*\").ilike(\"patient_id\", pid) // exact case-insensitive match (no wildcards)\n    .order(\"date_of_test\", {\n        ascending: true\n    });\n    if (error) throw error;\n    return (data || []).map(snake);\n}\n/** Fallback: read results_flat and pivot flat→wide per visit */ async function sbReadResultsFlatByPatient(patientId) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    const { data, error } = await supabase.from(\"results_flat\").select(\"*\").ilike(\"patient_id\", pid).order(\"date_of_test\", {\n        ascending: true\n    }).order(\"id\", {\n        ascending: true\n    });\n    if (error) throw error;\n    const flat = (data || []).map(snake);\n    if (!flat.length) return [];\n    // discover likely key/value columns\n    const keyField = [\n        \"analyte_key\",\n        \"key\",\n        \"parameter_key\",\n        \"param_key\",\n        \"analyte\",\n        \"parameter\"\n    ].find((k)=>k in flat[0]) || \"analyte_key\";\n    const valField = [\n        \"value\",\n        \"result\",\n        \"val\",\n        \"res\"\n    ].find((k)=>k in flat[0]) || \"value\";\n    const groups = new Map();\n    for (const r of flat){\n        const gk = [\n            r.patient_id ?? \"\",\n            r.date_of_test ?? \"\",\n            r.barcode ?? \"\",\n            r.notes ?? \"\"\n        ].join(\"|\");\n        let obj = groups.get(gk);\n        if (!obj) {\n            obj = {\n                patient_id: r.patient_id ?? \"\",\n                date_of_test: r.date_of_test ?? \"\",\n                barcode: r.barcode ?? \"\",\n                notes: r.notes ?? \"\"\n            };\n            groups.set(gk, obj);\n        }\n        const key = String(r[keyField] ?? \"\").trim();\n        if (key) obj[key] = r[valField] ?? \"\";\n    }\n    return Array.from(groups.values()).map(snake);\n}\n/** Public: read results as \"wide\" rows, using wide first then flat→wide */ async function sbReadResultsByPatient(patientId) {\n    const wide = await sbReadResultsWideByPatient(patientId);\n    if (wide.length) return wide;\n    return await sbReadResultsFlatByPatient(patientId);\n}\n/** Patient summary (Patients table) */ async function sbReadPatientById(patientId) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    const { data, error } = await supabase.from(\"patients\").select(\"*\").ilike(\"patient_id\", pid).limit(1).maybeSingle();\n    if (error) throw error;\n    return data ? snake(data) : null;\n}\nasync function sbListVitalsByPatient(patientId, opts) {\n    const supabase = getSupabase();\n    const pid = escapeLikeExact(String(patientId || \"\").trim());\n    let query = supabase.from(\"vitals_snapshots\").select(\"*\").ilike(\"patient_id\", pid).order(\"measured_at\", {\n        ascending: false\n    });\n    if (opts?.consultationId) query = query.eq(\"consultation_id\", opts.consultationId);\n    if (opts?.encounterId) query = query.eq(\"encounter_id\", opts.encounterId);\n    query = query.limit(opts?.limit ?? 8);\n    const { data, error } = await query;\n    if (error) throw error;\n    return (data || []).map((r)=>snake(r));\n}\nasync function sbReadLatestVitalsByPatient(patientId, opts) {\n    const rows = await sbListVitalsByPatient(patientId, {\n        ...opts,\n        limit: 1\n    });\n    return rows[0] ?? null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVExQyxTQUNURyxJQUFJLENBQUMsb0JBQ0xDLE1BQU0sQ0FBQyxLQUNQUyxLQUFLLENBQUMsY0FBY0QsS0FDcEJFLEtBQUssQ0FBQyxlQUFlO1FBQUVDLFdBQVc7SUFBTTtJQUUzQyxJQUFJMEIsTUFBTUUsZ0JBQWdCRCxRQUFRQSxNQUFNRSxFQUFFLENBQUMsbUJBQW1CSCxLQUFLRSxjQUFjO0lBQ2pGLElBQUlGLE1BQU1JLGFBQWFILFFBQVFBLE1BQU1FLEVBQUUsQ0FBQyxnQkFBZ0JILEtBQUtJLFdBQVc7SUFDeEVILFFBQVFBLE1BQU1KLEtBQUssQ0FBQ0csTUFBTUgsU0FBUztJQUVuQyxNQUFNLEVBQUVyQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU13QztJQUM5QixJQUFJeEMsT0FBTyxNQUFNQTtJQUNqQixPQUFPLENBQUNELFFBQVEsRUFBRSxFQUFFUSxHQUFHLENBQUMsQ0FBQ0osSUFBTXJCLE1BQU1xQjtBQUN2QztBQUVPLGVBQWV5Qyw0QkFDcEJuQyxTQUFpQixFQUNqQjhCLElBQXdEO0lBRXhELE1BQU1NLE9BQU8sTUFBTVAsc0JBQXNCN0IsV0FBVztRQUFFLEdBQUc4QixJQUFJO1FBQUVILE9BQU87SUFBRTtJQUN4RSxPQUFPUyxJQUFJLENBQUMsRUFBRSxJQUFJO0FBQ3BCIiwic291cmNlcyI6WyIvVXNlcnMvcG9jaG9sby9Qcm9qZWN0cy93ZWxsc2Vydi1wb3J0YWwvYXBwcy93ZWIvbGliL3N1cGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9zdXBhYmFzZS50c1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50LCBTdXBhYmFzZUNsaWVudCB9IGZyb20gXCJAc3VwYWJhc2Uvc3VwYWJhc2UtanNcIjtcblxuY29uc3QgU1VQQUJBU0VfVVJMID0gcHJvY2Vzcy5lbnYuU1VQQUJBU0VfVVJMO1xuY29uc3QgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSA9IHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVk7XG5cbmlmICghU1VQQUJBU0VfVVJMKSB0aHJvdyBuZXcgRXJyb3IoXCJTVVBBQkFTRV9VUkwgaXMgcmVxdWlyZWRcIik7XG5pZiAoIVNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkpIHRocm93IG5ldyBFcnJvcihcIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkgaXMgcmVxdWlyZWRcIik7XG5cbmV4cG9ydCB0eXBlIFJvdyA9IFJlY29yZDxzdHJpbmcsIGFueT47XG5leHBvcnQgdHlwZSBWaXRhbHNTbmFwc2hvdFJvdyA9IFJvdyAmIHtcbiAgaWQ6IHN0cmluZztcbiAgcGF0aWVudF9pZDogc3RyaW5nO1xuICBjb25zdWx0YXRpb25faWQ6IHN0cmluZztcbiAgZW5jb3VudGVyX2lkOiBzdHJpbmc7XG4gIG1lYXN1cmVkX2F0OiBzdHJpbmc7XG4gIHN5c3RvbGljX2JwPzogbnVtYmVyIHwgbnVsbDtcbiAgZGlhc3RvbGljX2JwPzogbnVtYmVyIHwgbnVsbDtcbiAgaHI/OiBudW1iZXIgfCBudWxsO1xuICBycj86IG51bWJlciB8IG51bGw7XG4gIHRlbXBfYz86IG51bWJlciB8IG51bGw7XG4gIGhlaWdodF9jbT86IG51bWJlciB8IG51bGw7XG4gIHdlaWdodF9rZz86IG51bWJlciB8IG51bGw7XG4gIGJtaT86IG51bWJlciB8IG51bGw7XG4gIG8yc2F0PzogbnVtYmVyIHwgbnVsbDtcbiAgbm90ZXM/OiBzdHJpbmcgfCBudWxsO1xuICBzb3VyY2U/OiBzdHJpbmcgfCBudWxsO1xuICBjcmVhdGVkX2J5X2luaXRpYWxzPzogc3RyaW5nIHwgbnVsbDtcbiAgY3JlYXRlZF9hdD86IHN0cmluZyB8IG51bGw7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VwYWJhc2UoKTogU3VwYWJhc2VDbGllbnQge1xuICByZXR1cm4gY3JlYXRlQ2xpZW50KFNVUEFCQVNFX1VSTCEsIFNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkhLCB7XG4gICAgYXV0aDogeyBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSwgcGVyc2lzdFNlc3Npb246IGZhbHNlIH0sXG4gIH0pO1xufVxuXG5jb25zdCBTVVBBQkFTRV9BTk9OX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZOyAvLyBwdWJsaWMtc2FmZVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VwYWJhc2VCcm93c2VyKCk6IFN1cGFiYXNlQ2xpZW50IHtcbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChTVVBBQkFTRV9VUkwhLCBTVVBBQkFTRV9BTk9OX0tFWSEsIHtcbiAgICBhdXRoOiB7IGF1dG9SZWZyZXNoVG9rZW46IHRydWUsIHBlcnNpc3RTZXNzaW9uOiB0cnVlIH0sXG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tIGhlbHBlcnMgLS0tLS0tLS0tLVxuZnVuY3Rpb24gc25ha2U8VCBleHRlbmRzIFJvdz4ocm93OiBUKTogVCB7XG4gIGNvbnN0IG91dDogUm93ID0ge307XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHJvdykpIHtcbiAgICBjb25zdCBuayA9IFN0cmluZyhrKVxuICAgICAgLnRyaW0oKVxuICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgIC5yZXBsYWNlKC9bXlxcd10rL2csIFwiX1wiKVxuICAgICAgLnJlcGxhY2UoL18rL2csIFwiX1wiKVxuICAgICAgLnJlcGxhY2UoL15fK3xfKyQvZywgXCJcIik7XG4gICAgb3V0W25rXSA9IHY7XG4gIH1cbiAgcmV0dXJuIG91dCBhcyBUO1xufVxuXG4vLyBFc2NhcGUgJSBhbmQgXyBzbyB0aGV5IERPTidUIGFjdCBhcyB3aWxkY2FyZHMgaW4gSUxJS0VcbmZ1bmN0aW9uIGVzY2FwZUxpa2VFeGFjdChzOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvWyVfXS9nLCAobSkgPT4gYFxcXFwke219YCk7XG59XG5cbi8vIC0tLS0tLS0tLS0gcmVhZGVycyAtLS0tLS0tLS0tXG4vKiogQ29uZmlnIGFzIGEgc2ltcGxlIGtleeKGknZhbHVlIG1hcCAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNiUmVhZENvbmZpZygpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZSgpO1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwiY29uZmlnXCIpLnNlbGVjdChcImtleSx2YWx1ZVwiKTtcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgY29uc3Qgb3V0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGZvciAoY29uc3QgciBvZiBkYXRhIHx8IFtdKSB7XG4gICAgY29uc3QgayA9IFN0cmluZyhyLmtleSA/PyBcIlwiKS50cmltKCk7XG4gICAgaWYgKGspIG91dFtrXSA9IFN0cmluZyhyLnZhbHVlID8/IFwiXCIpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKiBSYW5nZXMgc2hhcGVkIGxpa2UgdGhlIG9sZCBzaGVldCAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNiUmVhZFJhbmdlcygpOiBQcm9taXNlPFJvd1tdPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0U3VwYWJhc2UoKTtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInJhbmdlc1wiKS5zZWxlY3QoXCIqXCIpO1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICByZXR1cm4gKGRhdGEgfHwgW10pLm1hcChzbmFrZSk7XG59XG5cbi8qKiBQcmVmZXIgcmVzdWx0c193aWRlICgxIHJvdyBwZXIgdmlzaXQpICovXG5hc3luYyBmdW5jdGlvbiBzYlJlYWRSZXN1bHRzV2lkZUJ5UGF0aWVudChwYXRpZW50SWQ6IHN0cmluZyk6IFByb21pc2U8Um93W10+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZSgpO1xuICBjb25zdCBwaWQgPSBlc2NhcGVMaWtlRXhhY3QoU3RyaW5nKHBhdGllbnRJZCB8fCBcIlwiKS50cmltKCkpO1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwicmVzdWx0c193aWRlXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZCkgLy8gZXhhY3QgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCAobm8gd2lsZGNhcmRzKVxuICAgIC5vcmRlcihcImRhdGVfb2ZfdGVzdFwiLCB7IGFzY2VuZGluZzogdHJ1ZSB9KTtcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgcmV0dXJuIChkYXRhIHx8IFtdKS5tYXAoc25ha2UpO1xufVxuXG4vKiogRmFsbGJhY2s6IHJlYWQgcmVzdWx0c19mbGF0IGFuZCBwaXZvdCBmbGF04oaSd2lkZSBwZXIgdmlzaXQgKi9cbmFzeW5jIGZ1bmN0aW9uIHNiUmVhZFJlc3VsdHNGbGF0QnlQYXRpZW50KHBhdGllbnRJZDogc3RyaW5nKTogUHJvbWlzZTxSb3dbXT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGdldFN1cGFiYXNlKCk7XG4gIGNvbnN0IHBpZCA9IGVzY2FwZUxpa2VFeGFjdChTdHJpbmcocGF0aWVudElkIHx8IFwiXCIpLnRyaW0oKSk7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJyZXN1bHRzX2ZsYXRcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKVxuICAgIC5vcmRlcihcImRhdGVfb2ZfdGVzdFwiLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgIC5vcmRlcihcImlkXCIsIHsgYXNjZW5kaW5nOiB0cnVlIH0pO1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXG4gIGNvbnN0IGZsYXQgPSAoZGF0YSB8fCBbXSkubWFwKHNuYWtlKTtcbiAgaWYgKCFmbGF0Lmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gIC8vIGRpc2NvdmVyIGxpa2VseSBrZXkvdmFsdWUgY29sdW1uc1xuICBjb25zdCBrZXlGaWVsZCA9XG4gICAgW1wiYW5hbHl0ZV9rZXlcIiwgXCJrZXlcIiwgXCJwYXJhbWV0ZXJfa2V5XCIsIFwicGFyYW1fa2V5XCIsIFwiYW5hbHl0ZVwiLCBcInBhcmFtZXRlclwiXS5maW5kKFxuICAgICAgKGspID0+IGsgaW4gZmxhdFswXVxuICAgICkgfHwgXCJhbmFseXRlX2tleVwiO1xuICBjb25zdCB2YWxGaWVsZCA9XG4gICAgW1widmFsdWVcIiwgXCJyZXN1bHRcIiwgXCJ2YWxcIiwgXCJyZXNcIl0uZmluZCgoaykgPT4gayBpbiBmbGF0WzBdKSB8fCBcInZhbHVlXCI7XG5cbiAgY29uc3QgZ3JvdXBzID0gbmV3IE1hcDxzdHJpbmcsIFJvdz4oKTtcbiAgZm9yIChjb25zdCByIG9mIGZsYXQpIHtcbiAgICBjb25zdCBnayA9IFtyLnBhdGllbnRfaWQgPz8gXCJcIiwgci5kYXRlX29mX3Rlc3QgPz8gXCJcIiwgci5iYXJjb2RlID8/IFwiXCIsIHIubm90ZXMgPz8gXCJcIl0uam9pbihcInxcIik7XG4gICAgbGV0IG9iaiA9IGdyb3Vwcy5nZXQoZ2spO1xuICAgIGlmICghb2JqKSB7XG4gICAgICBvYmogPSB7XG4gICAgICAgIHBhdGllbnRfaWQ6IHIucGF0aWVudF9pZCA/PyBcIlwiLFxuICAgICAgICBkYXRlX29mX3Rlc3Q6IHIuZGF0ZV9vZl90ZXN0ID8/IFwiXCIsXG4gICAgICAgIGJhcmNvZGU6IHIuYmFyY29kZSA/PyBcIlwiLFxuICAgICAgICBub3Rlczogci5ub3RlcyA/PyBcIlwiLFxuICAgICAgfTtcbiAgICAgIGdyb3Vwcy5zZXQoZ2ssIG9iaik7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IFN0cmluZyhyW2tleUZpZWxkXSA/PyBcIlwiKS50cmltKCk7XG4gICAgaWYgKGtleSkgKG9iaiBhcyBhbnkpW2tleV0gPSByW3ZhbEZpZWxkXSA/PyBcIlwiO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGdyb3Vwcy52YWx1ZXMoKSkubWFwKHNuYWtlKTtcbn1cblxuLyoqIFB1YmxpYzogcmVhZCByZXN1bHRzIGFzIFwid2lkZVwiIHJvd3MsIHVzaW5nIHdpZGUgZmlyc3QgdGhlbiBmbGF04oaSd2lkZSAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNiUmVhZFJlc3VsdHNCeVBhdGllbnQocGF0aWVudElkOiBzdHJpbmcpOiBQcm9taXNlPFJvd1tdPiB7XG4gIGNvbnN0IHdpZGUgPSBhd2FpdCBzYlJlYWRSZXN1bHRzV2lkZUJ5UGF0aWVudChwYXRpZW50SWQpO1xuICBpZiAod2lkZS5sZW5ndGgpIHJldHVybiB3aWRlO1xuICByZXR1cm4gYXdhaXQgc2JSZWFkUmVzdWx0c0ZsYXRCeVBhdGllbnQocGF0aWVudElkKTtcbn1cblxuLyoqIFBhdGllbnQgc3VtbWFyeSAoUGF0aWVudHMgdGFibGUpICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2JSZWFkUGF0aWVudEJ5SWQocGF0aWVudElkOiBzdHJpbmcpOiBQcm9taXNlPFJvdyB8IG51bGw+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZSgpO1xuICBjb25zdCBwaWQgPSBlc2NhcGVMaWtlRXhhY3QoU3RyaW5nKHBhdGllbnRJZCB8fCBcIlwiKS50cmltKCkpO1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwicGF0aWVudHNcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5pbGlrZShcInBhdGllbnRfaWRcIiwgcGlkKVxuICAgIC5saW1pdCgxKVxuICAgIC5tYXliZVNpbmdsZSgpO1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICByZXR1cm4gZGF0YSA/IHNuYWtlKGRhdGEgYXMgUm93KSA6IG51bGw7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYkxpc3RWaXRhbHNCeVBhdGllbnQoXG4gIHBhdGllbnRJZDogc3RyaW5nLFxuICBvcHRzPzogeyBsaW1pdD86IG51bWJlcjsgY29uc3VsdGF0aW9uSWQ/OiBzdHJpbmc7IGVuY291bnRlcklkPzogc3RyaW5nIH1cbik6IFByb21pc2U8Vml0YWxzU25hcHNob3RSb3dbXT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGdldFN1cGFiYXNlKCk7XG4gIGNvbnN0IHBpZCA9IGVzY2FwZUxpa2VFeGFjdChTdHJpbmcocGF0aWVudElkIHx8IFwiXCIpLnRyaW0oKSk7XG4gIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgLmZyb20oXCJ2aXRhbHNfc25hcHNob3RzXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuaWxpa2UoXCJwYXRpZW50X2lkXCIsIHBpZClcbiAgICAub3JkZXIoXCJtZWFzdXJlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgaWYgKG9wdHM/LmNvbnN1bHRhdGlvbklkKSBxdWVyeSA9IHF1ZXJ5LmVxKFwiY29uc3VsdGF0aW9uX2lkXCIsIG9wdHMuY29uc3VsdGF0aW9uSWQpO1xuICBpZiAob3B0cz8uZW5jb3VudGVySWQpIHF1ZXJ5ID0gcXVlcnkuZXEoXCJlbmNvdW50ZXJfaWRcIiwgb3B0cy5lbmNvdW50ZXJJZCk7XG4gIHF1ZXJ5ID0gcXVlcnkubGltaXQob3B0cz8ubGltaXQgPz8gOCk7XG5cbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gIHJldHVybiAoZGF0YSB8fCBbXSkubWFwKChyKSA9PiBzbmFrZShyIGFzIFJvdykpIGFzIFZpdGFsc1NuYXBzaG90Um93W107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYlJlYWRMYXRlc3RWaXRhbHNCeVBhdGllbnQoXG4gIHBhdGllbnRJZDogc3RyaW5nLFxuICBvcHRzPzogeyBjb25zdWx0YXRpb25JZD86IHN0cmluZzsgZW5jb3VudGVySWQ/OiBzdHJpbmcgfVxuKTogUHJvbWlzZTxWaXRhbHNTbmFwc2hvdFJvdyB8IG51bGw+IHtcbiAgY29uc3Qgcm93cyA9IGF3YWl0IHNiTGlzdFZpdGFsc0J5UGF0aWVudChwYXRpZW50SWQsIHsgLi4ub3B0cywgbGltaXQ6IDEgfSk7XG4gIHJldHVybiByb3dzWzBdID8/IG51bGw7XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50IiwiU1VQQUJBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkiLCJFcnJvciIsImdldFN1cGFiYXNlIiwiYXV0aCIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsIlNVUEFCQVNFX0FOT05fS0VZIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJnZXRTdXBhYmFzZUJyb3dzZXIiLCJzbmFrZSIsInJvdyIsIm91dCIsImsiLCJ2IiwiT2JqZWN0IiwiZW50cmllcyIsIm5rIiwiU3RyaW5nIiwidHJpbSIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsImVzY2FwZUxpa2VFeGFjdCIsInMiLCJtIiwic2JSZWFkQ29uZmlnIiwic3VwYWJhc2UiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiciIsImtleSIsInZhbHVlIiwic2JSZWFkUmFuZ2VzIiwibWFwIiwic2JSZWFkUmVzdWx0c1dpZGVCeVBhdGllbnQiLCJwYXRpZW50SWQiLCJwaWQiLCJpbGlrZSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwic2JSZWFkUmVzdWx0c0ZsYXRCeVBhdGllbnQiLCJmbGF0IiwibGVuZ3RoIiwia2V5RmllbGQiLCJmaW5kIiwidmFsRmllbGQiLCJncm91cHMiLCJNYXAiLCJnayIsInBhdGllbnRfaWQiLCJkYXRlX29mX3Rlc3QiLCJiYXJjb2RlIiwibm90ZXMiLCJqb2luIiwib2JqIiwiZ2V0Iiwic2V0IiwiQXJyYXkiLCJ2YWx1ZXMiLCJzYlJlYWRSZXN1bHRzQnlQYXRpZW50Iiwid2lkZSIsInNiUmVhZFBhdGllbnRCeUlkIiwibGltaXQiLCJtYXliZVNpbmdsZSIsInNiTGlzdFZpdGFsc0J5UGF0aWVudCIsIm9wdHMiLCJxdWVyeSIsImNvbnN1bHRhdGlvbklkIiwiZXEiLCJlbmNvdW50ZXJJZCIsInNiUmVhZExhdGVzdFZpdGFsc0J5UGF0aWVudCIsInJvd3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase.ts\n");

/***/ })

};
;